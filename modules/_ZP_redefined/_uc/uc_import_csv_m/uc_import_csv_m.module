<?php

 define('Version', '1.034v 15-11-08');  // версия
 //define('CATALOG_VID', 2);  // номер основного словаря для каталога (позже определяется программно)

/**
 * Converts a CSV file to an XML file ready to be imported into Ubercart via
 * uc_importer.module
 *
 * Uses the SimpleXML PHP extention (since the uc_importer.module does and its
 * a dependant of this module.
 *
 * Developed by Alexander R B Whillas BsCS <codemonkey@tsd.net.au>
 * of Taylor Square Designs (www.tsd.net.au)
 */



/**
 * Do not save objects if the database already contains their names.
 */
define('UC_IMPORTER_DO_NOTHING', 0);

/**
 * Replace objects if the database already contains their names.
 */
define('UC_IMPORTER_REPLACE', 1);

/**
 * Append '_#' to the names of objects already in the database.
 */
define('UC_IMPORTER_INCREMENT', 2);

/**
 * New revision for the node for objects already in the database.
 */

define('UC_IMPORTER_NEW_REVISION', 3);


define('UC_IMPORTER_FROM_FILE', 4);

define('UC_IMPORTER_TEST', 5);

//global $output_i_results;

/**
 * Implementation of hook_menu().
 */
function uc_import_csv_m_menu($may_cache)
{
    global $form_values;
  $items = array();
    $items[] = array(
        'path' => 'admin/store/products/import/csv_m',
        'access' => user_access('import'),
        'title' => t('CSV m /Ver. '. Version),
        'callback' => 'drupal_get_form',
        'callback arguments' => array('uc_import_csv_m_multiform'),
        'type' => MENU_NORMAL_ITEM,
    );


  return $items;
}


/**
 * adapted code from http://www.bytemycode.com/snippets/snippet/448/
 * Returns the headings of the csv file
 *
 * @param $file
 *   String with path to CSV file
 * @param
 *   String, The column delimiter used in the CSV file. Also accepts the tokens: 'comma', 'tab' or 'semi colin'
 * @return
 *   Array
 */
function uc_import_csv_m_load_headings($file, $delimiter = ',')
{
   $titles = array();

   $delimiter = uc_import_csv_m_get_delimiter($delimiter);

    if(file_exists($file))
    {
        if (!$handle = @fopen($file, 'r')) return $handle;

        if(($data = fgetcsv($handle, 0, $delimiter)) !== FALSE)
            for ($i = 0; $i < count($data); $i++)
            {
                $titles[$i] = $data[$i];
            }

        fclose($handle);

        return $titles;
    }
    else
    {
        drupal_set_message('Could not load CSV file: '.$file);
        return false;
    }
}

function uc_import_csv_m_get_delimiter($in = '')
{
    $delimiter_map = array(
        'semi colin'    => ';',
        'comma'         => ',',
        'tab'           => "\t"
    );
    if(isset($delimiter_map[$in]))
        return $delimiter_map[$in];
    elseif(empty($in))
        return  ';';
}




function uc_import_csv_m_get_duplicate_handle($in) // = 'UC_IMPORTER_DO_NOTHING')
{



            $form['step1options']['handle_duplicates'] = array(
                '#type' => 'radios',
                '#title' => t('How should items with similar Artikul_postavki, Shop and Otdel be handled during import?'),
                '#options' => array(
                    UC_IMPORTER_DO_NOTHING => t('Do not save the new item.'),
                    UC_IMPORTER_REPLACE => t('Overwrite the existing item.'),
                    UC_IMPORTER_NEW_REVISION => t('Save the new item as a new revision of existed product.'),
                ),
                '#default_value' => variable_get('uc_importer_handle_duplicates', UC_IMPORTER_DO_NOTHING),
                '#description' => 'This tells the importer how to handle conflict with products already in the stores database.'
            );


    $duplicate_map = array(
        UC_IMPORTER_DO_NOTHING    	=> '1UC_IMPORTER_DO_NOTHING',
	UC_IMPORTER_REPLACE 		=> '2UC_IMPORTER_REPLACE',
        UC_IMPORTER_NEW_REVISION  	=> 'UC_IMPORTER_NEW_REVISION'
    );
    //if(isset($duplicate_map[$in]))
        //return $duplicate_map[$in];
        return $duplicate_map[$in];
    //elseif(empty($in))
        //return  'UC_IMPORTER_DO_NOTHING';
}



/**
 * Multistep form for collecting the import options before processing the
 * selected CSV file.
 *
 * Requirements for csv file
 * First row must contain headings and must NOT end with a comma
 *
 * Step 1: Put in your file name (file must be in the same path as the script - or put it in relative to the script)
 * Step 2: Loads file, displays row 1 headings. User must map headings across to Ubercart/CCK product fields
 * Step 3: Confirm that the field mappings are correct
 * Step 4: Generates XML and passes it to 'uc_importer'
 */
function uc_import_csv_m_multiform($values = NULL)
{
    //global $output_i_results;

    $form = array();

    $form['#multistep'] = TRUE;
    $form['#redirect'] = FALSE;

    // Find out which step we are on. If $values is NULL,
    // that means we are on step 1.
    $step = !is_null($values) ? (int) $values['step'] : 1;

    // переменная для возврата на первое окно импорта
    global $new_import;
    if($new_import != 0) $step = $new_import;

    $form['step'] = array(
        '#type' => 'hidden',
        '#value' => $step + 1
    );

    switch($step)
    {
        case 1:     // STEP 1

            // Customize the fieldset title to indicate the current step to the user.
            $form['step1'] = array(
                '#type' => 'fieldset',
                '#collapsible' => TRUE,
                '#collapsed' => FALSE,
                '#title' => t('Step 1: Select CSV file /Ver. '.Version)
            );

            $form['step1']['csvfile'] = array(
                '#type'         => 'file',
                '#title'        => t('CSV file'),
                '#description'  => t('Select the file to import from your computer.'),
                '#size'         => 40,
            );

            $form['step1']['delimiter'] = array(
                '#type' => 'select',
                '#title' => 'field delimiter',
                '#default_value' => '',
                '#options' => array(
                    'semi colin'    => t(';  - semi colin'),
                    'comma'         => t(',  - comma'),
                    'tab'           => t('\t - tab')
                ),
                '#description' => t('What character is used as a delimiter between columns in the CSV file. By defualt a comma is used. This is usually chosen when you export the CSV from your spreadsheet application.'),
            );




            // эту форму пока не используем
            $form['step1']['show_xml'] = array(
                '#type' => 'radios',
                '#title' => t('Import immediatly or show XML ready for import'),
                '#options' => array(
                    0 => t('Import Immediatly'),
                    1 => t('Show import XML only'),
                ),
                '#default_value' => 1,
                '#type' => 'hidden',
                '#description' => 'If you want to just save the converted CSV as an XML to import later (or elsewhere) then chose the second option, otherwise leave this to import the CSV data now.'

            );





            $form['step1options'] = array(
                '#type' => 'fieldset',
                '#collapsible' => TRUE,
                '#collapsed' => FALSE,
                '#title' => t('Data options')
            );
            // Get Product classes that exist in the DB
            $result = db_query("SELECT pcid, name FROM {uc_product_classes}");
            $classes = array('product' => 'Standard product');
            while($c = db_fetch_object($result))
                $classes[$c->pcid] = $c->name;

            $form['step1options']['class'] = array(
                '#type'             => 'select',
                '#title'            => 'Product classes',
                '#default_value'    => 'product',
                '#options'          => $classes,
                '#description'      => t('If the products to be imported are all of the same <a href="/admin/store/products/classes" title="Manage product classes">class</a> (type) then select it here and it will be applied to all these products.'),
            );

            $form['step1options']['images_path'] = array(
                '#type'             => 'textfield',
                '#title'            => 'Images path',
                '#default_value'    => 'ubercart_images',
                '#description'      => t('Path to the images on the server. Its assumed you have already uploaded the images. You can define the file name for each product in a column in your CSV file.'),
            );






            // блок с обработкой совпадений

            $form['step1duplicates'] = array(
                '#type' => 'fieldset',
                '#collapsible' => TRUE,
                '#collapsed' => FALSE,
                '#title' => t('Duplicates handling')
            );


            //$form['step1options']['handle_duplicates'] = array(
            $form['step1duplicates']['handle_duplicates'] = array(
                '#type' => 'radios',
                '#title' => t('How should items with similar Artikul_postavki, Shop and Otdel be handled during import?'),
                '#options' => array(
                    UC_IMPORTER_DO_NOTHING => t("Skip duplicated product(s)."),
                    //UC_IMPORTER_TEST => t("Test file in write/update mode without writing/updating."),
                    UC_IMPORTER_FROM_FILE => t("Take instruction on duplicate handling from file (field ZAMENA). And do nothing if nothing's there"),
                    UC_IMPORTER_REPLACE => t("Update the existing product (with option FROM_FILE it would be row['Zamena'] = '1' in file)."),
                    UC_IMPORTER_INCREMENT => t("Create new product and append '_#' to the name of object already in DB (with option FROM_FILE it would be row['Zamena'] = '2' in file)."),
                    UC_IMPORTER_NEW_REVISION => t("Make new revision of existing product (with option FROM_FILE it would be row['Zamena'] = '3' in file).")
                ),
                '#default_value' => UC_IMPORTER_DO_NOTHING, //variable_get('uc_importer_handle_duplicates', UC_IMPORTER_DO_NOTHING),
                '#description' => 'This tells the importer how to handle conflict with products already in the stores database.'
            );


            $form['step1duplicates']['handle_duplicates_with_diff_names'] = array(
                '#type' => 'radios',
                '#title' => t('If duplicates arent skipped, how to handle duplicates (sovpadenie po Gorod-Magazin-Otdel-Artikul_postavki) with different names?'),
                '#options' => array(
                    'Skip' => t("Skip that product(s). Maybe there is an error with Artikul_postavki in file"),
                    'Name_from_DB' => t("Leave name from DB. Maybe it's an error with name in file"),
                    'Name_from_file' => t("Take new name from file. Perhaps, the name was changed by supplier")
                ),
                '#default_value' => 'Skip',
                '#description' => 'This tells the importer how to handle conflict when products already in the stores database, but with defined Artikul_postavki its names is different.'
            );





            // Блок с чекбоксами для указания пользователем, для каких разделов или свойств создавать новые записи в базе, если в файле они есть, а в базе ещё нет

            $form['step1create_new_option'] = array(
                '#type' => 'fieldset',
                '#collapsible' => TRUE,
                '#collapsed' => FALSE,
                '#description'      => t('Be careful, please! All options in checked fields that are not in database will be added to there!'),
                '#title' => t('Create new option if not exist for...')
            );


            // пока почему-то не работающая форма с несколькими чекбоксами
            // поэтому пока буду использовать по одному чекбоксу для каждого пункта (следующие после этой формы)

            $form['step1create_new_option']['create_new_option'] = array(
                '#type'             => 'checkboxes',
                // '#title'            => 'Product classes',
                '#prefix' => '<div class="container-inline">',
                '#suffix' => '</div>',
                '#default_value' => array('Gorod' => 1, 'Magazin' => 1, 'Svoistvo_Svoistvo' => 1),
                '#multiple' => TRUE,
    		//'#attributes' => array('class' => 'form-checkboxes-horizontal'),
                //'#default_value' => 1,

                //'#options'          => array('Gorod' => t('Gorod'), 'Magazin' => t('Magazin'), 'Otdel' => 'Otdel', 'Svoistvo_Razdel' => 'Svoistvo_Razdel', 'Svoistvo_Svoistvo' => 'Svoistvo_Svoistvo', 'Attribute' => 'Attribute', 'Attribute_Options' => 'Attribute_Options'),
                //'#description'      => t('Be careful, please!'),
            );





            // собственно чекбоксы для указания пользователем, для каких разделов или свойств создавать новые записи в базе, если в файле они есть, а в базе ещё нет
            $form['step1create_new_option']['Create_New_Gorod'] = array(
                '#type'             => 'checkbox',
                '#title'            => 'Gorod',
                '#value' => 0
            );
            $form['step1create_new_option']['Create_New_Magazin'] = array(
                '#type'             => 'checkbox',
                '#title'            => 'Magazin',
                '#value' => 0
            );
            $form['step1create_new_option']['Create_New_Otdel'] = array(
                '#type'             => 'checkbox',
                '#title'            => 'Otdel',
                '#value' => 0
            );
            $form['step1create_new_option']['Create_New_Svoistvo_Razdel'] = array(
                '#type'             => 'checkbox',
                '#title'            => 'Svoistvo_Razdel',
                '#value' => 0
            );
            $form['step1create_new_option']['Create_New_Svoistvo_Svoistvo'] = array(
                '#type'             => 'checkbox',
                '#title'            => 'Svoistvo_Svoistvo',
                '#value' => 0
            );
            $form['step1create_new_option']['Create_New_Attribute'] = array(
                '#type'             => 'checkbox',
                '#title'            => 'Attribute',
                '#value' => 0
            );
            $form['step1create_new_option']['Create_New_Attribute_Options'] = array(
                '#type'             => 'checkbox',
                '#title'            => 'Attribute_Options',
                '#value' => 0
            );








            // блок для выбором пользователем, как поступать с полем с картинками в файле... например, пропускать поле или брать инструкции из этого поля
            $form['step1pictures_handling'] = array(
                '#type' => 'fieldset',
                '#collapsible' => TRUE,
                '#collapsed' => FALSE,
                '#title' => t('How to handle pictures filed for all products in a file?')
            );

            $form['step1pictures_handling']['pictures_handling'] = array(
                '#type' => 'radios',
                //'#title' => t('How to handle pictures filed?'),
                '#options' => array(
                    'Fromfile' => t("Take instructions form field"),
                    'UseAllPicsOrAddOne' => t("Use All own pics and Pics of products with the same name and/or bar-code. OR add one new pic."),
                    'AddOneNewIfNoSelfPicsBefore' => t("Add one new pic if the product hasn't had any pics before."),
                    'Skip' => t("Skip field with pictures")
                ),
                '#default_value' => 'Fromfile',
                '#description' => 'This tells the importer how to handle conflict with products already in the stores database.'
            );

            $form['step1save_report_csv'] = array(
                '#type' => 'fieldset',
                '#collapsible' => TRUE,
                '#collapsed' => FALSE,
                '#title' => t('Save report in a file?')
            );

            $form['step1save_report_csv']['save_report_csv'] = array(
                '#type' => 'radios',
                '#options' => array(
                    'Dontsave' => t("Don't save the report"),
                    'Save' => t("Save the report in CSV file")
                ),
                '#default_value' => 'Dontsave',
                '#description' => 'This tells the importer how to handle conflict with products already in the stores database.'
            );


            $form['#attributes']['enctype'] = 'multipart/form-data';



	    // кнопка  Submit
	    $form['submit'] = array(
	        '#type' => 'submit',
	        '#value' => t('Submit')
	        );

            $new_import = 0;


            break;











        case 2:     // STEP 2


// Save data from perivious step to pass on to next step (hidden)...
// сохранение полей выбора пользователя
// если здесь не прописать все поля, то на последующих шагах не сохранятся значения, выбранные пользователем
// соответственно, не будет к ним доступа (они все будут неопределены) и их нельзя будет использовать

            $csv_file = variable_get('uc_import_csv_m_filename', false);

            $form['csvfile'] = array(
                '#type' => 'hidden',
                '#value' => $csv_file
            );
            $form['class'] = array(
                '#type' => 'hidden',
                '#value' => $values['class']
            );
            $form['images_path'] = array(
                '#type' => 'hidden',
                '#value' => $values['images_path']
            );
            $form['images_name_pattern'] = array(
                '#type' => 'hidden',
                '#value' => $values['images_name_pattern']
            );
            $form['delimiter'] = array(
                '#type' => 'hidden',
                '#value' => $values['delimiter']
            );
            $form['show_xml'] = array(
                '#type' => 'hidden',
                '#value' => $values['show_xml']
            );




// сохранение моих полей

            $form['handle_duplicates'] = array(
                '#type' => 'hidden',
                '#value' => $values['handle_duplicates']
            );

            $form['handle_duplicates_with_diff_names'] = array(
                '#type' => 'hidden',
                '#value' => $values['handle_duplicates_with_diff_names']
            );

            $form['pictures_handling'] = array(
                '#type' => 'hidden',
                '#value' => $values['pictures_handling']
            );

            $form['save_report_csv'] = array(
                '#type' => 'hidden',
                '#value' => $values['save_report_csv']
            );


// поле с чекбоксами для указания, какие новые разделы или свойства создавать в базе, если в файле они есть, а в базе ещё нет
            $form['Create_New_Gorod'] = array(
                '#type' => 'hidden',
                '#value' => $values['Create_New_Gorod']
            );
            $form['Create_New_Magazin'] = array(
                '#type' => 'hidden',
                '#value' => $values['Create_New_Magazin']
            );
            $form['Create_New_Otdel'] = array(
                '#type' => 'hidden',
                '#value' => $values['Create_New_Otdel']
            );
            $form['Create_New_Svoistvo_Razdel'] = array(
                '#type' => 'hidden',
                '#value' => $values['Create_New_Svoistvo_Razdel']
            );
            $form['Create_New_Svoistvo_Svoistvo'] = array(
                '#type' => 'hidden',
                '#value' => $values['Create_New_Svoistvo_Svoistvo']
            );
            $form['Create_New_Attribute'] = array(
                '#type' => 'hidden',
                '#value' => $values['Create_New_Attribute']
            );
            $form['Create_New_Attribute_Options'] = array(
                '#type' => 'hidden',
                '#value' => $values['Create_New_Attribute_Options']
            );















            // STEP 2 (this step)...

// теперь собственно второй шаг начался

            $form['step2'] = array(
                '#type' => 'fieldset',
                '#title' => t('Step 2: Map CSV columns to Ubercart product data.'),
                '#description' => t('For each column in the CSV listed bellow select what it maps to on a Product. Items with a * after their name mus be mapped to something.')
            );

            $form['step2']['images_name_pattern'] = array(
                '#type'             => 'textfield',
                '#title'            => 'Images filename pattern',
                '#default_value'    => '%Artikul_postavki-%name.jpg',
                '#description'      => t('If you have followed a naming convention when naming your image files you can define it here and the impoter will try and figure it out. Vaild values here are: '. implode(', ', array_keys(uc_import_csv_m_image_filename_tokens($values)))),
            );

            // List of basic Product values to map column values to.
            $uc_product_fields = array(
                '' => t('<ignore>'),
                t('Product fields') => uc_import_csv_m_get_product_properties_list()
            );

            /**
             * Invoke Hook 'uc_import_csv_m_fields_list'
             */
            $hook_results = module_invoke_all('uc_import_csv_m_fields_list', $values);




















// пробую добавлять свои поля с заголовком перед ними в список

    $mesto_tovar_list = array(                             //это поля
//      'Strana'	=> 'Strana',
//      'Gorod'		=> 'Gorod',
//	'Magazin'	=> 'Magazin',
//      'Zamena'	=> 'Zamena',
//	'Otdel'		=> 'Otdel'
    );

    $mesto_tovar = array('Mesto' => $mesto_tovar_list); // это заголовок


// эти поля я внёс в общий список, так что этот массив - уже пустышка









            if(is_array($hook_results) and count($hook_results))
                $uc_product_fields = array_merge($uc_product_fields, $hook_results, $mesto_tovar);

            // Get column headings from the CSV file
            $column_headings = uc_import_csv_m_load_headings($csv_file, $values['delimiter']);

            foreach($column_headings as $key => $column)
            {
                // Auto-select if column names are the same
                $default = '';
                foreach($uc_product_fields as $options)
                    if(is_array($options) and $default = array_search($column, $options))
                        break;

                $form['step2']['column_'.$key] = array(
                    '#type'             => 'select',
                    '#title'            => $column,
                    '#default_value'    => $default,
                    '#options'          => $uc_product_fields,
                );
            }




// кнопка  Submit
    $form['submit'] = array(
        '#type' => 'submit',
        '#value' => t('Submit')
        );


            break;







        case 3:     // STEP 3
              $form['save_report_csv'] = array(
                '#type' => 'hidden',
                '#value' => $values['save_report_csv']
            );

            $form['step3'] = array(
                '#type' => 'fieldset',
                '#title' => t('Step 3: Map CSV columns to Ubercart product data.'),
                '#description' => t('For each column in the CSV listed bellow select what it maps to on a Product. Items with a * after their name mus be mapped to something.')
            );


            // кнопка  Submit
            $form['submit'] = array(
            '#type' => 'submit',
            '#value' => t('Save results or New Import')
            );

            $tmp = variable_get('save_report_csv', $form_values['save_report_csv']);
            //drupal_set_message("save_report_csv = $tmp", 'error');
            if($tmp == 'Save')
               $new_import = 4; //значит слеждующий шаг - на первое (начальное) окно импорта
            else $new_import = 1;

            break;



        case 4:     // STEP 4

            $form['step4'] = array(
                '#type' => 'fieldset',
                '#title' => t('Step 4: Map CSV columns to Ubercart product data.'),
                '#description' => t('For each column in the CSV listed bellow select what it maps to on a Product. Items with a * after their name mus be mapped to something.')
            );


			//$output_i_results = '"Title";"Snippet";"Link";"Type","Author","Date","Comments","Attachments","Score"'."\n".'2"Title","Snippet","Link","Type","Author","Date","Comments","Attachments","Score"';

            $output_i_results = variable_get('output_i_results_var', $output_i_results);
			drupal_set_message("r_t_f = $output_i_results", 'error');
			$output_i_results = utf8_win($output_i_results);
			drupal_set_message("r_t_f = $output_i_results", 'error');
			// если пользователь на первом экране указал производить запись результатов импорта в файл
            // и если есть, что записывать в файл (были добавления новых продуктов или их изменения), делаем это
			//if(0)
			if ($output_i_results != '') // AND $form_values['save_report_csv'] == 'Save')
  			  {
   		 	    if($file = file_save_data($output_i_results, file_directory_temp() ."/product_import_results_" . date("MjS_H-i") . ".csv", FILE_EXISTS_REPLACE))
			      {
       				//drupal_set_message(print_r($file, true));
       				file_transfer($file, array(
         			'Content-Type: text/x-comma-seperated-values', //application/xml',
         			'Content-Disposition: attachment; filename="'. $file .'"',));
     	          }
  			  }

            $new_import = 1; //значит слеждующий шаг - на первое (начальное) окно импорта




            break;


        case 5:     // STEP 5


            $form['step5'] = array(
                '#type' => 'fieldset',
                '#title' => t('Step 5: Map CSV columns to Ubercart product data.'),
                '#description' => t('For each column in the CSV listed bellow select what it maps to on a Product. Items with a * after their name mus be mapped to something.')
            );


            break;



    }
/*
    $form['submit'] = array(
        '#type' => 'submit',
        '#value' => t('Submit')

    );
*/


    return $form;
}


















/**
 * I would make this a Global but PHP doesn't support global arrays
 *
 * @return array
 *   A list of standard UC Product attributes.
 */
function uc_import_csv_m_get_product_properties_list()
{
    //$r_t_f = "No:;Product_name;Artikul_postavki;Proizvoditel;Artikul_proizv;Bar;Gorod->Magazin->Otdel(s);Artikul_zp;Action;Notice;Price;Kol-vo;Kartinki;" . "\n";

    return array(
        'Num'           => 'Num',
        'Name'          => 'Name',
        'Description'   => 'Opisanie',
        'Artikul_postavki'         => 'Artikul_postavki',             // NB: this will be treated differently depending on weather the uc_attributes module is enabled.
        'Proizvoditel'   => 'Proizvoditel',
        'Artikul_proizv' => 'Artikul_proizv',
        'Bar'            => 'Bar',
        'List_price'    => 'List price',
        'Cost'          => 'Cost price',
        'Sell_price'    => 'Price',
        'Weight'        => 'Ves',         	// NB: get the current systems default units
        'Type'          => 'Type',
        'Image'         => 'Image name',
        'Strana'	=> 'Strana',
        'Gorod'		=> 'Gorod',
	    'Magazin'	=> 'Magazin',
        'Zamena'	=> 'Zamena',
	    'Otdel'		=> 'Otdel',
	    'Svoistva'	=> 'Svoistva',
	    'Atributy'	=> 'Atributy',
	    'Kol-vo'	=> 'Kol-vo',
	    'Kartinki'	=> 'Kartinki'

    );
}
































/**
 * Map used to generate Image file names from a template inputed by the user
 *
 * Result is staticly cached.
 */
function uc_import_csv_m_image_filename_tokens($values)
{
    static $cache;

    if(is_array($cache))
        return $cache;

    $product_values = array('%Artikul_postavki' => 'model', '%type' => 'type', '%name' => 'name');

    $result = module_invoke_all('uc_import_csv_m_filename_tokens', $values);

    if(is_array($result))
        foreach($result as $replace => $selector)
            $product_values['%'.$replace] = $selector;

    return $cache = $product_values;
}













/**
 * Validate handler for form ID 'uc_import_csv_m_multiform'.
 */
function uc_import_csv_m_multiform_validate($form_id, $form_values, $form)
{

    if(isset($form_values['step']))
    {
        $step = $form_values['step'] - 1;

        switch($step)
        {
            case 1:

                if($File = file_check_upload('csvfile'))
                {
                    variable_set('uc_import_csv_m_filename', $File->filepath);
                    //form_set_value($form['csvfile'], $File->filepath);    // not working??

                    drupal_set_message('Got file: '.$File->filename.' (on server: '.$File->filepath.')');
                }
                else
                {
                    form_set_error('csvfile', 'Problem uploading CSV file. Could not proceed to next step.');
                }

                variable_set('uc_importer_handle_duplicates', $form_values['handle_duplicates']);
                variable_set('save_report_csv', $form_values['save_report_csv']);

                //$tmp = variable_get('save_report_csv', $form_values['save_report_csv']);
                //drupal_set_message("save_report_csv = $tmp", 'error');


                break;




            case 2:

                // Which are required to be selected? Hook?
                $require_list = array('name', 'sell_price', 'model');

                foreach($require_list as $required)
                {
                    $current = false;

                    for($i = 0; isset($form_values['column_'.$i]); $i++)
                        if($form_values['column_'.$i])
                            $current = true;

                    if(!$current)
                        form_set_error($required, t('"%name" is required! Please choose it to map to one of the columns in the CSV file.', array('%name' => $required)));
                }

                break;

            case 3:

            //$form_values['step'] = 0;
            //$values['step'] = 0;
            break;
        }
    }
    else
        form_set_error('step', 'Can not determine process step number?');
}









/*


function win_utf8 ($in_text){
$output="";
$other[1025]="р";
$other[1105]="с";
$other[1028]="т";
$other[1108]="у";
$other[1030]="I";
$other[1110]="i";
$other[1031]="ф";
$other[1111]="х";

for ($i=0; $i<strlen($in_text); $i++){
if (ord($in_text{$i})>191){
  $output.="&#".(ord($in_text{$i})+848).";";
} else {
  if (array_search($in_text{$i}, $other)===false){
   $output.=$in_text{$i};
  } else {
   $output.="&#".array_search($in_text{$i}, $other).";";
  }
}
}
return $output;
}

*/



/*

//## перекодировка unicode UTF-8 -> win1251
function utf8_win ($s){
$out="";
$c1="";
$byte2=false;
for ($c=0;$c<strlen($s);$c++){
$i=ord($s[$c]);
if ($i<=127) $out.=$s[$c];
if ($byte2){
$new_c2=($c1&3)*64+($i&63);
$new_c1=($c1>>2)&5;
$new_i=$new_c1*256+$new_c2;
if ($new_i==1025){
$out_i=168;
}else{
if ($new_i==1105){
$out_i=184;
}else {
$out_i=$new_i-848;
}
}
$out.=chr($out_i);
$byte2=false;
}
if (($i>>5)==6) {
$c1=$i;
$byte2=true;
}
}
return $out;
}

*/




/*

function cp1251_to_utf8_recursive($data) //mixed type
{
    if (is_array($data))
    {
        $d = array();
        foreach ($data as $k => &$v)
        {
            $d[cp1251_to_utf8_recursive($k)] = cp1251_to_utf8_recursive($v);
        }
        return $d;
    }
    if (is_string($data)) return iconv('cp1251', 'utf-8//IGNORE//TRANSLIT', $data);
    if (is_scalar($data) or is_null($data)) return $data;
    #throw warning, if the $data is resource or object:
    trigger_error('An array, scalar or null type expected, ' . gettype($data) . ' given!', E_USER_WARNING);
    return $data;
}


*/





















 //########################################################################
 // основная функция обработки файла с продуктами



/**
 * Submit handler for form ID 'uc_import_csv_m_multiform'.
 *
 * Generates the XML and passes it to the uc_importer module for processing.
 */
function uc_import_csv_m_multiform_submit($form_id, $form_values)
{
    //global $output_i_results;
    // Have all the data, time to process it...
    if(intval($form_values['step']) == 3)
    {



      drupal_set_message('Step 3: File handling starts...', 'error'); // просто контрольная точка





      if(!file_exists($form_values['csvfile']))
        {
         // файл не существует или не открывается
         drupal_set_message('Problem finding file to open', 'error');
         return;

        }

      if (!$handle = @fopen($form_values['csvfile'], 'r')) return $handle;  // Open file.

      $csvfile_name = $form_values['csvfile'];


      //эту функцию для возможности использования транслитерации pathauto вызовем один раз в начале функции
      _pathauto_include();

      // инициализируем данные для возможности транслитерации, с использованием pathauto
      static $i18n_loaded = false;
      static $translations = array();
      if (!$i18n_loaded)
        {
 	     $path = drupal_get_path('module', 'pathauto');
	     if (is_file($path. '/i18n-ascii.txt'))
	       {
	         $translations = parse_ini_file($path. '/i18n-ascii.txt');
            }
           $i18n_loaded = true;
        }

      $pattern = '/[^a-zA-Z0-9]/'; // символы, которые останутся в строке (имени файла, например) после фильтрации
      $separator = ''; // этим будут заменены остальные символы в строке... Пустота "" означает, что лишние символы просто будут удалены



// Единожды для всех строк (продуктов) в выбранном файле выполняем различные действия, в том числе, уcтанавливаем различные переменные



      // определяем единожды  каталог для картинок (этот каталог может быть изменён пользователем в интерфейсе друпала)
      $file_directory_path = explode('"', db_result(db_query("SELECT value FROM {variable} WHERE name = 'file_directory_path'")));
      $file_directory_path = $file_directory_path[1];

      global $user; // для доступа к данных о текущем юзере

      $row_count = -1; //компенсируем пропуск строки с названием полей

      //$product_count = 0; // кол-во созданных продуктов
      $product_created_count = 0; //кол-во созданных продуктов
      $product_updated_count = 0; // кол-во изменённых продуктов


      $product_properties = array_keys(uc_import_csv_m_get_product_properties_list());

      $delimiter = uc_import_csv_m_get_delimiter($form_values['delimiter']);



      //$catalog_vid = CATALOG_VID; // переменная определена в начале файла
                                    // номер словаря основного каталога Уберкарта
                        	    // можно взять из таблицы variables, поля uc_catalog_vid... сейчас там "i:1;"
                           	    // что и делаем
      $catalog_vid = db_result(db_query("SELECT vid FROM {vocabulary} WHERE name = 'Catalog'"));
      // единожды определяем номер словаря Свойства (для дальнейшей работы с ним)
      $svoistva_vid = db_result(db_query("SELECT vid FROM {vocabulary} WHERE name = '%s'", cp1251_to_utf8_recursive('Свойства')));


      // если в свойствах в таблице node_field для поля field_svoistva установлена опция "сохранять свойства как категории"
      // при необходимости, будем добавлять такие же категории в таблицу term_node, чтобы они стали и ссылками (именно по ним потом можно будет группировать однотипные продукты)
      // $content_field_add_category определяется один раз вначале функции, где и остальные переменные
      $content_field_add_category_tmp = db_result(db_query("SELECT global_settings FROM {node_field} WHERE field_name = 'field_svoistva'"));
      $content_field_add_category_tmp = explode(";", $content_field_add_category_tmp);
      $content_field_add_category = $content_field_add_category_tmp[7][2]; // именно этот символ в опциях отвечает за необходимость сохранения свойств как категорий (тегов)



      //устанавливаем первоначальный выбор юзера по обработке дубликатов
      //if(isset($form_values['handle_duplicates']))
      variable_set('uc_importer_handle_duplicates', $form_values['handle_duplicates']);



      //тестовый вывод значения обработки дубликатов из выбора юзера и из файла
      //$user_set_duplicate_handle = variable_get('uc_importer_handle_duplicates', UC_IMPORTER_DO_NOTHING);
      //$from_file_set_duplicate_handle = $row['Zamena'];
      //drupal_set_message("user_set_duplicate_handle = $user_set_duplicate_handle and from_file_set_duplicate_handle = $from_file_set_duplicate_handle", 'error');


      // в зависимости от того, что на первом экране пользователь указал для обработки поля с картинками
      // сообщаем вначале обработки всего файла, что именно выбрал пользователь для всех продуктов в файле
	  switch($form_values['pictures_handling'])
        {
          case 'Skip': // если в общих настройках на первом экране сказано пропускать картинки, то пропускаем это поле

              drupal_set_message("Vnimanie! Zadan GLOBALNYI propusk obrabotki polia s kartinkami. Pole s kartinkami propuskaetsjia!", 'error');
              break;

          case 'UseAllPicsOrAddOne': // если продукт имеет картинки и/или найдены картинки (и добавлены в этот продукт) в других продуктах с таким же названием или штрих-кодом
                                     // то не создавать новых картинок
                                     // иначе создать одну новую картинку
                                     // считаем, как будто во всех продуктах это поле содержит *
              drupal_set_message("Vnimanie! Zadan GLOBALNAYA opciya: ignore for field with Kartinki, but use vse sobstvenie pics and pics u productov s takim zhe name or bar-code OR add one new pic!", 'error');
              break;

          case 'AddOneNewIfNoSelfPicsBefore': // если продукт имеет картинки, то новые картинки не добавляются, а поле пропускается
                                              // если продукт не содержал уже своих картинок, то добавляяется одна картинка
                                              // поиск картинок по другим продуктам НЕ производится
                                              // считаем, как будто во всех продуктах это поле содержит !?
              drupal_set_message("Vnimanie! Zadan GLOBALNAYA opciya: Add one new pic if the product hasn't had any pics before.", 'error');
              break;

          case 'Fromfile':
          default:
              // во всех остальных случаях берутся инструкции из файла
              break;
		}


      // если не создана в базе таблица, сожержащая количество продуктов в отделах (она нужна для формирования внутренних артикулов artikul_zp)
      // создаём её
      db_query("CREATE TABLE IF NOT EXISTS {uc_otdel_products_count} (`otd_id` mediumint(9) NOT NULL auto_increment, `count` mediumint(9) NOT NULL default '0', `otdel_name` varchar(255) NOT NULL default '', `otdel_tid` mediumint(9) NOT NULL default '0', `magazin_name` varchar(255) NOT NULL default '', `magazin_tid` mediumint(9) NOT NULL default '0', `gorod_name` varchar(255) NOT NULL default '', `gorod_tid` mediumint(9) NOT NULL default '0', PRIMARY KEY (`otd_id`, `otdel_tid`));");

      // если не создана в базе таблица, сожержащая все термы каталога для ноды (всю иерархию, а не только самые глубокие/конечные термы)
      // создаём её
      db_query("CREATE TABLE IF NOT EXISTS {term_node_lineage} (`nid` mediumint(9) NOT NULL, `tid` mediumint(9) NOT NULL default '0', PRIMARY KEY (`nid`, `tid`));");





      $r_t_f = "No:;Product_name;Artikul_postavki;Proizvoditel;Artikul_proizv;Bar;Gorod->Magazin->Otdel(s);Artikul_zp;Action;Notice;Price;Kol-vo;Kartinki;" . "\n";

// Перебираем последовательно все строки файла, пока файл не закончится


      while( ($csv_row = fgetcsv($handle, 0, $delimiter)) !== FALSE )
        {
         $row_count++;
         $row = array();
         $sovpadenie = 0; //если после всех проверок эта переменная окажется =1, значит совпадение найдено

         $nid = 0;
         $vid = 0;

         if($row_count == 0) continue;   // skip heading row

         // Join the Map array with the data from the current CSV row so
         // we have a neat little array to pass to the hooks...

         for($i = 0; isset($form_values['column_'.$i]); $i++)
            if(!empty($form_values['column_'.$i]))  // ... we have map info for this column
                {
                 //$row[$form_values['column_'.$i]] = $csv_row[$i];
                 $row[$form_values['column_'.$i]] = trim(cp1251_to_utf8_recursive($csv_row[$i])); // trim() нужен для отсекания пробелов с начала и конца строки
                 //$row[$form_values['column_'.$i] . '2'] = trim($csv_row[$i]);
                }

         // если строка с продуктом закомментирована (вначале строки стоит '//'), то продукт пропускается
         if($row['Num'][0] == '/' AND $row['Num'][1] == '/')
           continue;








        drupal_set_message("...", 'error');
        drupal_set_message(">Row $row_count...", 'error');







         // для любого продукта должны быть определены поля 'Gorod', 'Magazin', 'Otdel', 'Magazin', 'Artikul_postavki', 'Name'
         // если какое-то из поля неопределено, сообщаем об этом и пропускаем продукт
         if(!$row['Gorod'] OR !$row['Magazin'] OR !$row['Otdel'] OR !$row['Magazin'] OR !$row['Artikul_postavki'] OR !$row['Name'])
           {
             $r_t_f = $r_t_f . "\n" . $row_count . ".;" . ";;;;;;;" . 'Skipped (Error)... ;' . "For product ne opredeleni vse ili nekotorie polia iz 'Gorod', 'Magazin', 'Otdel', 'Magazin', 'Artikul_postavki', 'Name'";
             //$r_t_f = "No:;Product_name;Artikul_postavki;Proizvoditel;Artikul_proizv;Bar;Gorod->Magazin->Otdel(s);Artikul_zp;Action;Notice;Price;Kol-vo;Kartinki;" . "\n";

             drupal_set_message("For product #$row_count ne opredeleni vse ili nekotorie polia iz 'Gorod', 'Magazin', 'Otdel', 'Magazin', 'Artikul_postavki', 'Name'", 'error');
             continue;
           }

         // позже нужно будет сделать предварительный выбор в первом экране нужного города, магазина и отдела
         // послежством hierarchical select c дальнейшим применением ко всем продуктам


         $tmp_gorod = $row['Gorod'];
         $tmp_magazin = $row['Magazin'];

		 // массив, где будут содержаться отделы и подотделы
         $otdels = array();
         $otdels_index = 0;
         $tid_otdels = array();
         $tmp_otdel = $row['Otdel'];

         $tmp_Artikul_postavki = $row['Artikul_postavki'];
         $name_file = $row['Name'];

         //drupal_set_message("----$tmp_gorod, $tmp_magazin, $tmp_otdel, $tmp_Artikul_postavki, $name_file", 'error');



// Если тип/класс продукта не выбран, то по умолчанию устанавливается тип product

         // Put the global 'class' value into each row if its not specified already in the CSV row.
         if(!isset($row['type']) and isset($form_values['class']))
            $row['type'] = $form_values['class'];
         else
            $row['type'] = 'product';




// выясняем номера категорий местоположения по базе
// $tid_gorod, $tid_magazin, $tid_otdel


         $tid_gorod = 0;
         $tid_magazin = 0;
         $tid_otdel = 0;

//##############################################






         //если есть вообще такой город, выясняем его tid
         // тут vid - это номер словаря с городами и отделами, может иметь и другой номер в другой инсталляции
         if(!(($tid_gorod = db_result(db_query("SELECT tid FROM {term_data} WHERE name = '%s' AND vid = '%s'", $row['Gorod'], $catalog_vid))) > 0))
           {
             // нет такого города в базе, этот продукт пропускается
             $r_t_f = $r_t_f . "\n" . $row_count . ".;" . $row['Name'] . ";" . $tmp_Artikul_postavki . ";;;;;;" . 'Skipped (Error)... ;' . "Net takogo goroda = " . $tmp_gorod . " v baze. Product propuskaetsia;" . ";";
             //$r_t_f = "No:;Product_name;Artikul_postavki;Proizvoditel;Artikul_proizv;Bar;Gorod->Magazin->Otdel(s);Artikul_zp;Action;Notice;Price;Kol-vo;Kartinki;" . "\n";

             drupal_set_message("Net takogo goroda = $tmp_gorod v baze. Product s Artikul = $tmp_Artikul_postavki propuskaetsia", 'error');
             continue; // переход на следующий продукт (след. строку в файле)
           }

// такой город есть, его tid определён, теперь находим tid магазина в этом городе

         //есть ли вообще такой магазин (магазины) в базе?
         if(!(($results = db_query("SELECT tid FROM {term_data} WHERE name = '%s' AND vid = '%s'", $row['Magazin'], $catalog_vid)) > 0))
            {
             // нет ни одного такого магазина в базе, этот продукт пропускается
             $r_t_f = $r_t_f . "\n" . $row_count . ".;" . $row['Name'] . ";" . $tmp_Artikul_postavki . ";;;;;;" . 'Skipped (Error)... ;' . "Net takogo magazina = " . $tmp_magazin . " v baze. Product propuskaetsia;" . ";";
             //$r_t_f = "No:;Product_name;Artikul_postavki;Proizvoditel;Artikul_proizv;Bar;Gorod->Magazin->Otdel(s);Artikul_zp;Action;Notice;Price;Kol-vo;Kartinki;" . "\n";


             drupal_set_message("Net takogo magazina = $tmp_magazin v baze. Product s Artikul = $tmp_Artikul_postavki propuskaetsia", 'error');
             continue; // переход на следующий продукт (след. строку в файле)
            }








// такой магазин есть, а может даже и не один, т.к. могут одинаковые магазины в разных городах быть
// выясняем tid указанного магазина, который находится в указанном городе
// для этого в полученном списке магазинов с заданным названием находим такой,
// у которого родительская категория = указанный город $tid_gorod
// если в нашем городе нет такого магазина, значит пропускаем этот продукт

         //перебираем список магазинов
         while($result = db_fetch_object($results))
            if(($tid_magazin = db_result(db_query("SELECT tid FROM {term_hierarchy} WHERE tid = '%s' AND parent = '%s'", $result->tid, $tid_gorod))) > 0)
              {
       	        //магазин совпал, т.е. есть указанный магазин в указанном городе
                break; // выйти из цикла перебора магазинов
              }

          // если же нет указанного магазина в указанном городе,
          // пропускаем этот продукт
          if(!($tid_magazin > 0))
            {
             // нет такого магазина в указанном городе , этот продукт пропускается
             $r_t_f = $r_t_f . "\n" . $row_count . ".;" . $row['Name'] . ";" . $tmp_Artikul_postavki . ";;;;;;" . 'Skipped (Error)... ;' . "Net takogo magazina = " . $tmp_magazin . " v ukazannom gorode = " . $tmp_gorod . "Product propuskaetsia;" . ";";
             //$r_t_f = "No:;Product_name;Artikul_postavki;Proizvoditel;Artikul_proizv;Bar;Gorod->Magazin->Otdel(s);Artikul_zp;Action;Notice;Price;Kol-vo;Kartinki;" . "\n";


             drupal_set_message("Net takogo magazina = $tmp_magazin v ukazannom gorode $tmp_gorod. Produkt s Artikul = $tmp_Artikul_postavki propuskaetsia", 'error');
             continue; // переход на следующий продукт (след. строку в файле)
            }








// такой магазин есть, его tid определён,
// теперь находим tid всех указанных отделов и подотделов в этом магазине


         // уберём из строки все лишние '~', которые могли быть ошибочно повтороно введены (в конце, в середине, двойные ~~)
         $row['Otdel'] = trim($row['Otdel'], "~");
         $row['Otdel'] = str_replace("~~", "~", $row['Otdel']);

         // разобвьём строку с отделами в массив, в котором будут помещены последовательно подотделы, где нулевой элемент - корневой отдел, а все последующие - дети предыдущего
         $otdels = explode("~", $row['Otdel']);


           //тестовый вывод
           //$tmp1 = $row['Artikul_postavki'];
           //$tmp2 = $otdels[$otdels_index];
           //$tmp3 = $tid_otdels[$otdels_index];
           //drupal_set_message("~~~Test: tmp1 = $tmp1, tmp2 = $tmp2, tmp3 = $tmp3, tid_gorod = $tid_gorod, tid_magazin = $tid_magazin", 'error');

         //foreach($otdels as $otdels_index => $podotdel)
         for($otdels_index = 0; $otdels[$otdels_index] /*AND $otdels[$otdels_index] != ''*/; $otdels_index++)
           {
            //if(!$podotdel) break; //прервать, если нет данных (достигнут конечный подотдел либо отделы вообще не были указаны)

         	// тестовый вывод инфы
         	// уберём лишние пробелы в начале и в конце отделов
         	$podotdel[$otdels_index] = trim($podotdel[$otdels_index]);

            //$tmp =$podotdel[$otdels_index];
            //drupal_set_message("!!! podotdel[otdels_index] = $tmp", 'error');


            $podotdel = $otdels[$otdels_index];

            // тестовый вывод инфы
            //drupal_set_message("!! otdels_index = $otdels_index, podotdel = $podotdel", 'error');

         	//есть ли вообще такой отдел/отделы (а фактически - терм) в базе?
         	if(!(($results = db_query("SELECT tid FROM {term_data} WHERE name = '%s' AND vid = '%s'", $otdels[$otdels_index], $catalog_vid)) > 0))
         	   {
         	    // нет ни одного такого отдела в базе, этот продукт пропускается
         	    drupal_set_message("Net takogo otdela = $podotdel. Produkt s Artikul = $tmp_Artikul_postavki propuskaetsia", 'error');
         	    //continue; // переход на следующий продукт (след. строку в файле)
         	   }
         	 else
         	  {
		     // такой отдел есть, а может даже и не один, т.к. могут быть одинаковые отделы в разных магазинах
		     // выясняем tid указанного отдела, который находится в нашем указанном магазине
		     // для этого в полученном списке отделов с заданным названием находим такой,
		     // у которого родительская категория = указанный магазин $tid_magazin
		     // если в нашем магазине нет такого отдела, значит пропускаем этот продукт

         	     //перебираем список отделов

         	     if($otdels_index == 0) // если это первый, корневой подотдел (как бы именно пока отдел, а не подотдел), значит его родителем в иерархии будет магазин, а не другой подотдел
                  {
		   	       while($result = db_fetch_object($results))
         	    	if(($tid_otdels[$otdels_index] = db_result(db_query("SELECT tid FROM {term_hierarchy} WHERE tid = '%s' AND parent = '%s'", $result->tid, $tid_magazin))) > 0)
         	     	 {
       	  	      	   //отдел совпал, т.е. есть указанный отдел в указанном магазине

                      	   // тестовый вывод инфы
                      	   //drupal_set_message("!!!!!Kornevoy Otdel Sovpal! otdels_index = $otdels_index, podotdel = $podotdel", 'error');

          	      	   break; // выйти из цикла перебора отделов
          	     	 }
                  }
                 else  // если это не первый первый, корневой отдел, а именно подотдел (значит его родителем в иерархии будет предыдущий в исследуемом списке отдел
                  {
         	     	while($result = db_fetch_object($results))
         	      	if(($tid_otdels[$otdels_index] = db_result(db_query("SELECT tid FROM {term_hierarchy} WHERE tid = '%s' AND parent = '%s'", $result->tid, $tid_otdels[$otdels_index-1]))) > 0)
         	     	 {
       	  	      	   //отдел совпал, т.е. есть указанный отдел в указанном магазине

          	           // тестовый вывод инфы
                      	   //drupal_set_message("!!!!!!!!!!!!PodOtdel Sovpal! otdels_index = $otdels_index, podotdel = $podotdel", 'error');

          	           break; // выйти из цикла перебора отделов
          	         }
                  }

                  } // конец выполнения действий, если хоть один такой терм есть в базе

                 // если после всех предыдущих итераций $tid_otdels[$otdels_index] не больше нуля,
                 // значит нет указанного подотдела в указанном отделе или отдела в цказанном магазине
          	 // тогда что делать?
          	 if(!($tid_otdels[$otdels_index] > 0))
          	   {
          	     $parent_otdel = $otdels[$otdels_index-1]; //определение переменной только для вывода на экран
          	     //если отдела или подотдела в базе нет, но пользователь отметил опцию "Создавать новый терм для отделов (созадавать в базе новые отделы и подотделы, если их в базе ещё нет)"
          	     if($form_values['Create_New_Otdel'])
          	       {
          	      	  // значит создаём в базе такой отдел или подотдел

          	      	  // определяем следующий свободный номер tid для термов из таблицы sequences
          	          // и присваиваем его текущему терму (пока что он не определён, так как терма такого в базе ещё нет)
          	          $tid_otdels[$otdels_index] = 1 + db_result(db_query("SELECT id FROM {sequences} WHERE name = 'term_data_tid'"));


          	          if($otdels_index == 0) // если нужно добавить отдел (родитель для отдела - магазин)...
          	            {
          	              // добавляем новый отдел в таблицу с термами в продуктовый каталог
          	              db_query("INSERT INTO {term_data} (tid, vid, name, description) VALUES ('%s', '%s', '%s', '')", $tid_otdels[$otdels_index], $catalog_vid, $otdels[$otdels_index]);
          	              // связываем текущий отдел с его родительским магазином в таблице иерархии термов
          	              db_query("INSERT INTO {term_hierarchy} (tid, parent) VALUES ('%s', '%s')", $tid_otdels[$otdels_index], $tid_magazin);
          	              //обновляем переменную, хранящую текущий максимальный номер в таблице термов
          	              db_query("UPDATE {sequences} SET id = '%s' WHERE name = 'term_data_tid'", $tid_otdels[$otdels_index]);

          	              drupal_set_message("Otdel $podotdel in magazin $tmp_magazin at gorod $tmp_gorod have been created (User has chosen creating a new otdel (podotdel)!)!", 'error');
          	            }
          	          else // иначе нужно добавить подотдел (родитель для подотдела - отдел или родительский подотдел)
          	            {
          	              // добавляем новый отдел в таблицу с термами в продуктовый каталог
          	              db_query("INSERT INTO {term_data} (tid, vid, name, description) VALUES ('%s', '%s', '%s', '')", $tid_otdels[$otdels_index], $catalog_vid, $otdels[$otdels_index]);
          	              // связываем текущий подотдел с его родительским отделом в таблице иерархии термов
          	              db_query("INSERT INTO {term_hierarchy} (tid, parent) VALUES ('%s', '%s')", $tid_otdels[$otdels_index], $tid_otdels[$otdels_index-1]);
          	              //обновляем переменную, хранящую текущий максимальный номер в таблице термов
          	              db_query("UPDATE {sequences} SET id = '%s' WHERE name = 'term_data_tid'", $tid_otdels[$otdels_index]);


          	              drupal_set_message("Podotdel $podotdel for otdel(or podotdel) $parent_otdel in magazin $tmp_magazin at gorod $tmp_gorod have been created (User has chosen creating a new otdel (podotdel)!)", 'error');
          	            }

          	       } // конец проверки опции, нужно ли создавать новый терм в базе if($form_values['Create_New_Otdel'])
          	     else // если отдела (подотдела) в базе нет и пользователь не отметил опцию создавать отделы...
          	       {
          	        // Сообщаем пользователю, что такого отдела (подотдела) нет и продукт поэтому пропускается

          	        if($otdels_index == 0)
          	         {
                       // выведем имеющиеся данные в файл
                       $r_t_f = $r_t_f . "\n" . $row_count . ".;" . $row['Name'] . ";" . $tmp_Artikul_postavki . ";;;;;;" . 'Skipped (Error)... ;' . "Net takoho otdela = ". $podotdel . " v ukazannom magazine = " . $tmp_magazin . " v ukazannom gorode = " . $tmp_gorod . ". Produkt propuskaetsia;";
                       //$r_t_f = "No:;Product_name;Artikul_postavki;Proizvoditel;Artikul_proizv;Bar;Gorod->Magazin->Otdel(s);Artikul_zp;Action;Notice;Price;Kol-vo;Kartinki;" . "\n";

          	          drupal_set_message("Net takoho otdela = $podotdel v ukazannom magazine $tmp_magazin v ukazannom gorode  $tmp_gorod. Produkt s Artikul = $tmp_Artikul_postavki propuskaetsia", 'error');
                     }
          	        else
          	         {
                       // выведем имеющиеся данные в файл
                       $r_t_f = $r_t_f . "\n" . $row_count . ".;" . $row['Name'] . ";" . $tmp_Artikul_postavki . ";;;;;;" . 'Skipped (Error)... ;' . "Net takoho podotdela = ". $podotdel . " otdele (podotdele) = " . $parent_otdel . " v ukazannom magazine = " . $tmp_magazin . " v ukazannom gorode = " . $tmp_gorod . ". Produkt propuskaetsia;";
                       //$r_t_f = "No:;Product_name;Artikul_postavki;Proizvoditel;Artikul_proizv;Bar;Gorod->Magazin->Otdel(s);Artikul_zp;Action;Notice;Price;Kol-vo;Kartinki;" . "\n";

          	           drupal_set_message("Net takoho podotdela = $podotdel v ukazannom otdele (podotdele) $parent_otdel v ukazannom magazine $tmp_magazin v ukazannom gorode  $tmp_gorod. Produkt s Artikul = $tmp_Artikul_postavki propuskaetsia", 'error');
                     }
          	        // временно на время теста закомментировано
          	        continue (2); // переход на следующий продукт (след. строку в файле)

          	       }

          	 } // конец проверки, есть ли такой отдел в базе if(!($tid_otdels[$otdels_index] > 0))
          	   // к этому моменту будет понятно, что такой отдел или подотдел в базе есть
          	   // либо продукт будет пропущен и программа перейдёт на обработку следующего продукта
          	   // либо будет создан в базе отдел, который был в файле, но не было ещё в базе


           } // end of перебор подотделов в списке отделов for($otdels_index = 0; $otdels[$otdels_index]; $otdels_index++)

          // после окончания перебора подотделов имеем список из подотделов в массиве $otdels в виде иерархического последовательного списка
          // а такжке такой же список их tid в массиве $tid_otdels,
          // количество подотделов и их tid, т.е. кол-во элементов в каждом их этих массивов равно $otdels_index


          // return;
















//-----------------------------------------------------------------------

// проверяем, есть ли указанный продукт уже в базе?
// совпадение по параметрам Gorod-Magazin-Otdel-Artikul
// отличие в любом значении говорит о том, что совпадения нет
// так как продукт даже с идентичным Artikul, Gorod и Otdel может
// находиться в другом магазине в этом городе

           // тестовый вывод
           //$tmp1 = $row['Artikul_postavki'];
           //$tmp2 = $otdels[$otdels_index-1];
           //$tmp3 = $tid_otdels[$otdels_index-1];

           //drupal_set_message("~~~Test: tmp1 = $tmp1, tmp2 = $tmp2, tmp3 = $tmp3, tid_gorod = $tid_gorod, tid_magazin = $tid_magazin, otdels_index = $otdels_index", 'error');
           //return;

           // считаем, что у всех ревизий одного продукта Artikul одинаково
           // получаем список нодов всех продуктов с указанным

           //Artikul_postavki
           if(($results = db_query("SELECT nid FROM {content_field_artikul_postavki} WHERE field_artikul_postavki_value = '%s'", $row['Artikul_postavki'])) > 0)
           //if(($results = db_query("SELECT nid FROM {uc_products} WHERE model = '%s'", $row['SKU'])) > 0)
            {
             // в базе есть продукт(ы) с указанным Artikul
             // проверяем, есть ли среди них продукты с полным совпадением
             // по Artikul-Gorod-Magazin-Otdel

             $sql_get_children_otdel_tids = 0;
             // единожды найдём всех детей данного отдела

             //$tmp = $otdels[$otdels_index-1];
             //drupal_set_message("0) otdels[otdels_index-1] = $tmp", 'error');
             $otdel_children_tids = db_query("SELECT tid FROM {term_hierarchy} WHERE parent = '%s'", $tid_otdels[$otdels_index-1]);
             if(($otdel_children_tid = db_fetch_object($otdel_children_tids)) > 0 ) // > 0)
                {
                  //$otdel_children_tid = db_fetch_object($otdel_children_tids);
                  //$tmp = $otdel_children_tid->tid;
                  //drupal_set_message("0) otdel_children_tid->tid = $tmp", 'error');
                  $sql_get_children_otdel_tids = " AND tid = " . $otdel_children_tid->tid;
                  while($otdel_children_tid = db_fetch_object($otdel_children_tids))
                    $sql_get_children_otdel_tids = $sql_get_children_otdel_tids . " OR tid = " . $otdel_children_tid->tid;
                  //drupal_set_message("0) Otdel has podotdels!!!", 'error');
                }

             //drupal_set_message("0) sql_get_children_otdel_tids = $sql_get_children_otdel_tids", 'error');

             //$tmp_count = 0;
             while($result = db_fetch_object($results))
              {
               //$tmp_count++;
               //drupal_set_message("1) Count = $tmp_count, sovpadenie = $sovpadenie", 'error');
               //$tmp1 = $result->nid;
               //drupal_set_message("1) result->nid = $tmp1", 'error');

               // следующие две строчки закомментированы, так как пока что сделано так, что продукт содержит только терм самого глубокого отдела и не содержит термы города и отдела (связь вычисляется друпалом автоматически на основе иерархии термов)
               //if(($nid = db_result(db_query("SELECT nid FROM {term_node} WHERE nid = '%s' AND tid = '%s'", $result->nid, $tid_gorod))) > 0)
                  //if(($nid = db_result(db_query("SELECT nid FROM {term_node} WHERE nid = '%s' AND tid = '%s'", $result->nid, $tid_magazin))) > 0)
                     // внимание! Мы можем считать совпадением только для продуктов одного подотдела с одинаковыми артикулами.
                     // Поэтому даже продукты с одинаковыми артикулами будут считаться разными, если они находятся в разных подотделах даже отдного отдела
                     // Считать находящиеся в разных подотделах продукты одинаковыми нельзя, так как тогда может случиться попытка обновить несуществующий продукт из другого подотдела
                    {

                     /*


                     //$tmp2 = $row['Artikul_postavki'];
                     //drupal_set_message("2) perebor nid with similar Artikul_postavki = $tmp2 -> nid = $tmp1", 'error');

                     // если очередной нод с таким же СКУ содержит терм отдела вводимого продукта
                     if(($nid = db_result(db_query("SELECT nid FROM {term_node} WHERE nid = '%s' AND tid = '%s'", $result->nid, $tid_otdels[$otdels_index-1]))) > 0)  // здесь берём $tid_otdels[$otdels_index-1], где -1 потому, что индекс количества отделов в списке отделов для товара после конечной итерации смещается на 1 и становится больше, чем есть на самом деле элементов. Кстати, для теста мы берём самый глубокий подотдел, нам этого достаточно, учитывая, что если у продукта есть этот подотдел, то значит и все внешние, родительские отделы.
                      {
                      	//drupal_set_message("3) Product soderzhit term otdela issleduemogo producta - Trebuetsia dalneishee issledovanie...", 'error');
                      	//drupal_set_message("3) sql_get_children_otdel_tids = $sql_get_children_otdel_tids", 'error');
                      	//drupal_set_message("3) SELECT nid FROM {term_node} WHERE nid = " . $result->nid . $sql_get_children_otdel_tids, 'error');
                      	if($sql_get_children_otdel_tids)// > 0) // если у отдела есть подотделы, проверим для очередного проверяемого нода с таким же Artikul_postavki  также определён хоть один из подотделов?
                      	  {

                      	   //drupal_set_message("4) sql_get_children_otdel_tids >0   = $sql_get_children_otdel_tids", 'error');
                      	   //$sql_string = "SELECT nid FROM {term_node} WHERE nid = " . $result->nid . $sql_get_children_otdel_tids;
                      	   //drupal_set_message("4) sql_string = $sql_string", 'error');
                      	   $nid_with_podotdels = db_result(db_query("SELECT nid FROM {term_node} WHERE nid = " . $result->nid . $sql_get_children_otdel_tids));
                      	   //drupal_set_message("4) nid = $nid", 'error');
                      	   if($nid_with_podotdels != $result->nid) // если для отдела НЕ определён подотдел из детей текущего отдела, считаем, что этот продукт находится именно в этом отделе (а не в более глубоком подотделе), значит совпадение найдено
                      	    {
                              //drupal_set_message("5) Polnoe sovpadenie - net podotdelov u noda", 'error');
                              //обнаружено полное совпадение
                              $sovpadenie = 1;
                              //drupal_set_message("Polnoe sovpadenie Otdel = $tmp_otdel v magazine $tmp_magazin v gorode  $tmp_gorod. Produkt s Artikul = $tmp_Artikul_postavki !!!", 'error');
			 				  break; // выйти из цикла по перебору нодов, так как совпадение найдено
                      	    }
                      	   else
                      	    {
                      	     //drupal_set_message("6) Sovpadenija net, t.k. est podotdeli u noda", 'error');

                      	    }
                          }
                        else  // если нет подоотделов, считаем, что совпадение найдено именно в этом отделе
                          {
                          	//drupal_set_message("7) Net podotdelov u otdela -> Est' sovpadenie. Nid = $nid", 'error');
                          	//обнаружено полное совпадение
                            $sovpadenie = 1;
                            //drupal_set_message("Polnoe sovpadenie Otdel = $tmp_otdel v magazine $tmp_magazin v gorode  $tmp_gorod. Produkt s Artikul = $tmp_Artikul_postavki !!!", 'error');
			 				break; // выйти из цикла по перебору нодов, так как совпадение найдено
                          }
                      }
                     else // если же очередной нод с таким же СКУ НЕ содержит терм отдела вводимого продукта
                      {   // значит совпадающий продукт находится не в этом же отделе
                          // значит на этом продукте совпадения нет и надо брать следующий проверяемый продукт с таким же СКУ
                      	  //drupal_set_message("8) Product NE soderzhit term otdela issleduemogo producta - Propuskaetsia", 'error');


                      }

                       */



                     if(($nid = db_result(db_query("SELECT nid FROM {term_node} WHERE nid = '%s' AND tid = '%s'", $result->nid, $tid_otdels[$otdels_index-1]))) > 0)  // здесь берём $tid_otdels[$otdels_index-1], где -1 потому, что индекс количества отделов в списке отделов для товара после конечной итерации смещается на 1 и становится больше, чем есть на самом деле элементов. Кстати, для теста мы берём самый глубокий подотдел, нам этого достаточно, учитывая, что если у продукта есть этот подотдел, то значит и все внешние, родительские отделы.
                       {
                         //обнаружено полное совпадение
                         $sovpadenie = 1;
                            //drupal_set_message("Polnoe sovpadenie Otdel = $tmp_otdel v magazine $tmp_magazin v gorode  $tmp_gorod. Produkt s Artikul = $tmp_Artikul_postavki !!!", 'error');
			 				break; // выйти из цикла по перебору нодов, так как совпадение найдено
                       }

                    }

              }


             } // конец проверки наличия нодов с указанным Artikul
















           // если у продукта ещё не было определено внутреннего артикула, определим его
           // это нужно и для нового продукта, и для уже имеющегося в базе продукта (на случай, если ранее внутренний артикул вдруг не быд определён)


                $artikul_zp = 0;
                if($sovpadenie == 1)
                  $artikul_zp = db_result(db_query("SELECT field_artikul_zp_value FROM {content_field_artikul_zp} WHERE nid = '%s'", $nid));
                //drupal_set_message("----artikul_zp = $artikul_zp", 'error');
                //drupal_set_message("----sovpadenie = $sovpadenie", 'error');

                if(!($artikul_zp > 0))
                 {
                    // флаг того, что необходимо внести артикул zp в базу
                    $need_to_write_artikul_zp = 1;

                    // сгенерируем и введём в таблицу content_field_artikul_zp внутренний артикул ZP
                    // который формируется по принципу "код города"."код магазина"."код отдела"."порядковый номер продукта в отделе"

                    // позднее надо будет сформировать отдельную таблицу идентификаторов, в которой будут содержаться специальные номера для всех городов, магазинов и отделов, чтобы по каждому из них счёт начинался для вложений с нуля (единицы)...
                    // например, город 1 (Магазин 1 (Отдел1, Отдел2, отдел3, подотдел4, отдел5, подотдет6 (Продукт1, продукт2, продукт3), подотдел7)), Город 2 (Магазин 1 (Отдел 1, Отдел 2, Отдел 3), Магазин2...) и т.д.
                    // тогда будет проще отслеживать структуру всего портала и легче вычислять по артикулу конкретный товар (пока что используется основная таблица термов, где для любого нового терма берётся следующий свободный во всей таблице номер).

                    // выясним текущее количество продуктов в текущем отделе и для нового продукта назначим это количество + 1

                    //$tmp = $tid_otdels[$otdels_index-1];
                    //drupal_set_message("----tid_otdels[otdels_index-1] = $tmp", 'error');

                    $otdel_products_count = db_result(db_query("SELECT count FROM {uc_otdel_products_count} WHERE otdel_tid = '%s'", $tid_otdels[$otdels_index-1]));
                    //drupal_set_message("1----otdel_products_count = $otdel_products_count", 'error');

                    // db_query("CREATE TABLE IF NOT EXISTS {uc_otdel_products_count} (`otd_id` mediumint(9) NOT NULL auto_increment, `count` mediumint(9) NOT NULL default '0', `otdel_name` varchar(255) NOT NULL default '', `otdel_tid` mediumint(9) NOT NULL default '0', `magazin_name` varchar(255) NOT NULL default '', `magazin_tid` mediumint(9) NOT NULL default '0', `gorod_name` varchar(255) NOT NULL default '', `gorod_tid` mediumint(9) NOT NULL default '0', PRIMARY KEY (`otd_id`, `otdel_tid`));");
                    if( !( $otdel_products_count AND $otdel_products_count > 0) )
                     {
                     	// если такого отдела в таблице ещё нет, вставляем и сразу устанавливаем количество продуктов в 1.
                     	db_query("INSERT INTO {uc_otdel_products_count} (count, otdel_name, otdel_tid, magazin_name, magazin_tid, gorod_name, gorod_tid) VALUES ('%s', '%s', '%s', '%s', '%s', '%s', '%s')", '1', $otdels[$otdels_index-1], $tid_otdels[$otdels_index-1], $row['Magazin'], $tid_magazin, $row['Gorod'], $tid_gorod);
                        $otdel_products_count = 1;
                        //drupal_set_message("2----otdel_products_count = $otdel_products_count", 'error');
                     }
                    else
                     {
                     	// обновим данные о количество продуктов в отделе в соответствующей таблице
                     	$otdel_products_count = $otdel_products_count + 1;
                        db_query("UPDATE {uc_otdel_products_count} SET count = '%s' WHERE otdel_tid = '%s'", $otdel_products_count, $tid_otdels[$otdels_index-1]);
                        //drupal_set_message("3----otdel_products_count = $otdel_products_count", 'error');
                     }

                    // сформируем внутренний артикул
                    // он же будет являться основным артикулом SKU всей базы (для этого его позднее внесём в таблицу продуктов как поле SKU)
                    $artikul_zp = $tid_gorod . '.' . $tid_magazin . '.' . $tid_otdels[$otdels_index-1] . '.' .  $otdel_products_count;
                    //drupal_set_message("----artikul_zp = $artikul_zp -----------otdel_products_count = $otdel_products_count", 'error');
                    // внесём артикул zp в базу
                    // пока не определён vid, поэтому в базу вводить данные не будем

                    //db_query("INSERT INTO {content_field_artikul_zp} (nid, vid, field_artikul_zp_value) VALUES ('%s', '%s', '%s')", $nid, $vid, $artikul_zp);
                 }
                else
                 $need_to_write_artikul_zp = 0;






















// Итак, город, магазин, отдел в базе такие есть.
// Проверка совпадения произведена, т.е. уже известно, есть ли такой продукт в базе


// если совпадение найдено (есть такой продукт в базе)
// уточняем, что делать с дубликатом (проверяем поле Zamenа в файле для текущего продукта)
// иначе соаздадим новый продукт

             if($sovpadenie == 1)
               {
                    // выведем некоторые уже известные данные в файл
                    //$r_t_f = "No:;Product_name;Artikul_postavki;Proizvoditel;Artikul_proizv;Bar;Gorod->Magazin->Otdel(s);Artikul_zp;Action;Notice;Price;Kol-vo;Kartinki;" . "\n";

                    // номер продукта в файле, имя, артикул поставки
                    $r_t_f = $r_t_f . "\n" . $row_count . ".;" . $name_file .";" . $tmp_Artikul_postavki . ";";


                    // выведем в файл производителя, если он указан
	         	 	if($row['Proizvoditel'] AND  $row['Proizvoditel'] != '')
                        $r_t_f = $r_t_f . $row['Proizvoditel'] . ';';
                    else
                        $r_t_f = $r_t_f . ';';

                    // выведем в файл артикул производителя, если он не пустой
	         	 	if($row['Artikul_proizv'] AND  $row['Artikul_proizv'] != '')
                        $r_t_f = $r_t_f . $row['Artikul_proizv'] . ';';
                    else
                        $r_t_f = $r_t_f . ';';

                    // выведем штрих-код в файл, если он не пустой
	         	 	if($row['Bar'] AND  $row['Bar'] != '')
	                    $r_t_f = $r_t_f . $row['Bar'] . ';';
                    else
                        $r_t_f = $r_t_f . ';';


                    // выведем в файл город и магазин
                    $r_t_f = $r_t_f . $row['Gorod'] . '->' . $row['Magazin'];

                    // выведем в файл отдел(ы)
                    $count_otdels = 0;
                    while($otdels[$count_otdels])
                     {
                       $r_t_f = $r_t_f . '->' . $otdels[$count_otdels++];
                     }
                    $r_t_f = $r_t_f . ';';

                    // выведем артикул $artikul_zp в файл
                    $r_t_f = $r_t_f . $artikul_zp . ';';





                // если пользователь на первом экране указал пропускать дубликаты
                if($form_values['handle_duplicates'] == UC_IMPORTER_DO_NOTHING)
                   {
                     $r_t_f = $r_t_f . 'Skipped (Sovpadenie)... ;' . "Polnoe sovpadenie Gorod-Magazin-Otdel-Artikul for product in Catalog -> nid = " . $nid . ". Produkt propuskaetsia (User set GLOBAL instructions to skip duplicates!);" . ";";

                     if($need_to_write_artikul_zp) // если ранее артикул zp не был определён и введен, вводим его, предварительно определив vid
                      {
                       	$vid = db_result(db_query("SELECT vid FROM {node} WHERE nid = '%s' ", $nid));
                        db_query("INSERT INTO {content_field_artikul_zp} (nid, vid, field_artikul_zp_value) VALUES ('%s', '%s', '%s')", $nid, $vid, $artikul_zp);
                        //внесём артикул zp также в таблицу продуктов как основной артикул базы SKU, вернее, уточним это поле, так как продукт в базе есть, а артикул zp для него пока не определён,
                        // это может случиться из-за ручного ввода продукта в базу. В таком случае понятно, что вручную артикул zp определить сложно, и артикул zp (а значит и правильный артикул SKU) в базу введен не был
                        db_query("UPDATE {uc_products} SET model = '%s' WHERE vid = '%s'", $artikul_zp, $vid);
                        // раз не был введён правильный артикул SKU, значит не было введено и правильное количество продукта в базу
                        // вернее, количество было привязано в базе к неправильному артикулу, а это неправильно
                        // значит нам нужно удалить старую строку с неправильным артикулом, и добавить строку с вот этим артикулом zp и текущим куоличеством продукта, взятым из файла

                        // для начала, если в файле не опредено количество продукта, попробуем взять его из базы с пока неправильным
                        // если такая строка в таблице отсутствует (при вооде продукта вручную не было указано количество и/или активность продукта для отслеживаниющей количество системы),
                        // то $row['Kol-vo'] останется неопределённым, но это не страшно

                        // попробуем взять количество продукта из базы (база может и не содержать это количество при ручном вводе продукта в базу)
                        $kol_vo_tmp = db_result(db_query("SELECT stock FROM {uc_product_stock} WHERE nid = '%s'", $nid));

                        if(!$row['Kol-vo']) // если в файле не определено количество продукта
                          {
                            // если количество было определено в базе
                            if($kol_vo_tmp)
                              {
                                // присываиваем переменной $row['Kol-vo'], которое не было определено в файле, значение из базы
                                $row['Kol-vo'] = $kol_vo_tmp;
                              }
                          }

                        if($kol_vo_tmp)
                          db_query("UPDATE {uc_product_stock} SET sku = '%s', active = '%s', stock = '%s', threshold = '%s' WHERE nid = '%s'", $artikul_zp, '1', $row['Kol-vo'], '0', $nid);
                        else
                          db_query("INSERT INTO {uc_product_stock} (sku, nid, active, stock, threshold) VALUES ('%s', '%s', '%s', '%s', '%s')", $artikul_zp, $nid, '1', $artikul_zp, $row['Kol-vo'], '0');
                      }

                     drupal_set_message("Polnoe sovpadenie Gorod-Magazin-Otdel-Artikul for product in Catalog with Artikul = $tmp_Artikul_postavki (Name = $name_file in file), nid = $nid. Izmenenija ne proizvodiatsia (User set GLOBAL instructions to skip duplicates!).", 'error');
 					 continue; // пропускаем продукт, переходим к следующему
                   }

                // если пользователь на первом экране указал брать инструкции по обработке дубликатов из файла (то есть, отдельно для каждого продукта для)
     	        if($form_values['handle_duplicates'] == UC_IMPORTER_FROM_FILE)
     	           {
                     switch ($row['Zamena'])
					  {

                          case 'replace':
                          case '1':
		     			      variable_set('uc_importer_handle_duplicates', UC_IMPORTER_REPLACE);
                              break;

                          case 'increment':
			  			  case '2':
		                     variable_set('uc_importer_handle_duplicates', UC_IMPORTER_INCREMENT);
		              		 break;

                          case 'new_revision':
                          case '3':
		         			variable_set('uc_importer_handle_duplicates', UC_IMPORTER_NEW_REVISION);

			  			  case '':     // если поле пустое
                          case 'skip': // если стоит в поле 'skip'
			  		      case '0':    // или '0'
			  			  default:     // или что угодно другое (например, ошибочно введенная команда)
			                 // значит устанавливаем переменную обработки дубликатов в UC_IMPORTER_DO_NOTHING, то есть пропускать продукт
                             $r_t_f = $r_t_f . 'Skipped (Sovpadenie)... ;' . "Polnoe sovpadenie Gorod-Magazin-Otdel-Artikul for product in Catalog -> nid = " . $nid . ". Produkt propuskaetsia (V faile Zamena = 0, Skip, ne opredeleno ili oshibochnaya komanda!);" . ";";

                             if($need_to_write_artikul_zp) // если ранее артикул zp не был определён и введен, вводим его, предварительно определив vid
                               {
                       			 $vid = db_result(db_query("SELECT vid FROM {node} WHERE nid = '%s' ", $nid));
                       			 db_query("INSERT INTO {content_field_artikul_zp} (nid, vid, field_artikul_zp_value) VALUES ('%s', '%s', '%s')", $nid, $vid, $artikul_zp);
                       			 //внесём артикул zp также в таблицу продуктов как основной артикул базы SKU, вернее, уточним это поле, так как продукт в базе есть, а артикул zp для него пока не определён,
                       			 // это может случиться из-за ручного ввода продукта в базу. В таком случае понятно, что вручную артикул zp определить сложно, и артикул zp (а значит и правильный артикул SKU) в базу введен не был
                       			 db_query("UPDATE {uc_products} SET model = '%s' WHERE vid = '%s'", $artikul_zp, $vid);
                       			 // раз не был введён правильный артикул SKU, значит не было введено и правильное количество продукта в базу
                       			 // вернее, количество было привязано в базе к неправильному артикулу, а это неправильно
                       			 // значит нам нужно удалить старую строку с неправильным артикулом, и добавить строку с вот этим артикулом zp и текущим куоличеством продукта, взятым из файла

                        		 // для начала, если в файле не опредено количество продукта, попробуем взять его из базы с пока неправильным
                       			 // если такая строка в таблице отсутствует (при вооде продукта вручную не было указано количество и/или активность продукта для отслеживаниющей количество системы),
                        		 // то $row['Kol-vo'] останется неопределённым, но это не страшно

                        		 // попробуем взять количество продукта из базы (база может и не содержать это количество при ручном вводе продукта в базу)
                        		 $kol_vo_tmp = db_result(db_query("SELECT stock FROM {uc_product_stock} WHERE nid = '%s'", $nid));

		                         if(!$row['Kol-vo']) // если в файле не определено количество продукта
                        		  {
                         		  	 // если количество было определено в базе
                         		  	 if($kol_vo_tmp)
                           		 	  {
                           		  	    // присываиваем переменной $row['Kol-vo'], которое не было определено в файле, значение из базы
                               		    $row['Kol-vo'] = $kol_vo_tmp;
                            	 	  }
                         		  }

                        		 if($kol_vo_tmp)
                         		   db_query("UPDATE {uc_product_stock} SET sku = '%s', active = '%s', stock = '%s', threshold = '%s' WHERE nid = '%s'", $artikul_zp, '1', $row['Kol-vo'], '0', $nid);
                        		 else
                          		   db_query("INSERT INTO {uc_product_stock} (sku, nid, active, stock, threshold) VALUES ('%s', '%s', '%s', '%s', '%s')", $artikul_zp, $nid, '1', $artikul_zp, $row['Kol-vo'], '0');
                               }


                             drupal_set_message("Polnoe sovpadenie Gorod-Magazin-Otdel-Artikul for product in Catalog with Artikul = $tmp_Artikul_postavki, Name = $name_file in file), nid = $nid. Izmenenija ne proizvodiatsia (V faile Zamena = 0, Skip, ne opredeleno ili oshibochnaya komanda!).", 'error');
    		   		         continue; // пропускаем продукт, переходим к следующему

				      } // end of switch


     	             }  // end of if ($form_values['handle_duplicates'] == UC_IMPORTER_FROM_FILE)









//############################################################################
//############################################################################
//#############################################################################


					//конкретные действия с продуктом, который уже имеется в базе...
					switch(variable_get('uc_importer_handle_duplicates', UC_IMPORTER_DO_NOTHING))
		 			  {
					    case UC_IMPORTER_INCREMENT: // если найдено и установлено действие "новый продукт, добавление к модели #"

						    drupal_set_message("Polnoe sovpadenie Gorod-Magazin-Otdel-Artikul for product in Catalog with Artikul = $tmp_Artikul_postavki, (Name = $name_file in file). Noviy produkt will be with model + # (Set by GLOBAL user unstruction on first screen or in file in field ZAMENA = 2 for this product).", 'error');
						    // пока пропускаем продукт, переходим к следующему
						    continue (2);

						    // номер ноды остаётся текущий $nid, а номер ревизии устанавливаем следующий свободный в базе
						    //$nid = db_result(db_query("SELECT id FROM {sequences} WHERE name = 'node_nid'")) + 1;
						    //$vid = db_result(db_query("SELECT id FROM {sequences} WHERE name = 'node_revisions_vid'")) + 1;

		            		break;

		     			case UC_IMPORTER_NEW_REVISION: // если найдено и установлено действие "новая ревизия"

        		            drupal_set_message("Polnoe sovpadenie Gorod-Magazin-Otdel-Artikul for product in Catalog with Artikul = $tmp_Artikul_postavki (Name = $name_file in file).  There will be Novaja revizija (Set by GLOBAL user unstruction on first screen or in file in field ZAMENA = 3 for this product).  Nid = $nid. New vid = $vid .", 'error');
		       			    // пока пропускаем продукт, переходим к следующему
		       			    continue (2);

			    			// номер ноды остаётся текущий $nid, а номер ревизии устанавливаем следующий свободный в базе
			   			    //$vid = db_result(db_query("SELECT id FROM {sequences} WHERE name = 'node_revisions_vid'")) + 1;
		         		    break;












//##################################################################################


		     			case UC_IMPORTER_REPLACE: // если найдено и установлено действие "замена"
		   	  			    //номер ноды остаётся текущий $nid и номер ревизии берётся текущий этой ноды

	  		    			//определяем название продукта в базе
		          			$name_bd = db_result(db_query("SELECT title FROM {node} WHERE nid = '%s'", $nid));

		            		//переписываем имя продукта только тогда, когда оно реально изменилось
		           		    if($name_bd != $name_file)
					   	      {
                                switch($form_values['handle_duplicates_with_diff_names'])
                                 {
                                   case 'Skip':

                                        // пропустить продукт. Вдруг он вообще не относится к данному артикулу?
		   	               				// предполагаем, что опечатка в артикуле

                                        $r_t_f = $r_t_f . 'Skipped (Sovpadenie)... ;' . "Polnoe sovpadenie Gorod-Magazin-Otdel-Artikul for product in Catalog -> nid = " . $nid . ". Name in DB = " . $name_bd . ". But it has different Name = " . $name_file . " in file. Produkt propuskaetsia (GLOBAL instruction from user on first ekran!);" . ";";

                                        if($need_to_write_artikul_zp) // если ранее артикул zp не был определён и введен, вводим его, предварительно определив vid
                      						 {
                       							 $vid = db_result(db_query("SELECT vid FROM {node} WHERE nid = '%s' ", $nid));
                       							 db_query("INSERT INTO {content_field_artikul_zp} (nid, vid, field_artikul_zp_value) VALUES ('%s', '%s', '%s')", $nid, $vid, $artikul_zp);
                       							 //внесём артикул zp также в таблицу продуктов как основной артикул базы SKU, вернее, уточним это поле, так как продукт в базе есть, а артикул zp для него пока не определён,
                       							 // это может случиться из-за ручного ввода продукта в базу. В таком случае понятно, что вручную артикул zp определить сложно, и артикул zp (а значит и правильный артикул SKU) в базу введен не был
                       							 db_query("UPDATE {uc_products} SET model = '%s' WHERE vid = '%s'", $artikul_zp, $vid);
                       							 // раз не был введён правильный артикул SKU, значит не было введено и правильное количество продукта в базу
                       							 // вернее, количество было привязано в базе к неправильному артикулу, а это неправильно
                       							 // значит нам нужно удалить старую строку с неправильным артикулом, и добавить строку с вот этим артикулом zp и текущим куоличеством продукта, взятым из файла

                        						 // для начала, если в файле не опредено количество продукта, попробуем взять его из базы с пока неправильным
                       							 // если такая строка в таблице отсутствует (при вооде продукта вручную не было указано количество и/или активность продукта для отслеживаниющей количество системы),
                        						 // то $row['Kol-vo'] останется неопределённым, но это не страшно

                        						 // попробуем взять количество продукта из базы (база может и не содержать это количество при ручном вводе продукта в базу)
                        						 $kol_vo_tmp = db_result(db_query("SELECT stock FROM {uc_product_stock} WHERE nid = '%s'", $nid));

		                         				if(!$row['Kol-vo']) // если в файле не определено количество продукта
                        		 				 {
                         		  					 // если количество было определено в базе
                         		  					 if($kol_vo_tmp)
                           		 	 				 {
                           		  	  				  // присываиваем переменной $row['Kol-vo'], которое не было определено в файле, значение из базы
                               		  	 			  $row['Kol-vo'] = $kol_vo_tmp;
                            	 					 }
                         		  				 }

                        		 				if($kol_vo_tmp)
                         		   				  db_query("UPDATE {uc_product_stock} SET sku = '%s', active = '%s', stock = '%s', threshold = '%s' WHERE nid = '%s'", $artikul_zp, '1', $row['Kol-vo'], '0', $nid);
                        						else
                          		   				  db_query("INSERT INTO {uc_product_stock} (sku, nid, active, stock, threshold) VALUES ('%s', '%s', '%s', '%s', '%s')", $artikul_zp, $nid, '1', $artikul_zp, $row['Kol-vo'], '0');
                               				 }

                                        drupal_set_message("Attention!!! Polnoe sovpadenie Gorod-Magazin-Otdel-Artikul for product in Catalog with Artikul = $tmp_Artikul_postavki, Name = $name_bd. But it has different Name = $name_file in file. Pruduct propuskaetsia (GLOBAL instruction from user on first ekran!)!", 'error');
                                        continue (2);

                                   case 'Name_from_file':

                                        // меняем название в базе на новое из файла
                                        drupal_set_message("Attention!!! Product in Catalog with Artikul = $tmp_Artikul_postavki, Name = $name_bd has different Name = $name_file in file. Ispolzuetsia Name iz faila, $name_file (GLOBAL instruction from user on first ekran!)", 'error');

                                        //меняем имя продукта в двух таблицах
		   	    	        			db_query("UPDATE {node} SET title = '%s', uid = '%s', changed = '%s' WHERE nid = '%s'", $name_file, $user->uid, time(), $nid);
		   	     	        			db_query("UPDATE {node_revisions} SET title = '%s', uid = '%s', timestamp = '%s' WHERE nid = '%s' AND vid = '%s'", $name_file, $user->uid, time(), $nid, $vid);

		            	      			 // переписываем алиас с помощью транслита pathauto
		            	      			 // для этого сначала удаляем существующий алиас,
		            	        		 // а потом запускаем функцию node_pathauto_bulkupdate, которая создаёт алиасы для всех нодов, к которых нет алиасов
		            	        		 db_query("DELETE FROM {url_alias}  WHERE src = '%s'", 'node/'.$nid);
		            	        		 db_query("DELETE FROM {url_alias}  WHERE src = '%s'", 'node/'.$nid.'/edit');

		            	        		 //для возможности вызова node_pathauto_bulkupdate один раз вначале текущей функции вызываем _pathauto_include();
		            	        		 node_pathauto_bulkupdate();

                                         // обновим переменную $name_bd
                                         $name_bd = $name_file;

                                         break;

                            	   case 'Name_from_DB':
                                        // оставляем имя из базы, предполагая, что в файле просто опечатка в имени
                                        drupal_set_message("Attention!!! Product in Catalog with Artikul = $tmp_Artikul_postavki, Name = $name_bd has different Name = $name_file in file. Ispolzuetsia Name iz DB, $name_bd (GLOBAL instruction from user on first ekran!)", 'error');
                                        break;

                                  } // end of switch

		                     }  // end of if($name_bd != $name_file)


                             // увеличим на 1 счётчик изменённых продуктов
                             $product_updated_count++;

  		   	   			 	 $vid = db_result(db_query("SELECT vid FROM {node} WHERE nid = '%s' ", $nid));


                             // если ранее артикул zp не был определён и введен, вводим его, предварительно определив vid
		   	    		     if($need_to_write_artikul_zp)
                               {
                       			 db_query("INSERT INTO {content_field_artikul_zp} (nid, vid, field_artikul_zp_value) VALUES ('%s', '%s', '%s')", $nid, $vid, $artikul_zp);
                       			 //внесём артикул zp также в таблицу продуктов как основной артикул базы SKU, вернее, уточним это поле, так как продукт в базе есть, а артикул zp для него пока не определён,
                       			 // это может случиться из-за ручного ввода продукта в базу. В таком случае понятно, что вручную артикул zp определить сложно, и артикул zp (а значит и правильный артикул SKU) в базу введен не был
                       			 db_query("UPDATE {uc_products} SET model = '%s' WHERE vid = '%s'", $artikul_zp, $vid);
                       			 // раз не был введён правильный артикул SKU, значит не было введено и правильное количество продукта в базу
                       			 // вернее, количество было привязано в базе к неправильному артикулу, а это неправильно
                       			 // значит нам нужно удалить старую строку с неправильным артикулом, и добавить строку с вот этим артикулом zp и текущим куоличеством продукта, взятым из файла

                        		 // для начала, если в файле не опредено количество продукта, попробуем взять его из базы с пока неправильным
                       			 // если такая строка в таблице отсутствует (при вооде продукта вручную не было указано количество и/или активность продукта для отслеживаниющей количество системы),
                        		 // то $row['Kol-vo'] останется неопределённым, но это не страшно

                        		 // попробуем взять количество продукта из базы (база может и не содержать это количество при ручном вводе продукта в базу)
                        		 $kol_vo_tmp = db_result(db_query("SELECT stock FROM {uc_product_stock} WHERE nid = '%s'", $nid));

		                         if(!$row['Kol-vo']) // если в файле не определено количество продукта
                        		  {
                         		  	 // если количество было определено в базе
                         		  	 if($kol_vo_tmp)
                           		 	  {
                           		  	    // присываиваем переменной $row['Kol-vo'], которое не было определено в файле, значение из базы
                               		    $row['Kol-vo'] = $kol_vo_tmp;
                            	 	  }
                         		  }

                        		 if($kol_vo_tmp)
                         		   db_query("UPDATE {uc_product_stock} SET sku = '%s', active = '%s', stock = '%s', threshold = '%s' WHERE nid = '%s'", $artikul_zp, '1', $row['Kol-vo'], '0', $nid);
                        		 else
                          		   db_query("INSERT INTO {uc_product_stock} (sku, nid, active, stock, threshold) VALUES ('%s', '%s', '%s', '%s', '%s')", $artikul_zp, $nid, '1', $artikul_zp, $row['Kol-vo'], '0');
                               }



		   	    		 	 drupal_set_message("Polnoe sovpadenie Gorod-Magazin-Otdel-Artikul for product in Catalog with Artikul = $tmp_Artikul_postavki, Name = $name_bd (Name = $name_file in file), Nid = $nid, Vid = $vid. Proizvoditsia zamena! (Set by GLOBAL user unstruction on first screen or in file in field ZAMENA = 1 for this product).", 'error');

		           			 // установим текущего пользователя как автора изменений
		           		 	 // новый автор установится даже в том случае, если ни одно поле не было изменено (например, если все поля были пустые)
		           			 // просто иначе пришлось бы устанавливать функцию установки автора для каждого поля...

		           			 //global $user; // объявим эту переменную вначале функции
                             //$userid = $user->uid;
                             //$username = $user->name;
                             db_query("UPDATE {node} SET uid = '%s', changed = '%s' WHERE nid = '%s'", $user->uid, time(), $nid);
                             db_query("UPDATE {node_revisions} SET uid = '%s', timestamp = '%s' WHERE nid = '%s' AND vid = '%s'", $user->uid, time(), $nid, $vid);

                             //drupal_set_message("======UserID = $userid, username = $username", 'error');



                             // выведем в файл очередную порцию данных по этому продукту

                             //$r_t_f = "No:;Product_name;Artikul_postavki;Proizvoditel;Artikul_proizv;Bar;Gorod->Magazin->Otdel(s);Artikul_zp;Action;Notice;Price;Kol-vo;Kartinki;" . "\n";
                             $r_t_f = $r_t_f . 'Updated... ;;';

                             // выведем в файл sell_price, если он указан
	         	 			 if($row['Sell_price'] AND  $row['Sell_price'] != '')
                       			 $r_t_f = $r_t_f . $row['Sell_price'] . ';';
                   			 else
                       			 $r_t_f = $r_t_f . ';';

                             // если в файле указано количество продукта
	         	 			 if($row['Kol-vo'] AND  $row['Kol-vo'] != '')
                               {
                                  // введём данные в базу
                                  db_query("UPDATE {uc_product_stock} SET sku = '%s', active = '%s', stock = '%s', threshold = '%s' WHERE nid = '%s'", $artikul_zp, '1', $row['Kol-vo'], '0', $nid);
                                  // и выведем его в файл
                                  $r_t_f = $r_t_f . $row['Kol-vo'] . ';';
                               }
                   			 else
                               {
                                 // иначе обозначим в файле, что поле пропущено
                                 $r_t_f = $r_t_f . 'Skip;';
                                 // а если не жалко времени на дополнительный доступ к базе, можем оттуда взять старое количество продукта
                                 // $kol_vo_tmp = db_result(db_query("SELECT stock FROM {uc_product_stock} WHERE nid = '%s'", $nid));
                                 // $r_t_f = $r_t_f . $kol_vo_tmp . ';';
                               }

                             // стараемся ввести максимальное количество полей за одно обращение к базе
                             // для этого определяем несколько вариантов ввода, в зависимости от того, сколько полей определено
                             // если будет больше полей для ввода/изменения в таблицу uc_products, то вариантов ввода (ниже) будет больше

                              // если определены и не пустые поля 'Weight' и 'Sell_price'
                              if($row['Weight'] > 0 AND $row['Weight'] != '' AND $row['Sell_price'] > 0 AND $row['Sell_price'] != '')
                                {
                                  db_query("UPDATE {uc_products} SET weight = '%s', sell_price = '%s' WHERE vid = '%s'", $row['Weight'], $row['Sell_price'], $vid);
                                }
                              // если определены и не пустые поля 'Weight'
                              else if($row['Weight'] > 0 AND  $row['Weight'] != '')
                                {
                                  db_query("UPDATE {uc_products} SET weight = '%s' WHERE vid = '%s'", $row['Weight'], $vid);
                                }
                              // если определены и не пустые поля 'Sell_price'
                              else if($row['Sell_price'] > 0 AND $row['Sell_price'] != '')
                                {
                                  db_query("UPDATE {uc_products} SET sell_price = '%s' WHERE vid = '%s'", $row['Sell_price'], $vid);
                                }



                              //$r_t_f = "No:;Product_name;Artikul_postavki;Proizvoditel;Artikul_proizv;Bar;Gorod->Magazin->Otdel(s);Artikul_zp;Action;Notice;Price;Kol-vo;Kartinki;" . "\n";





                               // Если определено поле Картинки, вносим в базу соответствующие изменения

// ###############################################################

                            if($row['Kartinki'] AND  $row['Kartinki'] != '')
                              {

// ###########################################################

                                  // меняем картинки для продукта

                                  //$tmp1 = $row['Artikul_postavki'];
                                  //$tmp2 = $row['Kartinki'];
                                  //drupal_set_message("--------------Pole Kartinki opredeleno!!!!!!!", 'error');
                                  //drupal_set_message("--------------Artikul_postavki = $tmp1, Kartinki = $tmp2", 'error');




                                       switch($form_values['pictures_handling'])
                                        {
                                          case 'Skip': // если в общих настройках на первом экране сказано пропускать картинки, то пропускаем это поле

                                             //drupal_set_message("Zadan GLOBALNYI propusk obrabotki kartinok. Pole s kartinkami propuskaetsjia!", 'error');
                                             break (2);

                                          case 'UseAllPicsOrAddOne': // если продукт имеет картинки и/или найдены картинки (и добавлены в этот продукт) в других продуктах с таким же названием или штрих-кодом
                                                                     // то не создавать новых картинок
                                                                     // иначе создать одну новую картинку
                                             $row['Kartinki'] = '*'; // считаем, как будто во всех продуктах это поле содержит *
                                             break;

                                          case 'AddOneNewIfNoSelfPicsBefore': // если продукт имеет картинки, то новые картинки не добавляются, а поле пропускается
                                                                     // если продукт не содержал уже своих картинок, то добавляяется одна картинка
                                                                     // поиск картинок по другим продуктам НЕ производится
                                             $row['Kartinki'] = '!?'; // считаем, как будто во всех продуктах это поле содержит !?
                                             break;


                                          case 'Fromfile':
                                          default:
                                             // во всех остальных случаях берутся инструкции из файла
                                             break;
				        				}



                                       // если поле равно '' или '0' или 'skip'
 				       				   // ничего не делать с этим полем
                                       if( $row['Kartinki'] == '' OR $row['Kartinki'] == '0' OR $row['Kartinki'] == 'skip')
                                         break;


                                       // начнём вывод в файл поля с картинками
                                       $r_t_f = $r_t_f . '"';





                                       // начальная инициализация данных

                                       // берём для имени файла имя продукта, делаем все маленькие буквы
                                       // удаляем из него все лишние символы и преобразауем в транслит
				       		           $image_name = strtolower(preg_replace($pattern, $separator, strtr($row['Name'], $translations)));
				       		           //drupal_set_message("1. image_name = $image_name", 'error');
                                       // определяем следующий за последним номер fid в таблице files
                                       $files_fid = 1+ db_result(db_query("SELECT id FROM {sequences} WHERE name = 'files_fid'"));

                                       //каталог для картинок $file_directory_path определяется единожды в начале функции


                                       // если эта ревизия этой ноды уже имеет картинки, то добавляем картинку в конец (delta новой картинки на 1 больше самой большой для данной ревизии данной ноды)

                                       // поиск максимального значения дельты из таблицы - с помощью сортировки максимальную дельту ставим вперёд и её получаем как первое значение
                                       $delta = 0;
                                       $find_delta = 0; // временная переменная
                                       $find_delta = db_result(db_query("SELECT delta FROM {content_field_image_cache} WHERE vid = '%s' ORDER BY delta DESC", $vid));
                                       //drupal_set_message("xxxx - find_delta = $find_delta, delta = $delta", 'error');

                                       if($find_delta >= 0) // если дельта из базы больше или равна нулю, значит в базе уже есть картинка с такой дельтой
                                          $delta = $find_delta + 1;

                                       // теперь дельта у нас равна следующей свободной или нулю (если пока не было картинок для данной ревизии данной ноды)






                                       // если в общих настройках на первом экране сказано добавлять картинки пропускать картинки
                                       // пропускаем



                                       // в зависимости от содержимого поля "Kartinki" выполняем различные действия
                                       switch($row['Kartinki'][0])
                                        {
                                          case '!': // установка новых картинок на основе имени продукта
                                                    // если ревизия уже содержит картинки, добавляем новые в конец имеющихся
                                                    // количество добавляемых картинок определяется числом, следующим за "!"


                                                if($delta > 0 AND $row['Kartinki'][1] == '?')
                                                  {
                                                  	// если за ! следует ? и продукт уже содержит картинки,
                                                  	// то новых картинок не добавляем
                                                  	break (2); // переходим к следующему полю в файле для этого продукта
                                                  }
                                                // добавляем картинки к текущей ноде и текущей ревизии






                                                // если в файле после "!" (или "!?") указано число "х", это значит,
                                                // что необходимо добавить "х" картинок, что и делаем
                                                // для каждой последующей картинки к имени файла добавляем "~х", начиная с 2. (~2, ~3 и т.д...)
                                                // если оно больше 1, то значит необходимо добавить ещё указанное число - 1 (так как уже одну добавили) картинок

                                                // определим это число
                                                if($row['Kartinki'][1] == '?') // если второй символ (за !) в поле ?, то числом вставляемых картинок будет третяя позиция (это может быть и двухзначное число)
                                                  {
                                                  	$add_pics_count = explode("?", $row['Kartinki']);
                                                    $add_pics_count = $add_pics_count[1];
                                                    //если там не число, а какая-нибудь другая чепуха, то считаем, что там 0.
                                                    drupal_set_message("add_pics_count if ? = $add_pics_count", 'error');
                                                    if(!is_numeric($add_pics_count))
                                                      $add_pics_count = 1;
                                                    //drupal_set_message("add_pics_count if ? = $add_pics_count", 'error');
                                                  }
                                                else   // иначе число вставляемых картинок - это число за ! (это может быть и двухзначное число)
                                                  {
                                                  	$add_pics_count = explode("!", $row['Kartinki']);
                                                    $add_pics_count = $add_pics_count[1];
                                                    //если там не число, а какая-нибудь другая чепуха, то считаем, что там 0.
                                                    drupal_set_message("add_pics_count = $add_pics_count", 'error');
                                                    if(!is_numeric($add_pics_count))
                                                      $add_pics_count = 1;
                                                    //drupal_set_message("add_pics_count if NUM = $add_pics_count", 'error');
                                                  }



                                                // если это не первая картинка, то к названию файла добавим "~x", где "х" = дельта+1 (+1, чтобы после первой картинки без тильды сразу шла картинка с ~2, пропуская ~1)
                                                if($delta == 0)
                                                  {
                                                    db_query("INSERT INTO {files} (fid, nid, filename, filepath, filemime) VALUES ('%s', '%s', '%s', '%s', '%s')", $files_fid, $nid, $image_name.'.jpg', $file_directory_path . '/' . $image_name . '.jpg', 'image/jpeg');

                                             	    // выведем название первого добавленного файла, если у продукта ещё не было картинок
                                               	    $pics_name = $file_directory_path . '/' . $image_name . '.jpg';
                                                    $index_pics = 1;
                                                    drupal_set_message("K productu dobavleny kartinki:", 'error');
                                                    drupal_set_message("$index_pics: $pics_name", 'error');

                                                    // выводим имена картинок в файл
                                                    $r_t_f = $r_t_f . "K productu dobavleny kartinki: \n";
                                                    $r_t_f = $r_t_f . $pics_name . "\n";
                                                  }
                                                else
                                                  {
                                                    $counter = $delta + 1; // чтобы картинка пронумеровалась следующей за последней присутствующей в базе. Даже если предыдущие картинки не нумеровались, эта картинка будет пронумерована по счёту картинок на эту ревизию
                                                    db_query("INSERT INTO {files} (fid, nid, filename, filepath, filemime) VALUES ('%s', '%s', '%s', '%s', '%s')", $files_fid, $nid, $image_name . '~' . $counter . '.jpg', $file_directory_path . '/' . $image_name . '~' . $counter . '.jpg', 'image/jpeg');

                                             	    // выведем название первого добавленного файла, если у продукта уже были картинки
                                               	    $pics_name = $file_directory_path . '/' . $image_name . '~' . $counter . '.jpg';
                                                    $index_pics = 1;
                                                    drupal_set_message("K productu dobavleny kartinki:", 'error');
                                                    drupal_set_message("$index_pics: $pics_name", 'error');

                                                    // выводим имена картинок в файл
                                                    $r_t_f = $r_t_f . "K productu dobavleny kartinki: \n";
                                                    $r_t_f = $r_t_f . $pics_name . "\n";
                                                  }

                                                // увеличиваем системный счётчик файлов в таблице sequences
                                                db_query("UPDATE {sequences} SET id = %s WHERE name = 'files_fid'", $files_fid);


                                                // добавляем запись в content_field_image_cache

                                                // записываем ссылку на картинку в таблицу content_field_image_cache с найденной нодой
                                                // и со ссылкой на только что введенную картинку в таблице files
                                                db_query("INSERT INTO {content_field_image_cache} (vid, delta, nid, field_image_cache_fid) VALUES ('%s', '%s', '%s', '%s')", $vid, $delta, $nid, $files_fid);







                                                if($add_pics_count > 1)
                                                 {

                                                  $row['Kartinki'][1] = $row['Kartinki'][1] + $delta;
                                                  while($delta < $row['Kartinki'][1] - 1 )
                                                   {
                                                     $delta++;

                                                     $files_fid++;
                                                     $counter = $delta + 1; // чтобы нумерация картинок продолжалась не с ~1, а с ~2

                                                     // добавляем картинки к текущей ноде и текущей ревизии
                                                     db_query("INSERT INTO {files} (fid, nid, filename, filepath, filemime) VALUES ('%s', '%s', '%s', '%s', '%s')", $files_fid, $nid, $image_name . '~' . $counter . '.jpg', $file_directory_path . '/' . $image_name . '~' . $counter . '.jpg', 'image/jpeg');
                                                     // увеличиваем системный счётчик файлов в таблице sequences
                                                     db_query("UPDATE {sequences} SET id = %s WHERE name = 'files_fid'", $files_fid);

                                                     // записываем ссылку на картинку в таблицу content_field_image_cache с найденной нодой
                                                     // и со ссылкой на только что введенную картинку в таблице files
                                                     db_query("INSERT INTO {content_field_image_cache} (vid, delta, nid, field_image_cache_fid) VALUES ('%s', '%s', '%s', '%s')", $vid, $delta, $nid, $files_fid);

                                                     // выводим по очереди остальные названия картинок, добавленные к продукту
                                                     $pics_name = $file_directory_path . '/' . $image_name . '~' . $counter . '.jpg';
                                                	 $index_pics = $index_pics + 1;
                                                     drupal_set_message("$index_pics: $pics_name", 'error');

                                                     // выводим имена картинок в файл
                                                     $r_t_f = $r_t_f . $pics_name . "\n";

                                                   }

                                                 }



                                                // нужно очистить кеш (cache_content), чтобы данные на сайте обновились
                                                // сделаем это один раз в конце функции


                                                break;



                                             case '?':
                                                // поиск уже существующих в базе картинок и установка дополнительно новых на основе имени продукта
                                                // "?+х" (или "?-х") - поиск продуктов с таким же названием и копирование всех картинок в этот продукт.
                                                // Как вариант, может также пытаться искать продукты с таким же штрих-кодом или артикулом производителя; Если задано "+х", то к найденным придавит ещё "х" новых и поставит их в конец списка (в каталоге будут отображаться сначала найденные, а потом вновь созданные). Если задано "-х", то вновь созданные поставятся в начало списка и будут отображаться в каталоге первыми.
                                                // Если ничего не найдено, то будет создано "х" картинок.

                                                // $name_file - имя продукта, взятое из файла и уже либо установленное для текущего продукта либо и продукт и так имел это имя
                                                // но на всякий случай (вдруг для продукта оставлено имя, которое у него было изначально, а имя из файла проигнорировано или его и не было там?) выясняем имя текущего продукта из базы
                                                $product_name = db_result(db_query("SELECT title FROM {node} WHERE nid = '%s' AND vid = '%s'", $nid, $vid));


                                                // определим штрих-код текущего продукта
                                                $current_product_bar = db_result(db_query("SELECT field_bar_value FROM {content_field_bar} WHERE vid = '%s'", $vid));

                                                // если после окончания проверки эта переменная будет больше или равна нулю
                                                // значит были найдены картинки для использования
                                                $found_pics_index = -1;

                                                // если после окончания цикла эта переменная будет больше или равна нулю
                                                // значит продукт изначально содержал картинки
                                                $existed_pics_filepath_index = -1;

                                                $existed_pics_filepath = array();


                                                // создаём массив, который содержит уже записанные в данном продукте fid'ы
                                                // затем будем накапливать новые fid из других продуктов с таким же названием только в том случае, если их и так уже нет в данном продукте
                                                // для этого каждый новый fid будем сравнивать с этим масивом (перебирая все его элементы) и добавлять в массив новых фидов только те, которых нет в этом массиве
                                                $existed_pics_fids_query = db_query("SELECT field_image_cache_fid, nid FROM {content_field_image_cache} WHERE vid = '%s'", $vid);
                                                $existed_pics_fid_query = db_fetch_object($existed_pics_fids_query);

                                                if($existed_pics_fid_query->nid > 0)
                                                  {

                                                     // создадим sql-строку, которая за один раз вытащит из таблицы  files все картинки текущего продукта
                                                     $sql_current_product_fids = "SELECT nid, filename, filepath FROM {files} WHERE nid = ";


                                                     // возьмём первое значение
                                                     $sql_current_product_fids = $sql_current_product_fids . $existed_pics_fid_query->nid;


                                                     // добавим все остальные ноды
                                                     while($existed_pics_fid_query = db_fetch_object($existed_pics_fids_query))
                                                        $sql_current_product_fids = $sql_current_product_fids . ' OR nid = ' . $existed_pics_fid_query->nid;


                                                     //drupal_set_message("00000******** sql_current_product_fids = $sql_current_product_fids", 'error');

                                                     $existed_pics_fids_query = db_query($sql_current_product_fids);



                                                     while($existed_pics_fid = db_fetch_object($existed_pics_fids_query))
                                                        {
                                                          $existed_pics_filepath_index++;
                                                          $existed_pics_filepath[$existed_pics_filepath_index][0] = $existed_pics_fid->filepath;
                                                          $existed_pics_filepath[$existed_pics_filepath_index][1] = $existed_pics_fid->filename;

                                                          //$tmp = $existed_pics_filepath[$existed_pics_filepath_index][0];
                                                          //drupal_set_message("!!!!!!!!existed_pics_filepath[existed_pics_filepath_index][0] = $tmp", 'error');
                                                        }


                                          	      } // конец проверки, есть ли вообще какие-то картинки у продукта (не пустая ли строка, возвращаемая на запрос о картинках для этого продукта)

                                          	    // теперь если переменная $existed_pics_filepath_index больше или равна нулю
                                          	    // то продукт содержит картинки и это значение показывает (количество присутствующих в продукте картинок - 1);
                                                // и может использоваться как delta (если больше или равно нулю, то это текущее максимальное значение delta.... например, delta = 0, значит у продукта одна картинка)



                                                // массив $found_pics_fids, который будет содержать fid новых картинок, которые мы найдём среди существующих в базе продуктов и скопируем в наш продукт
                                                $found_pics_filepath = array();

                                                // находим в базе все ноды (продукты) с таким же именем
                                                // ИЛИ с таким же штрих-кодом, как у данного продукта
                                                // (кроме самого текущего продукта) и с типом, как у текущего продукта
                                                // для поиска по названию рассматриваем только продукты аналогичного с данным типа, предполагая, что в продуктах другого типа нет нужных нам продуктов... Да и так мы существенно сокращаем время поиска

                                                // Определим тип продукта. Ранее этого не сделали, чтобы не обращаться к базе, так на предыдущих проверках продукт мог быть пропущен из-за отсутствия города, отдела и т.д...
                                                $product_type = db_result(db_query("SELECT type FROM {node} WHERE nid = '%s'", $nid));

                                                // тип продукта при поиске одинаковых штрих-кодов не оговаривается (так как невозможно за один запрос выяснить и штрих-коды и типы, а таблица со  штрих-кодами не содержит описания типа продуктов), но будем считать, что одинаковых штрих-кодов не может быть у продуктов разных типов!

                                                $is_similar_names = 0; // флаг наличия продуктов с таким же именем
                                                $is_similar_bars = 0;  // флаг наличия продуктов с таким же штрих-кодом


                                                $similar_name_nodes = db_query("SELECT nid, vid, title FROM {node} WHERE title = '%s' AND nid != '%s' AND type = '%s'", $product_name, $nid, $product_type);
                                                $similar_name_node_temp1 = db_fetch_object($similar_name_nodes);
                                                if(is_numeric($similar_name_node_temp1->nid))
                                                   $is_similar_names = 1;

                                                $similar_bar_nodes = db_query("SELECT nid, vid FROM {content_field_bar} WHERE field_bar_value = '%s' AND nid != '%s'", $current_product_bar, $nid);
                                                $similar_name_node_temp2 = db_fetch_object($similar_bar_nodes);
                                                if($similar_name_node_temp2->nid > 0)
                                                   $is_similar_bars = 1;


                                                //drupal_set_message(" ------is_similar_names =  $is_similar_names, is_similar_bars = $is_similar_bars,,,,, temp1_nid = $temp1_nid, temp2_nid = $temp2_nid ", 'error');

                                                if($is_similar_names OR $is_similar_bars)    // если есть продукты с таким же именем или с таким же штрихкодом
                                                 {

                                                   if($is_similar_names AND !$is_similar_bars) // если есть только ноды с таким же именем, но нет продуктов с таким же штрих-кодом
                                                     {
                                                       // создадим sql-строку, которая за один раз вытащит из таблицы  files все только что найденные продукты с таким же названием, как у текущего продукта, вместе с названиями файлов
                                                       $sql_similar_name_or_bar_fids = "SELECT nid, filename, filepath FROM {files} WHERE nid = ";

                                                       // возьмём первое значение
                                                       $sql_similar_name_or_bar_fids = $sql_similar_name_or_bar_fids . $similar_name_node_temp1->nid;

                                                        // выведем названия продуктов для найденных продуктов
                                                       drupal_set_message("!Naideny propucti s takim zhe nazvaniem $product_name:", 'error');
                                                       //$tmp1 = $similar_name_node_temp1->nid;
                                                       //$tmp1_count = 1;
                                                       //drupal_set_message("$tmp1_count: nid of product = $tmp1", 'error');


                                                       // добавим все остальные ноды
                                                       while($similar_name_node_temp1 = db_fetch_object($similar_name_nodes))
                                                        {
                                                          $sql_similar_name_or_bar_fids = $sql_similar_name_or_bar_fids . ' OR nid = ' . $similar_name_node_temp1->nid;

                                                          // выведем номера нодов для остальных найденных продуктов
                                                          //$tmp1 = $similar_name_node_temp1->title;
                                                          //$tmp1_count = $tmp1_count + 1;
                                                          //drupal_set_message("$tmp1_count: nid of product = $tmp1", 'error');
                                                        }
                                                       //drupal_set_message("====1 is Similar names ********sql_similar_name_or_bar_fids = $sql_similar_name_or_bar_fids", 'error');

                                                     }
                                                   if(!$is_similar_names AND $is_similar_bars)  // если есть только ноды с таким же штрих-кодом, но нет продуктов с таким же именем
                                                     {
                                                       // создадим sql-строку, которая за один раз вытащит из таблицы  files все только что найденные продукты c таким же штрих-кодом, как у текущего продукта, вместе с названиями файлов
                                                       $sql_similar_name_or_bar_fids = "SELECT nid, filename, filepath FROM {files} WHERE nid = ";

                                                       // возьмём первое значение
                                                       $sql_similar_name_or_bar_fids = $sql_similar_name_or_bar_fids . $similar_name_node_temp2->nid;

                                                        // выведем номера нодов для найденных продуктов
                                                       drupal_set_message("!Naideny propucti s takim zhe bar-codom $current_product_bar:", 'error');
                                                       //$tmp2 = $similar_name_node_temp2->nid;
                                                       //$tmp2_count = 1;
                                                       //drupal_set_message("$tmp2_count: nid of product = $tmp2", 'error');

                                                       // добавим все остальные ноды
                                                       while($similar_name_node_temp2 = db_fetch_object($similar_bar_nodes))
                                                         {
                                                          $sql_similar_name_or_bar_fids = $sql_similar_name_or_bar_fids . ' OR nid = ' . $similar_name_node_temp2->nid;

                                                          // выведем номера нодов для остальных найденных продуктов
                                                          //$tmp2 = $similar_name_node_temp2->nid;
                                                          //$tmp2_count = $tmp2_count + 1;
                                                          //drupal_set_message("$tmp2_count: nid of product = $tmp2", 'error');
                                                         }

                                                     }
                                                   if($is_similar_names AND $is_similar_bars)  // если есть продукты и с таким же именем, и с таим же штрих-кодом
                                                     {
                                                       // создадим sql-строку, которая за один раз вытащит из таблицы  files все только что найденные продукты, у которых названия или штрих-коды равны, вместе с названиями файлов
                                                       // стоит обратить внимание, что AND в данном случае не говорит о том, что у продуктов одновременно равны и названия и штрих-коды. Это говорит, что среди найденных продуктов есть продукты и с таким же названием, и с таким же штрих-кодом.
                                                       $sql_similar_name_or_bar_fids = "SELECT nid, filename, filepath FROM {files} WHERE nid = ";

                                                       // сначала добавим все продукты с таким же названием
                                                       // возьмём первое значение
                                                       $sql_similar_name_or_bar_fids = $sql_similar_name_or_bar_fids . $similar_name_node_temp1->nid;

                                                        // выведем номера нодов для найденных продуктов с таким же названием
                                                       drupal_set_message("!Naideny propucti s takim zhe nazvaniem $product_name:", 'error');
                                                       //$tmp1 = $similar_name_node_temp1->nid;
                                                       //$tmp1_count = 1;
                                                       //drupal_set_message("$tmp1_count: nid of product = $tmp1", 'error');

                                                       // добавим все остальные названия найденных нодов с таким же названием
                                                       while($similar_name_node_temp1 = db_fetch_object($similar_name_nodes))
                                                        {
                                                          $sql_similar_name_or_bar_fids = $sql_similar_name_or_bar_fids . ' OR nid = ' . $similar_name_node_temp1->nid;

                                                          // выведем номера нодов для остальных найденных продуктов с таким же названием
                                                          //$tmp1 = $similar_name_node_temp1->nid;
                                                          //$tmp1_count = $tmp1_count + 1;
                                                          //drupal_set_message("$tmp1_count: nid of product = $tmp1", 'error');
                                                        }


                                                       // теперь добавим сюда же продукты с таким же штрих-кодом
                                                       // первую проверку пропускаем, так как она сделана ранее (при инициализации флага $is_similar_bars)
                                                       $sql_similar_name_or_bar_fids = $sql_similar_name_or_bar_fids . ' OR nid = ' . $similar_name_node_temp2->nid;

                                                       // выведем номера нодов для найденных продуктов c таким же бар-кодом
                                                       drupal_set_message("!Naideny propucti s takim zhe bar-codom $current_product_bar:", 'error');
                                                       //$tmp2 = $similar_name_node_temp2->nid;
                                                       //$tmp2_count = 1;
                                                       //drupal_set_message("$tmp2_count: nid of product = $tmp2", 'error');


                                                       // добавим все остальные ноды с таким же бар-кодом
                                                       while($similar_name_node_temp2 = db_fetch_object($similar_bar_nodes))
                                                         {
                                                          $sql_similar_name_or_bar_fids = $sql_similar_name_or_bar_fids . ' OR nid = ' . $similar_name_node_temp2->nid;

                                                          // выведем номера нодов для остальных найденных продуктов с таким же бар-кодом
                                                          //$tmp2 = $similar_name_node_temp2->nid;
                                                          //$tmp2_count = $tmp2_count + 1;
                                                          //drupal_set_message("$tmp2_count: nid of product = $tmp2", 'error');
                                                         }


                                                       //drupal_set_message("====3 is Similar names and bars********sql_similar_name_or_bar_fids = $sql_similar_name_or_bar_fids", 'error');

                                                     }



                                                   $similar_name_or_bar_nodes = db_query($sql_similar_name_or_bar_fids);

                                                   // определим масив, который будет содержать штрих-коды для всех найденных продуктов
                                                   // чтобы для одинаковых нодов каждый раз не определять заново штрих-код, обращаясь к базе
                                                   $bar_codes = array();


                                                   for($count = 0; $similar_name_node = db_fetch_object($similar_name_or_bar_nodes); $count++)
                                          	    	{
                                            	     $similar_name_node_nid = $similar_name_node->nid;
                                            	     //$similar_name_node_vid = $similar_name_node->vid;
                                            	     //drupal_set_message("current_product_nid = $nid, similar_name_node_nid = $similar_name_node_nid, product_type = $product_type", 'error');

                                            	     // для каждого продукта проверим, не различаются ли штрихкоды данного (который вводом) продукта и рассматриваемого
                                            	     // для этого проверим, определены ли штрихкоды для обоих продуктов?

                                            	     // тут, конечно, лучше было бы использовать vid, но таблица files не имеет такого поля, поэтому используем nid.
                                            	     // при желании более точно подходить к вопросу, можно делать дополнительный запрос к базе (к таблице nodes), чтобы выяснить текущую vid

                                                     // но пока условимся, что штрих-коды равны для всех ревизий

                                                     if($bar_codes[$similar_name_node_nid][0])
                                                      {
                                                       $test_product_bar = $bar_codes[$similar_name_node_nid][1];
                                                      }
                                                     else
                                                      {
                                                       $test_product_bar = trim(db_result(db_query("SELECT field_bar_value FROM {content_field_bar} WHERE nid = '%s'", $similar_name_node->nid))); // на всякий случай убираем лишние пробелы
                                                       $bar_codes[$similar_name_node_nid][0] = 1; // флаг, что штрих-код для данной ноды найден
                                                      }

                                                     //drupal_set_message("count = $count, xxx-----test_product_bar = $test_product_bar, current_product_bar = $current_product_bar => similar_name_node_nid = $similar_name_node_nid", 'error');

                                            	     if(( ($test_product_bar > 0) AND ($current_product_bar > 0) ) AND ($test_product_bar != $current_product_bar))
                                            	      {
                                            	       //если оба штрих-кода определены, но не равны, значит это разные объекты и картинки брать нельзя
                                            	       // значит пропускаем этот продукт
                                                       drupal_set_message("test_product_bar = $test_product_bar (NEEEEEEEE Ravno!!!) current_product_bar = $current_product_bar => similar_name_node_nid = $similar_name_node_nid", 'error');
                                                       continue;
                                            	      }

                                                     //иначе или штрих-коды равны, или не определены для одного из значений, значит предполагаем, что продукты равны и картинки рассматриваемого продукта использовать можно
                                                     //drupal_set_message("test_product_bar = $test_product_bar (Ravno!!!) current_product_bar = $current_product_bar => similar_name_node_nid = $similar_name_node_nid", 'error');


                                                     // проверяем, нет ли уже у текущего продукта такой картинки?
                                                     for($in = 0; $in <= $existed_pics_filepath_index; $in++)
                                                        {
                                                          // если такой fid уже содержится в массиве, пропускаем этот fid
                                                          if($existed_pics_filepath[$in][0] == $similar_name_node->filepath)
                                                            {
                                                              //drupal_set_message("Sovpadenie #1: VNUTRI (with existed in this product pics)  na $similar_name_node->filepath, nid = $similar_name_node->nid", 'error');
                                                              continue (2);
                                                            }
                                                        }


                                                     // проверяем, нет ли уже среди внесённых в новый массив очередной проверяемой картинки?
                                                     for($in = 0; $in <= $found_pics_index; $in++)
                                                        {
                                                          // если такой fid уже содержится в массиве, пропускаем этот fid
                                                          if($found_pics_filepath[$in][0] == $similar_name_node->filepath)
                                                            {
                                                              //drupal_set_message("2) Sovpadenie #2: (s tol'ko chto naidennymi pics) na $similar_name_node->filepath, nid = $similar_name_node->nid, PROPUSKAEM!", 'error');
                                                              continue (2);
                                                            }
                                                        }


                                                      // если мы дошли до этого шага, значит такого fid в массиве нет
                                                      // и значит мы его добавляем
                                                      $found_pics_index++;
                                                      $found_pics_filepath[$found_pics_index][0] = $similar_name_node->filepath;
                                                      $found_pics_filepath[$found_pics_index][1] = $similar_name_node->filename;

                                                      //$tmp = $found_pics_filepath[$found_pics_index][0];
                                                      //$xxx = found_pics_index;
                                                      //drupal_set_message("found_pics_filepath[$xxx][0] = $tmp", 'error');

                                                    } // конец перебора нодов с таким же именем, как у текущего продукта, имебщих картинки

                                                 } // конец проверки, есть ли продукты таким же именем с картинками      if(($similar_name_nodes = db_query("SELECT nid, vid FROM {node} WHERE title = '%s' AND nid != '%s' AND type = '%s'", $product_name, $nid, $product_type)) > 0 )












                                                 // теперь
                                                 // если переменная $existed_pics_filepath_index не равна нулю, то значит в продукте изначально были картинки
                                                 // если переменная $found_pics_index больше нуля, то картинки найдены


                                                 // если после знака вопроса стоял ещё и  "+",
                                                 // до ещё добавляем в базу столько названий файлов, сколько указано после плюса
                                                 $add_pics_count = 0;
                                                 if($row['Kartinki'][1] == '+')
                                                   {
                                                    $add_pics_count = explode("+", $row['Kartinki']);
                                                    $add_pics_count = $add_pics_count[1];
                                                    //drupal_set_message("-------add_pics_count = $add_pics_count", 'error');
                                                    //drupal_set_message("found_pics_index = $found_pics_index, existed_pics_filepath_index = $existed_pics_filepath_index", 'error');

                                                    for($count = 1; $count <= $add_pics_count; $count++)
                                                      {

                                                        $index_tmp = $found_pics_index + 1 + $existed_pics_filepath_index + 1 + $count; // два раза по "+1" - для компенсации начальных значений индексов, которые в начале функции = -1.

                                                        // filepath
                                                        // если это первая картинка, то номер с тильдой ей не нужен
                                                        if($index_tmp == 1)
                                                          $found_pics_filepath[$found_pics_index + $count][0] = $file_directory_path . '/' . $image_name . ".jpg";
                                                        else
                                                          $found_pics_filepath[$found_pics_index + $count][0] = $file_directory_path . '/' . $image_name . '~' . $index_tmp . ".jpg";

                                                        $tmp = $found_pics_filepath[$found_pics_index + $count][0];
                                                        //drupal_set_message("+found_pics_filepath[found_pics_index + count][0] = $tmp", 'error');

                                                        // filename
                                                        // если это первая картинка, то номер с тильдой ей не нужен
                                                        if($index_tmp == 1)
                                                          $found_pics_filepath[$found_pics_index + $count][1] = $image_name . ".jpg";
                                                        else
                                                          $found_pics_filepath[$found_pics_index + $count][1] = $image_name . '~' . $index_tmp . ".jpg";
                                                      }


                                                   }



                                                 // найдём максимальную дельту, которая присутствует у данного продукта
                                                 // но делаем это только в том случае, если были какие-то картинки у текущего продукта
                                                 //drupal_set_message("****existed_pics_filepath_index = $existed_pics_filepath_index", 'error');
                                                 if($existed_pics_filepath_index >= 0)
                                                  {
                                                   $current_max_delta = -1;
                                                   $current_max_delta = db_result(db_query("SELECT delta FROM {content_field_image_cache} WHERE vid = '%s' ORDER BY delta DESC", $vid));
                                                   //drupal_set_message("current_max_delta = $current_max_delta, existed_pics_filepath_index = $existed_pics_filepath_index", 'error');
                                                   if($current_max_delta > $existed_pics_filepath_index)
                                                      $existed_pics_filepath_index = $current_max_delta;
                                                  }





                                                 // выведем все изначально имеющиеся картинки продукта

                                                 if($existed_pics_filepath_index >= 0)
                                                   {
                                                     drupal_set_message("!Own pictures of the product: ", 'error');

                                                     // выводим заголовок блока собственных картинок в файл
                                                     $r_t_f = $r_t_f . "Own pictures of the product: \n";
                                                   }

                                                 for($count = 0; $existed_pics_filepath_index >= $count; $count++)
                                                   {
                                                    $tmp = $existed_pics_filepath[$count][0];
                                                    $index = $count + 1;
                                                    drupal_set_message("$index: $tmp", 'error');

                                                    // выводим имена собственных картинок в файл
                                                	$r_t_f = $r_t_f . $tmp . "\n";

                                                   }




                                                 // выведем все скопированные из других продуктов с таким же названием или штрих-кодом

                                                 if($found_pics_index >= 0)
                                                   {
                                                    drupal_set_message("!Found pictures in other product with the same name: ", 'error');

                                                    // выводим имена найденных картинок в файл
                                                	$r_t_f = $r_t_f . "Found in other product with the same name: \n";
                                                   }

                                                 for($count = 0; $found_pics_index >= $count; $count++)
                                                   {
                                                    $tmp = $found_pics_filepath[$count][0];
                                                    $index = $count + 1;
                                                    drupal_set_message("$index: $tmp", 'error');

                                                	$r_t_f = $r_t_f . $tmp . "\n";
                                                   }



                                                 // выведем все созданные новые картинки для продукта (количество указано в файле в поле с картинками после *)

                                                 if($add_pics_count > 0)
                                                  {
                                                   drupal_set_message("!Created new pictures for the product: ", 'error');

                                                   // выводим имена новых картинок картинок в файл
                                                	$r_t_f = $r_t_f . "Created new pictures: \n";
                                                  }

                                                 for($count = $found_pics_index + 1; $count <= $found_pics_index + $add_pics_count; $count++)
                                                   {
                                                    $tmp = $found_pics_filepath[$count][0];
                                                    $index = $count + 1;
                                                    drupal_set_message("$index: $tmp", 'error');

                                                	$r_t_f = $r_t_f . $tmp . "\n";
                                                   }






                                                 // теперь занесём в базу найденные картинки в других продуктах с таким же названием и/или вновь созданные картинки
                                                 for($count = 0, $delta_new = $existed_pics_filepath_index + 1; $found_pics_index + $add_pics_count >= $count; $count++, $delta_new++)
                                                   {

                                                    $flag_new_pics = 1; // если эта переменная будет установлена, значит новые картинки были добавлены

                                                    $tmp = $found_pics_filepath[$count][0]; // [0] это filepath, [1] это filename



                                                    // вносим в базу найденные картинки
                                                    // начальный номер для первой из вводимых картинок будет (delta = existed_pics_filepath_index + 1)

                                                    // $files_fid максимальный номер файла в таблице files, полученный из таблицы sequenses
                                                    // должен обновиться в таблице sequenses после добавления файлов в базу

                                                    $new_files_fid = $files_fid + $count;
                                                    // добавляем файл в таблицу files
                                                    db_query("INSERT INTO {files} (fid, nid, filename, filepath, filemime) VALUES ('%s', '%s', '%s', '%s', '%s')", $new_files_fid, $nid, $found_pics_filepath[$count][1], $found_pics_filepath[$count][0], 'image/jpeg');

                                                    // добавляем файл в таблицу content_field_image_cache
                                                    db_query("INSERT INTO {content_field_image_cache } (vid, delta, nid, field_image_cache_fid) VALUES ('%s', '%s', '%s', '%s')", $vid, $delta_new, $nid, $new_files_fid);
                                                    //drupal_set_message(">>>>count = $count, new_files_fid = $new_files_fid, files_fid = $files_fid, found_pics_filepath[count][0] = $tmp", 'error');
                                                   }

                                                 // если были добавлены новые картинки, значит нужно изменить и $files_fid в таблице sequenses
                                                 if($flag_new_pics)
                                                  {
                                                    db_query("UPDATE {sequences} SET id = '%s' WHERE name = 'files_fid'", $new_files_fid);
                                                  }


                                                 break;  // конец варианта, когда в поле картинки стоит "?"








                                             case '*':
                                                // "*х" - добавляет "х" новых картинок (названий файлов по названию продукта) только в том случае, если в продукте не было картинок и во всей базе не найдено картинок у продуктов с таким же названием.
												// Если в продукте были картинки, то это поле пропускается.
												// Если в базе были картинки, то они все добавляются, новые картинки не создаются.


                                                // $name_file - имя продукта, взятое из файла и уже либо установленное для текущего продукта либо и продукт и так имел это имя
                                                // но на всякий случай (вдруг для продукта оставлено имя, которое у него было изначально, а имя из файла проигнорировано или его и не было там?) выясняем имя текущего продукта из базы
                                                $product_name = db_result(db_query("SELECT title FROM {node} WHERE nid = '%s' AND vid = '%s'", $nid, $vid));


                                                // определим штрих-код текущего продукта
                                                $current_product_bar = db_result(db_query("SELECT field_bar_value FROM {content_field_bar} WHERE vid = '%s'", $vid));

                                                // если после окончания проверки эта переменная будет больше или равна нулю
                                                // значит были найдены картинки для использования
                                                $found_pics_index = -1;

                                                // если после окончания цикла эта переменная будет больше или равна нулю
                                                // значит продукт изначально содержал картинки
                                                $existed_pics_filepath_index = -1;

                                                $existed_pics_filepath = array();


                                                // создаём массив, который содержит уже записанные в данном продукте fid'ы
                                                // затем будем накапливать новые fid из других продуктов с таким же названием только в том случае, если их и так уже нет в данном продукте
                                                // для этого каждый новый fid будем сравнивать с этим масивом (перебирая все его элементы) и добавлять в массив новых фидов только те, которых нет в этом массиве
                                                $existed_pics_fids_query = db_query("SELECT field_image_cache_fid, nid FROM {content_field_image_cache} WHERE vid = '%s'", $vid);
                                                $existed_pics_fid_query = db_fetch_object($existed_pics_fids_query);

                                                if($existed_pics_fid_query->nid > 0)
                                                  {

                                                     // создадим sql-строку, которая за один раз вытащит из таблицы  files все картинки текущего продукта
                                                     $sql_current_product_fids = "SELECT nid, filename, filepath FROM {files} WHERE nid = ";


                                                     // возьмём первое значение
                                                     $sql_current_product_fids = $sql_current_product_fids . $existed_pics_fid_query->nid;


                                                     // добавим все остальные ноды
                                                     while($existed_pics_fid_query = db_fetch_object($existed_pics_fids_query))
                                                        $sql_current_product_fids = $sql_current_product_fids . ' OR nid = ' . $existed_pics_fid_query->nid;


                                                     //drupal_set_message("00000******** sql_current_product_fids = $sql_current_product_fids", 'error');

                                                     $existed_pics_fids_query = db_query($sql_current_product_fids);



                                                     while($existed_pics_fid = db_fetch_object($existed_pics_fids_query))
                                                        {
                                                          $existed_pics_filepath_index++;
                                                          $existed_pics_filepath[$existed_pics_filepath_index][0] = $existed_pics_fid->filepath;
                                                          $existed_pics_filepath[$existed_pics_filepath_index][1] = $existed_pics_fid->filename;

                                                          //$tmp = $existed_pics_filepath[$existed_pics_filepath_index][0];
                                                          //drupal_set_message("!!!!!!!!existed_pics_filepath[existed_pics_filepath_index][0] = $tmp", 'error');
                                                        }


                                          	      } // конец проверки, есть ли вообще какие-то картинки у продукта (не пустая ли строка, возвращаемая на запрос о картинках для этого продукта)

                                          	    // теперь если переменная $existed_pics_filepath_index больше или равна нулю
                                          	    // то продукт содержит картинки и это значение показывает (количество присутствующих в продукте картинок - 1);
                                                // и может использоваться как delta (если больше или равно нулю, то это текущее максимальное значение delta.... например, delta = 0, значит у продукта одна картинка)



                                                // массив $found_pics_fids, который будет содержать fid новых картинок, которые мы найдём среди существующих в базе продуктов и скопируем в наш продукт
                                                $found_pics_filepath = array();

                                                // находим в базе все ноды (продукты) с таким же именем
                                                // ИЛИ с таким же штрих-кодом, как у данного продукта
                                                // (кроме самого текущего продукта) и с типом, как у текущего продукта
                                                // для поиска по названию рассматриваем только продукты аналогичного с данным типа, предполагая, что в продуктах другого типа нет нужных нам продуктов... Да и так мы существенно сокращаем время поиска

                                                // Определим тип продукта. Ранее этого не сделали, чтобы не обращаться к базе, так на предыдущих проверках продукт мог быть пропущен из-за отсутствия города, отдела и т.д...
                                                $product_type = db_result(db_query("SELECT type FROM {node} WHERE nid = '%s'", $nid));

                                                // тип продукта при поиске одинаковых штрих-кодов не оговаривается (так как невозможно за один запрос выяснить и штрих-коды и типы, а таблица со  штрих-кодами не содержит описания типа продуктов), но будем считать, что одинаковых штрих-кодов не может быть у продуктов разных типов!

                                                $is_similar_names = 0; // флаг наличия продуктов с таким же именем
                                                $is_similar_bars = 0;  // флаг наличия продуктов с таким же штрих-кодом


                                                $similar_name_nodes = db_query("SELECT nid, vid FROM {node} WHERE title = '%s' AND nid != '%s' AND type = '%s'", $product_name, $nid, $product_type);
                                                $similar_name_node_temp1 = db_fetch_object($similar_name_nodes);
                                                if(is_numeric($similar_name_node_temp1->nid))
                                                   $is_similar_names = 1;


                                                if($current_product_bar >= 0 AND $current_product_bar != '')
                                                 {
                                                   $similar_bar_nodes = db_query("SELECT nid, vid FROM {content_field_bar} WHERE field_bar_value = '%s' AND nid != '%s'", $current_product_bar, $nid);
                                                   $similar_name_node_temp2 = db_fetch_object($similar_bar_nodes);
                                                   if($similar_name_node_temp2->nid > 0)
                                                      $is_similar_bars = 1;
                                                 }

                                                //drupal_set_message(" ------is_similar_names =  $is_similar_names, is_similar_bars = $is_similar_bars,,,,, temp1_nid = $temp1_nid, temp2_nid = $temp2_nid ", 'error');

                                                if($is_similar_names OR $is_similar_bars)    // если есть продукты с таким же именем или с таким же штрихкодом
                                                 {

                                                   if($is_similar_names AND !$is_similar_bars) // если есть только ноды с таким же именем, но нет продуктов с таким же штрих-кодом
                                                     {
                                                       // создадим sql-строку, которая за один раз вытащит из таблицы  files все только что найденные продукты с таким же названием, как у текущего продукта, вместе с названиями файлов
                                                       $sql_similar_name_or_bar_fids = "SELECT nid, filename, filepath FROM {files} WHERE nid = ";

                                                       // возьмём первое значение
                                                       $sql_similar_name_or_bar_fids = $sql_similar_name_or_bar_fids . $similar_name_node_temp1->nid;

                                                        // выведем названия продуктов для найденных продуктов
                                                       drupal_set_message("!Naideny propucti s takim zhe nazvaniem $product_name:", 'error');
                                                       //$tmp1 = $similar_name_node_temp1->nid;
                                                       //$tmp1_count = 1;
                                                       //drupal_set_message("$tmp1_count: nid of product = $tmp1", 'error');


                                                       // добавим все остальные ноды
                                                       while($similar_name_node_temp1 = db_fetch_object($similar_name_nodes))
                                                        {
                                                          $sql_similar_name_or_bar_fids = $sql_similar_name_or_bar_fids . ' OR nid = ' . $similar_name_node_temp1->nid;

                                                          // выведем номера нодов для остальных найденных продуктов
                                                          //$tmp1 = $similar_name_node_temp1->title;
                                                          //$tmp1_count = $tmp1_count + 1;
                                                          //drupal_set_message("$tmp1_count: nid of product = $tmp1", 'error');
                                                        }
                                                       //drupal_set_message("====1 is Similar names ********sql_similar_name_or_bar_fids = $sql_similar_name_or_bar_fids", 'error');

                                                     }
                                                   if(!$is_similar_names AND $is_similar_bars)  // если есть только ноды с таким же штрих-кодом, но нет продуктов с таким же именем
                                                     {
                                                       // создадим sql-строку, которая за один раз вытащит из таблицы  files все только что найденные продукты c таким же штрих-кодом, как у текущего продукта, вместе с названиями файлов
                                                       $sql_similar_name_or_bar_fids = "SELECT nid, filename, filepath FROM {files} WHERE nid = ";

                                                       // возьмём первое значение
                                                       $sql_similar_name_or_bar_fids = $sql_similar_name_or_bar_fids . $similar_name_node_temp2->nid;

                                                        // выведем номера нодов для найденных продуктов
                                                       drupal_set_message("!Naideny propucti s takim zhe bar-codom $current_product_bar:", 'error');
                                                       //$tmp2 = $similar_name_node_temp2->nid;
                                                       //$tmp2_count = 1;
                                                       //drupal_set_message("$tmp2_count: nid of product = $tmp2", 'error');

                                                       // добавим все остальные ноды
                                                       while($similar_name_node_temp2 = db_fetch_object($similar_bar_nodes))
                                                         {
                                                          $sql_similar_name_or_bar_fids = $sql_similar_name_or_bar_fids . ' OR nid = ' . $similar_name_node_temp2->nid;

                                                          // выведем номера нодов для остальных найденных продуктов
                                                          //$tmp2 = $similar_name_node_temp2->nid;
                                                          //$tmp2_count = $tmp2_count + 1;
                                                          //drupal_set_message("$tmp2_count: nid of product = $tmp2", 'error');
                                                         }

                                                     }
                                                   if($is_similar_names AND $is_similar_bars)  // если есть продукты и с таким же именем, и с таим же штрих-кодом
                                                     {
                                                       // создадим sql-строку, которая за один раз вытащит из таблицы  files все только что найденные продукты, у которых названия или штрих-коды равны, вместе с названиями файлов
                                                       // стоит обратить внимание, что AND в данном случае не говорит о том, что у продуктов одновременно равны и названия и штрих-коды. Это говорит, что среди найденных продуктов есть продукты и с таким же названием, и с таким же штрих-кодом.
                                                       $sql_similar_name_or_bar_fids = "SELECT nid, filename, filepath FROM {files} WHERE nid = ";

                                                       // сначала добавим все продукты с таким же названием
                                                       // возьмём первое значение
                                                       $sql_similar_name_or_bar_fids = $sql_similar_name_or_bar_fids . $similar_name_node_temp1->nid;

                                                        // выведем номера нодов для найденных продуктов с таким же названием
                                                       drupal_set_message("!Naideny propucti s takim zhe nazvaniem $product_name:", 'error');
                                                       //$tmp1 = $similar_name_node_temp1->nid;
                                                       //$tmp1_count = 1;
                                                       //drupal_set_message("$tmp1_count: nid of product = $tmp1", 'error');

                                                       // добавим все остальные названия найденных нодов с таким же названием
                                                       while($similar_name_node_temp1 = db_fetch_object($similar_name_nodes))
                                                        {
                                                          $sql_similar_name_or_bar_fids = $sql_similar_name_or_bar_fids . ' OR nid = ' . $similar_name_node_temp1->nid;

                                                          // выведем номера нодов для остальных найденных продуктов с таким же названием
                                                          //$tmp1 = $similar_name_node_temp1->nid;
                                                          //$tmp1_count = $tmp1_count + 1;
                                                          //drupal_set_message("$tmp1_count: nid of product = $tmp1", 'error');
                                                        }


                                                       // теперь добавим сюда же продукты с таким же штрих-кодом
                                                       // первую проверку пропускаем, так как она сделана ранее (при инициализации флага $is_similar_bars)
                                                       $sql_similar_name_or_bar_fids = $sql_similar_name_or_bar_fids . ' OR nid = ' . $similar_name_node_temp2->nid;

                                                       // выведем номера нодов для найденных продуктов c таким же бар-кодом
                                                       drupal_set_message("!Naideny propucti s takim zhe bar-codom $current_product_bar:", 'error');
                                                       //$tmp2 = $similar_name_node_temp2->nid;
                                                       //$tmp2_count = 1;
                                                       //drupal_set_message("$tmp2_count: nid of product = $tmp2", 'error');


                                                       // добавим все остальные ноды с таким же бар-кодом
                                                       while($similar_name_node_temp2 = db_fetch_object($similar_bar_nodes))
                                                         {
                                                          $sql_similar_name_or_bar_fids = $sql_similar_name_or_bar_fids . ' OR nid = ' . $similar_name_node_temp2->nid;

                                                          // выведем номера нодов для остальных найденных продуктов с таким же бар-кодом
                                                          //$tmp2 = $similar_name_node_temp2->nid;
                                                          //$tmp2_count = $tmp2_count + 1;
                                                          //drupal_set_message("$tmp2_count: nid of product = $tmp2", 'error');
                                                         }


                                                       //drupal_set_message("====3 is Similar names and bars********sql_similar_name_or_bar_fids = $sql_similar_name_or_bar_fids", 'error');

                                                     }




                                                   $similar_name_or_bar_nodes = db_query($sql_similar_name_or_bar_fids);

                                                   // определим масив, который будет содержать штрих-коды для всех найденных продуктов
                                                   // чтобы для одинаковых нодов каждый раз не определять заново штрих-код, обращаясь к базе
                                                   $bar_codes = array();


                                                   for($count = 0; $similar_name_node = db_fetch_object($similar_name_or_bar_nodes); $count++)
                                          	    	{
                                            	     $similar_name_node_nid = $similar_name_node->nid;
                                            	     //$similar_name_node_vid = $similar_name_node->vid;
                                            	     //drupal_set_message("current_product_nid = $nid, similar_name_node_nid = $similar_name_node_nid, product_type = $product_type", 'error');

                                            	     // для каждого продукта проверим, не различаются ли штрихкоды данного (который вводом) продукта и рассматриваемого
                                            	     // для этого проверим, определены ли штрихкоды для обоих продуктов?

                                            	     // тут, конечно, лучше было бы использовать vid, но таблица files не имеет такого поля, поэтому используем nid.
                                            	     // при желании более точно подходить к вопросу, можно делать дополнительный запрос к базе (к таблице nodes), чтобы выяснить текущую vid

                                                     // но пока условимся, что штрих-коды равны для всех ревизий

                                                     if($bar_codes[$similar_name_node_nid][0])
                                                      {
                                                       $test_product_bar = $bar_codes[$similar_name_node_nid][1];
                                                      }
                                                     else
                                                      {
                                                       $test_product_bar = trim(db_result(db_query("SELECT field_bar_value FROM {content_field_bar} WHERE nid = '%s'", $similar_name_node->nid))); // на всякий случай убираем лишние пробелы
                                                       $bar_codes[$similar_name_node_nid][0] = 1; // флаг, что штрих-код для данной ноды найден
                                                      }

                                                     //drupal_set_message("count = $count, xxx-----test_product_bar = $test_product_bar, current_product_bar = $current_product_bar => similar_name_node_nid = $similar_name_node_nid", 'error');

                                            	     if(( ($test_product_bar > 0) AND ($current_product_bar > 0) ) AND ($test_product_bar != $current_product_bar))
                                            	      {
                                            	       //если оба штрих-кода определены, но не равны, значит это разные объекты и картинки брать нельзя
                                            	       // значит пропускаем этот продукт
                                                       drupal_set_message("test_product_bar = $test_product_bar (NEEEEEEEE Ravno!!!) current_product_bar = $current_product_bar => similar_name_node_nid = $similar_name_node_nid", 'error');
                                                       continue;
                                            	      }

                                                     //иначе или штрих-коды равны, или не определены для одного из значений, значит предполагаем, что продукты равны и картинки рассматриваемого продукта использовать можно
                                                     //drupal_set_message("test_product_bar = $test_product_bar (Ravno!!!) current_product_bar = $current_product_bar => similar_name_node_nid = $similar_name_node_nid", 'error');


                                                     // проверяем, нет ли уже у текущего продукта такой картинки?
                                                     for($in = 0; $in <= $existed_pics_filepath_index; $in++)
                                                        {
                                                          // если такой fid уже содержится в массиве, пропускаем этот fid
                                                          if($existed_pics_filepath[$in][0] == $similar_name_node->filepath)
                                                            {
                                                              //drupal_set_message("Sovpadenie #1: VNUTRI (with existed in this product pics)  na $similar_name_node->filepath, nid = $similar_name_node->nid", 'error');
                                                              continue (2);
                                                            }
                                                        }


                                                     // проверяем, нет ли уже среди внесённых в новый массив очередной проверяемой картинки?
                                                     for($in = 0; $in <= $found_pics_index; $in++)
                                                        {
                                                          // если такой fid уже содержится в массиве, пропускаем этот fid
                                                          if($found_pics_filepath[$in][0] == $similar_name_node->filepath)
                                                            {
                                                              //drupal_set_message("2) Sovpadenie #2: (s tol'ko chto naidennymi pics) na $similar_name_node->filepath, nid = $similar_name_node->nid, PROPUSKAEM!", 'error');
                                                              continue (2);
                                                            }
                                                        }


                                                      // если мы дошли до этого шага, значит такого fid в массиве нет
                                                      // и значит мы его добавляем
                                                      $found_pics_index++;
                                                      $found_pics_filepath[$found_pics_index][0] = $similar_name_node->filepath;
                                                      $found_pics_filepath[$found_pics_index][1] = $similar_name_node->filename;

                                                      //$tmp = $found_pics_filepath[$found_pics_index][0];
                                                      //$xxx = found_pics_index;
                                                      //drupal_set_message("found_pics_filepath[$xxx][0] = $tmp", 'error');

                                                    } // конец перебора нодов с таким же именем, как у текущего продукта, имебщих картинки

                                                 } // конец проверки, есть ли продукты таким же именем с картинками      if(($similar_name_nodes = db_query("SELECT nid, vid FROM {node} WHERE title = '%s' AND nid != '%s' AND type = '%s'", $product_name, $nid, $product_type)) > 0 )


















                                                 // теперь
                                                 // если переменная $existed_pics_filepath_index не равна нулю, то значит в продукте изначально были картинки
                                                 // если переменная $found_pics_index больше нуля, то картинки найдены

                                                 //drupal_set_message("!!existed_pics_filepath_index = $existed_pics_filepath_index+1", 'error');
                                                 //drupal_set_message("!!found_pics_index = $found_pics_index+1", 'error');

                                                 // если и продукт не содержал ни одной картинки, и не найдено в других продуктах с таким же названием картинок
                                                 // тогда добавим в продукт столько картинок (по названию продукта в транслитерации), сколько указано после * в поле с картинками в файле
                                                 if( !($existed_pics_filepath_index >= 0 OR $found_pics_index >= 0) )
                                                  {
													// если после знака вопроса стоял ещё и  "+",
                                                 	// до ещё добавляем в базу столько названий файлов, сколько указано после плюса
                                                 	$add_pics_count = 0;
                                                 	$add_pics_count = explode("*", $row['Kartinki']);
                                             	    $add_pics_count = $add_pics_count[1];

                                              	    if($add_pics_count <= 0)
                                              	       $add_pics_count = 1;

                                             	    for($count = 1; $count <= $add_pics_count; $count++)
                                             	      {
                                             	         $index_tmp = $found_pics_index + 1 + $existed_pics_filepath_index + 1 + $count; // два раза по "+1" - для компенсации начальных значений индексов, которые в начале функции = -1.

                                               	         // filepath
                                              	         // если это первая картинка, то номер с тильдой ей не нужен
                                         	             if($index_tmp == 1)
                                          	               $found_pics_filepath[$found_pics_index + $count][0] = $file_directory_path . '/' . $image_name . ".jpg";
                                           	   		     else
                                            	           $found_pics_filepath[$found_pics_index + $count][0] = $file_directory_path . '/' . $image_name . '~' . $index_tmp . ".jpg";

                                                         // если это первая картинка, то номер с тильдой ей не нужен
                                                         if($index_tmp == 1)
                                                           $found_pics_filepath[$found_pics_index + $count][1] = $image_name;
                                                         else
                                                           $found_pics_filepath[$found_pics_index + $count][1] = $image_name . '~' . $index_tmp;

                                                      } // end of for ... конец добавления новых картинок, если в продукте их не было и с других продуктов с таким же названием не скопировано

                                                  }  // end of if... конец проверки, были ли в продукте картинки или в других продуктах с таким же названием картинки



                                                 // найдём максимальную дельту, которая присутствует у данного продукта
                                                 // но делаем это только в том случае, если были какие-то картинки у текущего продукта
                                                 //drupal_set_message("****existed_pics_filepath_index = $existed_pics_filepath_index", 'error');
                                                 if($existed_pics_filepath_index >= 0)
                                                  {
                                                   $current_max_delta = -1;
                                                   $current_max_delta = db_result(db_query("SELECT delta FROM {content_field_image_cache} WHERE vid = '%s' ORDER BY delta DESC", $vid));
                                                   //drupal_set_message("current_max_delta = $current_max_delta, existed_pics_filepath_index = $existed_pics_filepath_index", 'error');
                                                   if($current_max_delta > $existed_pics_filepath_index)
                                                      $existed_pics_filepath_index = $current_max_delta;
                                                  }



                                                 // выведем все изначально имеющиеся картинки продукта
                                                 if($existed_pics_filepath_index >= 0)
                                                  {
                                                    drupal_set_message("!Own pictures of the product: ", 'error');

                                                    // выводим имена собственных картинок продукта в файл
                                                	$r_t_f = $r_t_f . "Own pictures: \n";
                                                  }

                                                 for($count = 0; $existed_pics_filepath_index >= $count; $count++)
                                                   {
                                                    $tmp = $existed_pics_filepath[$count][0];
                                                    $index = $count + 1;
                                                    drupal_set_message("$index: $tmp", 'error');

                                                	$r_t_f = $r_t_f . $tmp . "\n";
                                                   }



                                                 // выведем все скопированные из других продуктов с таким же названием или штрих-кодом

                                                 if($found_pics_index >= 0)
                                                   {
                                                     drupal_set_message("!Found pictures in other product with the same name: ", 'error');

                                                     // выводим имена найденных картинок в файл
                                                	$r_t_f = $r_t_f . "Foundin other product with the same name: \n";
                                                   }

                                                 for($count = 0; $found_pics_index >= $count; $count++)
                                                   {
                                                    $tmp = $found_pics_filepath[$count][0];
                                                    $index = $count + 1;
                                                    drupal_set_message("$index: $tmp", 'error');

                                                	$r_t_f = $r_t_f . $tmp . "\n";
                                                   }

                                                 // выведем все созданные новые картинки для продукта (количество указано в файле в поле с картинками после *)
                                                 // выводим только в том случае, если продукт не содержал сам картинок и ничего не найдено в других продуктах
                                                 if( ($add_pics_count > 0) AND ($found_pics_index < 0) AND ($existed_pics_filepath_index < 0) )
                                                  {

                                                    if( ($found_pics_index >= 0) OR ($existed_pics_filepath_index >= 0) )
                                                     $add_pics_count = 0;

                                                    drupal_set_message("!Created new pictures for the product: ", 'error');

                                                    // выводим имена новых картинок в файл
                                                	$r_t_f = $r_t_f . "Created new: \n";


                                                    for($count = $found_pics_index + 1; $count <= $found_pics_index + $add_pics_count; $count++)
                                                      {
                                                       $tmp = $found_pics_filepath[$count][0];
                                                       $index = $count + 1;
                                                       drupal_set_message("$index: $tmp", 'error');

                                                       // выводим имена новых картинок в файл
                                                       $r_t_f = $r_t_f . $tmp . "\n";
                                                      }

                                                  }


                                                 if( ($found_pics_index >= 0) OR ($existed_pics_filepath_index >= 0) )
                                                  $add_pics_count = 0;

                                                 // а теперь занесём в базу найденные картинки в других продуктах с таким же названием (если были найдены) или вновь созданные картинки
                                                 for($count = 0, $delta_new = $existed_pics_filepath_index + 1; $found_pics_index + $add_pics_count >= $count; $count++, $delta_new++)
                                                  {
                                                    $flag_new_pics = 1; // если эта переменная будет установлена, значит новые картинки были добавлены

                                                    $tmp = $found_pics_filepath[$count][0]; // [0] это filepath, [1] это filename

                                                    // вносим в базу найденные картинки
                                                    // начальный номер для первой из вводимых картинок будет (delta = existed_pics_filepath_index + 1)

                                                    // $files_fid максимальный номер файла в таблице files, полученный из таблицы sequenses
                                                    // должен обновиться в таблице sequenses после добавления файлов в базу

                                                    $new_files_fid = $files_fid + $count;
                                                    // добавляем файл в таблицу files
                                                    db_query("INSERT INTO {files} (fid, nid, filename, filepath, filemime) VALUES ('%s', '%s', '%s', '%s', '%s')", $new_files_fid, $nid, $found_pics_filepath[$count][1], $found_pics_filepath[$count][0], 'image/jpeg');

                                                    // добавляем файл в таблицу content_field_image_cache
                                                    db_query("INSERT INTO {content_field_image_cache } (vid, delta, nid, field_image_cache_fid) VALUES ('%s', '%s', '%s', '%s')", $vid, $delta_new, $nid, $new_files_fid);
                                                    //drupal_set_message(">>>>count = $count, new_files_fid = $new_files_fid, files_fid = $files_fid, found_pics_filepath[count][0] = $tmp", 'error');
                                                  }

                                                 // если были добавлены новые картинки, значит нужно изменить и $files_fid в таблице sequenses
                                                 if($flag_new_pics)
                                                  {
                                                    db_query("UPDATE {sequences} SET id = '%s' WHERE name = 'files_fid'", $new_files_fid);
                                                  }


                                                 break;  // конец варианта, когда в поле картинки стоит "*"


                                              default: // установка в качестве имени картинки строки из этого поля в файле





                                                break; // конец варианта с установки в качестве имени файла содержимого этого поля

             						    } // end of switch перебор вариантов первого символа поля с картинками (?, !...)



                                        // Окончание текста в ячейке с именами файлов картинок
                                        $r_t_f = $r_t_f . '"' . ";";



// ###########################################################
                              }      // end of ввод картинок, если определено поле Картинки
							else
							  {  // если не определено или пустое поле Картинки, то ничего не делаем

                                  //$tmp1 = $row['Artikul_postavki'];
                                  //$tmp2 = $row['Kartinki'];
                                  //drupal_set_message("*******Pole Kartinki NE opredeleno!!!!!!!", 'error');
                                  //drupal_set_message("************Artikul_postavki = $tmp1, Kartinki = $tmp2", 'error');

							  }










		            		//заменяем все остальные данные в каталоге данными из файла
                            //перебираем поля в файле и записываем в базу те, которые присутствуют в файле
                            //замену производим только в том случае, если в файле поле не пустое (одни пробелы считаются пустотой)
                            for($i = 0; isset($form_values['column_'.$i]); $i++)
                             if(!empty($form_values['column_'.$i])) // AND $row[$form_values['column_'.$i]] !='')  // ... we have map info for this column
              		   		  	switch($form_values['column_'.$i])
	        					{

                                 // параметры из файла (разные поля)



// изменяем основное (полное) описание продукта
                                 case 'Description':
                                       db_query("UPDATE {node_revisions} SET body = '%s' WHERE vid = '%s'", $row['Description'], $vid);
                                       break;



// свойства-категории (предопределённые свойства, по которым можно затем группировать товары)
		               			 case 'Svoistva':

		                       		  // если поле равно '' или '0' или 'skip'
		                       		  // ничего не делать с этим полем
                                      if( $row['Svoistva'] == '' OR $row['Svoistva'] == '0' OR $row['Svoistva'] == 'skip')
                                         break;

                                      //сначала удаляем из таблицы со свойствами (content_field_svoistva) все вхождения, относящиеся к данной ревизии (другие ревизии остаются неизменными)
                                      db_query("DELETE FROM {content_field_svoistva}  WHERE vid = '%s'", $vid);

                                      // теперь удалим из таблицы term_node все строки, у которых текущий номер ноды $nid и $tid принадлежит словарю со свойствами
                                      // для этого выясняем все $tid для словаря со свойствами (у этого словаря $vid = $svoistva_vid)
                                      $tids_for_svoistva = db_query("SELECT tid FROM {term_data} WHERE vid = '%s' ", $svoistva_vid);

                                      // теперь удаляем все строки с tid и nid  из term_data
                                      while($tid_for_svoistva = db_fetch_object($tids_for_svoistva))
                                         {
                                           db_query("DELETE FROM {term_node} WHERE nid = '%s' AND tid = '%s'", $nid, $tid_for_svoistva->tid);
                                         }


                                       //$tmp = $row['Svoistva'];
                                       //drupal_set_message("row['Svoistva'] = $tmp", 'error');
                                       $svoistva = explode(")", $row['Svoistva']);
                                       foreach($svoistva as $index => $svoistvo)
                                        {
                                         if(!$svoistvo) break;
                                         //drupal_set_message("svoistvo = $svoistvo, index = $index, svoistva[index] = $svoistva[index], svoistva = $svoistva", 'error');
                                         $svoistva_topic = explode("(", $svoistvo);
                                         foreach($svoistva_topic as $index_topic => $svoistvo_topic)
                                           {

                                            if(!$svoistvo_topic) break; //прервать, если нет данных

                                            if($index_topic == 0)
                                              {
                                                // это название раздела (Материал, Фасон и т.д)
                                                //drupal_set_message("Razdel: $svoistvo_topic", 'error');

                                                $topic = trim($svoistvo_topic); //удаляем лишние пробелы из начала строки
                                                //выясняем номер этой категории в таблице

                                                // сначала найдём все категории из словаря
                                                // кстати, номер словаря Свойства = $svoistva_vid - был определён вначале этой функции, где определяются основные переменные
                                                $tid_svoistvo_razdel = db_result(db_query("SELECT tid FROM {term_data} WHERE vid = '%s' AND name = '%s'", $svoistva_vid, $topic));

                                               // если нет такого раздела (категории) в базе или эта категория имеет родителя (parent != 0), то значит ошибочная категория или новая и её нужно создать (если пользователь это указал на первом экране)
                                               if(!($tid_svoistvo_razdel > 0) OR (db_result(db_query("SELECT parent FROM {term_hierarchy} WHERE tid = '%s'", $tid_svoistvo_razdel))) != '0')
                                                 {
                                                      //если пользователь указал на первом экране создавать новый раздел для свойств
                                                      if($form_values['Create_New_Svoistvo_Razdel'])
                                                        {
                                                           // если да, то создаём новый раздел в таблице term_data в словаре свойств
                                                           db_query("INSERT INTO {term_data} (vid, name, description) VALUES ('%s', '%s', '')", $svoistva_vid, $topic);
                                                           //его tid создаётся автоматически, поэтому после создания выясняем его и присваиваем нашей рабочей переменной,
                                                           $tid_svoistvo_razdel = db_result(db_query("SELECT tid FROM {term_data} WHERE vid = '%s' AND name = '%s'", $svoistva_vid, $topic));
                                                           // прописываем раздел в таблице иерархии термов для того, чтобы этот раздел являлся корневым разделом (родителем для свойств). Если этого не сделать, раздел (и впоследствии его свойства) не появится в списке термов (категорий)
                                                           db_query("INSERT INTO {term_hierarchy} (tid, parent) VALUES ('%s', '0')", $tid_svoistvo_razdel);
                                                           // теперь также необходимо обновить переменную, содержащую максимальный номер tid таблицы term_data в таблице sequences
                                                           db_query("UPDATE {sequences} SET id = '%s' WHERE name = 'term_data_tid'", $tid_svoistvo_razdel);
                                                           // вообщаем о том, что ввели в базу новый раздел для свойств
                                                           drupal_set_message("VVVnimanie! V baze sozdan new razdel dlia svoistv = $topic (User set a creation of new razdel for svoistva if it's not exist)!", 'error');
                                                           // и дальше продолжаем, как будто бы атрибут изначально присутствовал в базе
                                                           //break;
                                                        }
                                                       else
                                                        {
                                                           // если пользователь не указывал вводить новый раздел для свойств, значит пропускаем этот раздел вместе с его свойствами
                                                           drupal_set_message("VVVnimanie! V baze v svoistvah net takogo razdela = $topic. Etot razdel propuskaetsia!", 'error');
                                                           continue (2); //прерываем цикл обработки этого раздела
                                                        }

                                                 }





                                                //while($tid_svoistvo = db_fetch_object($tids_svoistva))
                                                //$tid_svoistvo = db_fetch_object($tids_svoistva);
                                              /*   {
                                                   $tmp = $tid_svoistvo->tid;
                                                   $tmp2 = $tid_svoistvo->name;
                                                   drupal_set_message("tid = $tmp, name = $tmp2", 'error');

                                                 }
                                              */

                                                //drupal_set_message("tids_svoistva = $tids_svoistva", 'error');


                                                continue;
                                              }
                                             else
                                              {
                                                ; //drupal_set_message("Harakteristiki:", 'error');
                                              }


                                             // уберём из строки все лишние '~', которые могли быть ошибочно повтороно введены (в конце, в середине, двойные ~~)
         									 $svoistvo_topic = trim($svoistvo_topic, "~");
         									 $svoistvo_topic = str_replace("~~", "~", $svoistvo_topic);

                                             $svoistva_topic_feature = explode("~", $svoistvo_topic);
                                             foreach($svoistva_topic_feature as $index_topic_feature => $svoistvo_topic_feature)
                                              {

                                               //убираем лишние пробелы и из этих данных
                                               $svoistvo_topic_feature = trim($svoistvo_topic_feature);

                                               // это отдельные характеристики, которые теперь нужно внести в базу
                                               //drupal_set_message("$svoistvo_topic_feature", 'error');
                                               //вводим характеристики в таблицу content_field_svoistva
                                               // родитель для каждого свойства - найденный только что раздел $topic в этой таблице
                                               // и только что мы нашли его еомер tid в таблице term_data. Это $tid_svoistvo_razdel

                                               //выясняем номера tid всех свойств, у которых родитель текущий раздел $tid_svoistvo_razdel
                                               //ведь их обычно несколько
                                               $tids_svoistva = db_query("SELECT tid FROM {term_hierarchy} WHERE parent = '%s' ", $tid_svoistvo_razdel);

                                               // теперь находим среди них tid с текущим свойством
                                               $tid_svoistvo = 0; // обнуляем переменную
                                               while($tid_svoistva = db_fetch_object($tids_svoistva))
                                                 {

                                                   $tmp = db_result(db_query("SELECT name FROM {term_data} WHERE tid = '%s' ", $tid_svoistva->tid));
                                                   if($svoistvo_topic_feature == $tmp)
                                                    {
                                                     $tid_svoistvo = $tid_svoistva->tid;
                                                     break;
                                                    }
                                                 }


                                               // если в базе нет такого свойства в базе, что делать?
                                               if(!($tid_svoistvo > 0))
                                                 {

                                                   //если пользователь указал на первом экране создавать новыое свойство для этого раздела
                                                   if($form_values['Create_New_Svoistvo_Svoistvo'])
                                                     {
                                                        // если да, то создаём новое свойство для текущего раздела в таблице term_data в словаре свойств
                                                        db_query("INSERT INTO {term_data} (vid, name, description) VALUES ('%s', '%s', '')", $svoistva_vid, $svoistvo_topic_feature);
                                                        //его tid создаётся автоматически, поэтому после создания выясняем его и присваиваем нашей рабочей переменной,
                                                        $tid_svoistvo = db_result(db_query("SELECT tid FROM {term_data} WHERE vid = '%s' AND name = '%s'", $svoistva_vid, $svoistvo_topic_feature));
                                                        // связываем свойство с разделом в таблице иерархии термов
                                                        db_query("INSERT INTO {term_hierarchy} (tid, parent) VALUES ('%s', '%s')", $tid_svoistvo, $tid_svoistvo_razdel);
                                                        // теперь также необходимо обновить переменную, содержащую максимальный номер tid таблицы term_data в таблице sequences
                                                        db_query("UPDATE {sequences} SET id = '%s' WHERE name = 'term_data_tid'", $tid_svoistvo);
                                                        // вообщаем о том, что ввели в базу новое свойство для текущего раздела для свойств
                                                        drupal_set_message("VVVnimanie! V baze sozdano new svoistvo $svoistvo_topic_feature dlia razdela $topic (User set a creation of new svoistvo dlia razdela if it's not exist)!", 'error');
                                                        // и дальше продолжаем, как будто бы атрибут изначально присутствовал в базе
                                                     }
                                                   else
                                                     {
                                                       // если пользователь не указал создавать новое свойство в базе, выводим сообщение И пропускаем его
                                                       drupal_set_message("VVVnimanie! V baze net takogo svoistva = $svoistvo_topic_feature dlia razdela $topic. Eto svoistvo propuskaetsia!", 'error');
                                                       continue;
                                                     }


                                                 }

                                            /*
                                               //а если принять, что у нас не повторяются названия свойств в разных разделах, то можно найти tid текущего свойство одной строкой
                                               // кстати, номер словаря Свойства = $svoistva_vid - был определён вначале этой функции, где определяются основные переменные

                                               $tid_svoistvo = db_result(db_query("SELECT tid FROM {term_data} WHERE vid = '%s' AND name = '%s'", $svoistva_vid, $svoistvo_topic_feature));
                                               if(!($tid_svoistvo > 0))
                                                 {
                                                   // если в базе нет такого свойства, пропускаем его и выводим сообщение
                                                   drupal_set_message("Vnimanie! V baze net takogo svoistva = $svoistvo_topic_feature. Eto svoistvo propuskaetsia!", 'error');
                                                   continue;
                                                 }
                                             */

                                               // печатаем на экране текущее свойство
                                               //drupal_set_message("svoistvo_topic_feature = $svoistvo_topic_feature, tid = $tid_svoistvo", 'error');

                                               //добавляем свойство в таблицу content_field_svoistva к текущему продукту
                                               db_query("INSERT INTO {content_field_svoistva} (nid, vid, delta, field_svoistva_tid) VALUES (%s, %s, %s, %s)", $nid, $vid, $tid_svoistvo, $tid_svoistvo);



                                               // если в свойствах в таблице node_field для поля field_svoistva установлена опция "сохранять свойства как категории"
                                               // добавляем такие же категории в таблицу term_node, чтобы они стали и ссылками (именно по ним потом можно будет группировать однотипные продукты)
                                               // $content_field_add_category определяется один раз вначале функции, где и остальные переменные
                                               if($content_field_add_category)
                                                  {
                                                    db_query("INSERT INTO {term_node} (nid, tid) VALUES (%s, %s)", $nid, $tid_svoistvo);

                                                  }

                                               // обнуляем кэш, иначе данные на сайте не обновятся
                                               // обнулим его единожды в конце функии!
                                               //db_query("TRUNCATE TABLE {cache_content}");


                                              } // end of foreach($svoistva_topic_feature as $index_topic_feature...
                                           } //end of foreach($svoistva_topic as $index_topic...
                                        } //end of foreach($svoistva as $index...

                                        break; // конец блока с  изменением свойств продукта




// меняем атрибуты, которые может выбирать пользователь для этого продукта (размер, цвет и т.д.)
                                  case 'Atributy':



									   // если поле равно '' или '0' или 'skip'
		          					   // ничего не делать с этим полем
                                       if( $row['Atributy'] == '' OR $row['Atributy'] == '0' OR $row['Atributy'] == 'skip')
                                         break;



                                       // сначала удаляем все старые атрибуты
                                       // для этого...

                                       // ...удаляем все ссылки на картинки для опций
                                       // Для этого нужно удалить все вхождения в таблице files с nid = "номер ноды. Номер атрибута . Номер опции"
                                       // (нужно перебрать все атрибуты и ноды для данного продукта)
                                       {
                                         //выясняем все атрибуты (их номера), которые имеет данный продукт
                                         $node_attributes = db_query("SELECT aid FROM {uc_product_attributes} WHERE nid = '%s' ", $nid);

                                         // для каждого найденного атрибута у этого продукта...
                                         while($node_attribute = db_fetch_object($node_attributes))
                                           {
                                             //...находим все опции
                                             $attribute_options = db_query("SELECT oid FROM {uc_attribute_options} WHERE aid = '%s' ", $node_attribute->aid);
                                             // и затем для каждой опции удаляем информацию о картинке для этой опции
                                             // из таблицы files
                                             // есть ли там картинка, проверять не будем, так как времени займёт столько же, сколько и просто удаление
                                             // поэтому просто задаём команду удаления, и если есть ссылка на картинку в таблице files для этой опции есть, она удалится
                                             while($attribute_option = db_fetch_object($attribute_options))
                                               {
                                                db_query("DELETE FROM {files}  WHERE nid = '%s'", $nid.$node_attribute->aid.$attribute_option->oid);
                                               }
                                           }
                                       } // конец удаления ссылок на картинки для опций конкретного продукта


                                       // затем удаляем из таблицы с атрибутами (uc_product_attributes ) все вхождения, относящиеся к данной ноде
                                       // (получается, что изменения касаются всех ревизий)
                                       db_query("DELETE FROM {uc_product_attributes}  WHERE nid = '%s'", $nid);
                                       // и удаляем из таблицы с опциями для данного продукта (uc_product_options) также все вхождения, относящиеся к данной ноде
                                       db_query("DELETE FROM {uc_product_options}  WHERE nid = '%s'", $nid);








                                       // а теперь добавляем новые атрибуты и опции из файла

                                       $atributy = explode(")", $row['Atributy']);
                                       foreach($atributy as $index => $attrs_and_opts)
                                        {
                                         if(!$attrs_and_opts) break;
                                         //drupal_set_message("attrs_and_optso = $attrs_and_opts, index = $index, attrs_and_opts svoistva[index] = $$attrs_or_opts svoistva[index], attrs_or_opts = $attrs_and_opts", 'error');
                                         $attrs = explode("(", $attrs_and_opts);
                                         foreach($attrs as $index_attr => $attr)
                                           {
                                            if(!$attr) break; //прервать, если нет больше данных
                                            if($index_attr == 0)
                                              {
                                                // это название атрибута (Размер, Цвет и т.д)
                                                //drupal_set_message("Attribute: $attr", 'error');

                                                $attr = trim($attr); //удаляем лишние пробелы из начала строки
                                                $current_attr = $attr;
                                                //выясняем номер этого атрибута  в таблице uc_attributes
                                                $aid_attr = db_result(db_query("SELECT aid FROM {uc_attributes} WHERE name = '%s'", $attr));

//#####################################################################
                                                // если нет такого атрибута в базе, то значит ошибочный или новый атрибут,
                                                // что делать?
                                                if(!($aid_attr > 0))
                                                  {
                                                      // пользователь на первом экране указал создавать новые атрибуты?
                                                      if($form_values['Create_New_Attribute'])
                                                        {
                                                           // если да, то создаём новый артрибут в таблице uc_attributes
                                                           db_query("INSERT INTO {uc_attributes} (name, display) VALUES ('%s', '1')", $attr);
                                                           //его aid создаётся автоматически, поэтому после создания выясняем его и присваиваем нашей рабочей переменной,
                                                           $aid_attr = db_result(db_query("SELECT aid FROM {uc_attributes} WHERE name = '%s'", $attr));
                                                           drupal_set_message("VVVnimanie! V baze sozdan new attribut = $current_attr (User set a creation of new attribut if it's not exist)!", 'error');
                                                           // и дальше продолжаем, как будто бы атрибут изначально присутствовал в базе
                                                           //break;
                                                        }
                                                      else
                                                        {  // если такого атрибута нет в базе и пользователь на первом экране не указал создавать новые атрибуты,
                                                           // то пропускаем этот атрибут (вместе с его опциями)
                                                      	   drupal_set_message("VVVnimanie! V baze net takogo atributa = $current_attr. Etot atribut propuskaetsia (vmeste s ego options)!", 'error');
                                                           //break (2); //прерываем цикл обработки этого атрибута
                                                           continue (2);
                                                        }
                                                  }

                                                // заносим в таблицу uc_product_attributes инфо о новом атрибуте
                                                db_query("INSERT INTO {uc_product_attributes} (nid, aid, display) VALUES (%s, %s, %s)", $nid, $aid_attr, '1');
                                                // ещё осталось задать option по умолчанию, но эта опция станет известна только на следующей итерации
                                                // так что её добавим позже
                                                continue;
                                              }   // end of обработки, если это атрибут (а не опция атрибута)
                                             else
                                              {
                                              	//drupal_set_message("Options:", 'error');

                                                // уберём из строки все лишние '~', которые могли быть ошибочно повтороно введены (в конце, в середине, двойные ~~)
         									    $attr = trim($attr, "~");
         									    $attr = str_replace("~~", "~", $attr);


                                             	$options = explode("~", $attr);
                                             	foreach($options as $index_options => $option)
                                             	 {

                                             	  //убираем лишние пробелы и из этих данных
                                             	  $option = trim($option);

                                             	  // это отдельные опции, которые теперь нужно внести в базу
                                             	  // drupal_set_message("$option", 'error');
                                             	  // вводим опции в таблицу uc_product_options

                                             	  //выясняем номер oid опции
                                             	  $oid_option = db_result(db_query("SELECT oid FROM {uc_attribute_options} WHERE aid = '%s' AND name = '%s'", $aid_attr, $option));

                                                  // что делаеть, если в базе нет такой опции у данного атрибута?
                                              	  if(!($oid_option > 0))
                                              	   {
                                                      // пользователь на первом экране указал создавать новые свойства для атрибутов?
                                                      if($form_values['Create_New_Attribute_Options'])
                                                        {
                                                           // если да, то создаём новый артрибут в таблице uc_attributes
                                                           db_query("INSERT INTO {uc_attribute_options} (aid, name) VALUES ('%s', '%s')",  $aid_attr, $option);
                                                           //его oid создаётся автоматически, поэтому после создания выясняем его и присваиваем нашей рабочей переменной,
                                                           $oid_option = db_result(db_query("SELECT oid FROM {uc_attribute_options} WHERE name = '%s'", $option));
                                                           drupal_set_message("VVVnimanie! V baze sozdan new option = $option dlia attributa $current_attr (User set a creation of new options if it's not exist)!", 'error');
                                                           // и дальше продолжаем, как будто бы это свойство этого атрибута изначально присутствовало в базе
                                                           //break;
                                                        }
                                                      else
                                                        {
                                                           // если такого свойства у данного атрибута нет в базе и пользователь на первом экране не указал создавать новые свойства для атрибутов
                                                           // то пропускаем это свойство атрибута
                                                      	   drupal_set_message("VVVnimanie! V baze net takogo option = $option u attributa $attr. Etot option propuskaetsia!", 'error');
                                                           continue; //прерываем цикл обработки этого свойства атрибута
                                                        }

                                                   }


                                               	  // печатаем на экране текущию опцию
                                                  //drupal_set_message("Option = $option, oid = $oid_option", 'error');

                                                  //добавляем опцию в таблицу uc_product_options  к текущему продукту
                                               	  // тут можно было бы ещё и цену и прочие характеристики внести, когда придумаю, как их обозначать в файле
                                               	  db_query("INSERT INTO {uc_product_options } (nid, oid) VALUES ('%s', '%s')", $nid, $oid_option);

                                               	  // первую опцию в списке устанавливаем опцией по умолчанию для текущего атрибута этого продукта
                                                  if($index_options == 0)
                                                 	db_query("UPDATE {uc_product_attributes} SET default_option = '%s' WHERE nid = %s AND aid = %s", $oid_option, $nid, $aid_attr);


                                                  // тут ещё можно было бы указать и картинку для текущей опции
                                                  // когда придумаю, как обрабатывать картинки

                                                 }  // end of обработки (перебора) свойств атрибута foreach($options as $index_options...

                                              }  // end of else обработки, если это свойство атрибута (а не сам атрибут)

                                           } //end of foreach...

                                        } //end of foreach...


                                       break; // конец блока с  изменением атрибутов продукта









                                   default:

                                       break;




             					} //  end of switch перебор полей из файла (описание, вес, цена и прочее...)



                            break; // конец блока для case UC_IMPORTER_REPLACE:


		          } // end of switch перебор вариантов обработки дубликатов



	           } //if($sovpadenie == 1)  // конец проверки, есть ли в базе продукты с указанным Artikul
	         else // иначе совпадения нет, значит продукт новый
               {


//##########################################################################




































//##########################################################################
//##########################################################################



// если нет совпадения, то мы имеем новый продукт и вводим его в базу


                	$tmp = $row['Name'];
                    drupal_set_message("Creating product $tmp...", 'error');

                	//для начала берём следующий свободный в базе номер nid и vid

              		$nid = db_result(db_query("SELECT id FROM {sequences} WHERE name = 'node_nid'")) + 1;
		      		$vid = db_result(db_query("SELECT id FROM {sequences} WHERE name = 'node_revisions_vid'")) + 1;


                    // определим тип продукта
                    // если он не указан в файле, берём тип указанный пользователем на первой странице
                    switch(trim($row['Type']))
                      {
                      	case cp1251_to_utf8_recursive('Вещи'):
                      	      $row['Type'] = 'productpanties'; // сюда необходимо будет подставить правильный тип, когда будет понятна общая класификация (вещи, продукты, книги и пр...)
                      	      break;

                        default:
                        	  $row['Type'] = $form_values['class'];

                        	  $tmp = $form_values['class'];
                        	  drupal_set_message("Type for product #$row_count is not set in file. Use from 1st screen user choice: $tmp", 'error');
                        	  break;
                      }


                    // к этому моменту у нас точно определены в файле поля 'Gorod', 'Magazin', 'Otdel', 'Magazin', 'Artikul_postavki', 'Name'
                    // причём такие город, магазин и отдел существуют
                    // сразу введём эти значения в базу



                    // обновим переменные, содержащие последние значения nid, vid
                    db_query("UPDATE {sequences} SET id = '%s' WHERE name = 'node_nid'", $nid);
                    db_query("UPDATE {sequences} SET id = '%s' WHERE name = 'node_revisions_vid'", $vid);
                    //db_query("INSERT IGNORE INTO {sequences} (name, id) VALUES ('node_nid', '%s')", $nid);

                    //$user->uid
                    db_query("INSERT INTO {node} (nid, vid, type, title, uid, status, created, changed, comment, promote, moderate, sticky) VALUES ('%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s')", $nid, $vid, $row['Type'], $row['Name'], $user->uid, '1', time(), time(), '0', '0', '0', '0');

                    // есть сокращённое, а есть полное описание
                    // пока считаем, что описание одинаково для обоих вариантов

                    // если описание определено, вносим его и остальные необходимые данные в таблицу node_revisions
                    // если же не определено, то вносим только остальные необходимые данные
                    // делаем по условию, чтобы не обращаться к базе дважды (или трижды, если впоследствии будем разделять полное и сокращённое описание)
                    if(!$row['Description'])
                      db_query("INSERT INTO {node_revisions} (nid, vid, title, uid, timestamp, format) VALUES ('%s', '%s', '%s', '%s', '%s', '%s')", $nid, $vid, $row['Name'], $user->uid, time(), '1');
                    else
                      db_query("INSERT INTO {node_revisions} (nid, vid, title, uid, body, teaser, timestamp, format) VALUES ('%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s')", $nid, $vid, $row['Name'], $user->uid, $row['Description'], $row['Description'], time(), '1');

                    // введём данные по комментариям (нулевые, но они должны быть введены в базу по кажной ноде)
                    db_query("INSERT INTO {node_comment_statistics} (nid, last_comment_timestamp, last_comment_name, last_comment_uid, comment_count) VALUES ('%s', '%s', '%s', '%s', '%s')", $nid, time(), 'NULL', $user->uid, '0');



                    //Artikul_postavki

                    // вводим в базу ранее определённый артикул zp. Раньше его не могли ввести в базу, так как был не известен vid. Теперь vid определён.
                    db_query("INSERT INTO {content_field_artikul_zp} (nid, vid, field_artikul_zp_value) VALUES ('%s', '%s', '%s')", $nid, $vid, $artikul_zp);
                    // так как у нас артикул zp является основным артикулом базы (уникальным номером продукта по всей базе), он же является и SKU
                    // поэтому вводим артикул zp также и в базу, а именно в таблицу продуктов как артикул SKU

					// стараемся ввести максимальное количество полей в таблицу продуктов за одно обращение к базе
                    // для этого определяем несколько вариантов ввода, в зависимости от того, сколько полей определено
                    // если будет больше полей для ввода/изменения в таблицу uc_products, то вариантов ввода (ниже) будет больше

                    // если определены и не пустые поля 'Weight' и 'Sell_price'
                    if($row['Weight'] > 0 AND $row['Weight'] != '' AND $row['Sell_price'] > 0 AND $row['Sell_price'] != '')
                       {
                         db_query("INSERT INTO {uc_products} (nid, vid, model, sell_price, weight, weight_units, length_units, pkg_qty, default_qty, ordering, shippable) VALUES ('%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s',  '%s', '%s', '%s')", $nid, $vid, $artikul_zp, $row['Sell_price'], $row['Weight'], 'kg', 'mm', '1', '1', '0', '1');
                       }
                    // если определены и не пустые поля 'Weight'
                    else if($row['Weight'] > 0 AND  $row['Weight'] != '')
                       {
                         db_query("INSERT INTO {uc_products} (nid, vid, model, sell_price, weight, weight_units, length_units, pkg_qty, default_qty, ordering, shippable) VALUES ('%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s',  '%s', '%s', '%s')", $nid, $vid, $artikul_zp, '0', $row['Weight'], 'kg', 'mm', '1', '1', '0', '1');
                       }
                    // если определены и не пустые поля 'Sell_price'
                    else if($row['Sell_price'] > 0 AND $row['Sell_price'] != '')
                       {
                         db_query("INSERT INTO {uc_products} (nid, vid, model, sell_price, weight, weight_units, length_units, pkg_qty, default_qty, ordering, shippable) VALUES ('%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s',  '%s', '%s', '%s')", $nid, $vid, $artikul_zp, $row['Sell_price'], '0', 'kg', 'mm', '1', '1', '0', '1');
                       }
                    else
                       {
                       	 db_query("INSERT INTO {uc_products} (nid, vid, model, sell_price, weight, weight_units, length_units, pkg_qty, default_qty, ordering, shippable) VALUES ('%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s',  '%s', '%s', '%s')", $nid, $vid, $artikul_zp, '0', '0', 'kg', 'mm', '1', '1', '0', '1');
                       }


                    //  не будем вносить термы города и магазина, чтобы  продукт не засвечивался при наведении на город или магазин, а только показывался при лоступе в конкретный подотдел

                    /*
                    // введём все термы местоположения товара: город, магазин
                    db_query("INSERT INTO {term_node} (nid, tid) VALUES ('%s', '%s')", $nid, $tid_gorod);
                    db_query("INSERT INTO {term_node} (nid, tid) VALUES ('%s', '%s')", $nid, $tid_magazin);
                    */


                    // чтобы добавить к ноде терм только самого глубокого отдела
                    db_query("INSERT INTO {term_node} (nid, tid) VALUES ('%s', '%s')", $nid, $tid_otdels[$otdels_index-1]);

                    // чтобы добавить к ноде все термы отделов, в которых он содержится по иерархии.
                    // если все добавить, то продукт становится виден во всех надотделах, а это неправильно.
                    /*
                    while($otdels_index--)
                     {
                       db_query("INSERT INTO {term_node} (nid, tid) VALUES ('%s', '%s')", $nid, $tid_otdels[$otdels_index]);

					   // тестовый вывод инфы
					   //$tmp = $tid_otdels[$otdels_index];
                       //$tmp2 = $otdels[$otdels_index];
                       //drupal_set_message("otdels_index = $otdels_index, tid_otdels[otdels_index] = $tmp, otdels[otdels_index] = $tmp2", 'error');
                     }
                      */







                     // добавим к этой ноде все термы отделов, в которых он содержится по иерархии - сохраняем полную иерархию по термам каталога для данной ноды
                     // в отдельно, специально созданную таблицу, которая затем будет использоваться для выбора upsell-продуктов.

                     // если в этой таблице уже были данные по этой ноде, сначала удаляем их


 $flag = 0; // 0 - ничего не делать, 1 - записать, 2 - перезаписать (стереть и записать), 3 - стереть


 $sql_results = db_query("SELECT tid FROM {term_node_lineage} WHERE nid = '%s'", arg(1));
 if($sql_results > 0) // если в базе что-то есть по этой ноде, проверим, совпадают ли данные. Если совпадают, ничего не делаем, если не совпадают, всё стираем по этой ноде и записываем по-новой
  {
     for($count_bd = 0; $sql_result = db_fetch_object($sql_results); $count_bd++)
      {
       $hss_bd[$count_bd] = $sql_result->nid; // заполняем массив термов из базы для этой ноды
                                            // заодно подсчитываем, сколько термов для этой ноды в базе ($count_bd)

       $flag = 2;
       foreach($tid_otdels as $count => $tid)
        if($sql_result->nid == $tid)
          $flag = 0;

       if($flag == 2)
        break;
      }

     if($count != ($count_bd - 1))
       $flag = 2;

  }
 else // значит в базе нет ничего
  {
       $flag = 1;
  }

 switch($flag)
  {
   case 1:
     foreach($tid_otdels as $tid)
      {
        db_query("INSERT INTO {term_node_lineage} (nid, tid) VALUES (%d, %d)", $nid, $tid);
      }
     break;

   case 2:
     db_query("DELETE FROM {term_node_lineage} WHERE nid = '%s'", arg(1));
     foreach($tid_otdels as $tid)
      {
        db_query("INSERT INTO {term_node_lineage} (nid, tid) VALUES (%d, %d)", $nid, $tid);
      }
     break;

    case 3:
     db_query("DELETE FROM {term_node_lineage} WHERE nid = '%s'", $nid);
     break;

    case 0:
     break;
  }


















                    // начинаем выводить данные по этому продукту в файл. НАчнём с Номера, Действия, Имени и Артикула поставки
                    $r_t_f = $r_t_f . "\n" . $row_count . ".;" . $row['Name'] . ';' . $row['Artikul_postavki'] . ';';


                     // выведем в файл производителя, если он указан
	         	 	if($row['Proizvoditel'] AND  $row['Proizvoditel'] != '')
                        $r_t_f = $r_t_f . $row['Proizvoditel'] . ';';
                    else
                        $r_t_f = $r_t_f . ';';




                    // внесём артикул поставки в базу и выведем в файл, если он не пустой
	         	 	if($row['Artikul_postavki'] AND  $row['Artikul_postavki'] != '')
                      {
                      	db_query("INSERT INTO {content_field_artikul_postavki} (nid, vid, field_artikul_postavki_value) VALUES ('%s', '%s', '%s')", $nid, $vid, $row['Artikul_postavki']);
                        $r_t_f = $r_t_f . $row['Artikul_postavki'];
                      }
                    $r_t_f = $r_t_f . ';';


                    // внесём артикул производителя в базу и выведем в файл, если он не пустой
	         	 	if($row['Artikul_proizv'] AND  $row['Artikul_proizv'] != '')
                      {
                      	db_query("INSERT INTO {content_field_artikul_proizv} (nid, vid, field_artikul_proizv_value) VALUES ('%s', '%s', '%s')", $nid, $vid, $row['Artikul_proizv']);
                        $r_t_f = $r_t_f . $row['Artikul_proizv'];
                      }
                    $r_t_f = $r_t_f . ';';

                    // внесём штрих-код в базу, если он не пустой
	         	 	if($row['Bar'] AND  $row['Bar'] != '')
	                  {
	                  	db_query("INSERT INTO {content_field_bar} (nid, vid, field_bar_value) VALUES ('%s', '%s', '%s')", $nid, $vid, $row['Bar']);
	                    $r_t_f = $r_t_f . $row['Bar'];
	                  }
                    $r_t_f = $r_t_f . ';';

                    // выведем в файл город и магазин
                    $r_t_f = $r_t_f . $row['Gorod'] . '->' . $row['Magazin'];

                    // выведем в файл отдел(ы)
                    $count_otdels = 0;
                    while($otdels[$count_otdels])
                     {
                       $r_t_f = $r_t_f . '->' . $otdels[$count_otdels++];
                     }
                    $r_t_f = $r_t_f . ';';

                    // выведем артикул $artikul_zp в файл (артикул формируется чуть ранее в этой же функции, воспользуйтесь поиском для нахождения по файлу)
                    $r_t_f = $r_t_f . $artikul_zp . ';';


                    //drupal_set_message("r_t_f = $r_t_f", 'error');

                    $r_t_f = $r_t_f . 'Created... ; ;';

                    // выведем в файл sell_price, если он указан
	         	 	if($row['Sell_price'] AND  $row['Sell_price'] != '')
                        $r_t_f = $r_t_f . $row['Sell_price'] . ';';
                   	else
                        $r_t_f = $r_t_f . ';';

                    // введём в базу и выведем в файл количество продукта, если оно указано
	         	 	if($row['Kol-vo'] AND  $row['Kol-vo'] != '')
                      {
                        // введём данные в базу
                        db_query("UPDATE {uc_product_stock} SET sku = '%s', active = '%s', stock = '%s', threshold = '%s' WHERE nid = '%s'", $artikul_zp, '1', $row['Kol-vo'], '0', $nid);
                        // и выведем его в файл
                        $r_t_f = $r_t_f . $row['Kol-vo'] . ';';
                      }
                   	else
                       	$r_t_f = $r_t_f . ';';












// если определено поле с картинками, вводим в базу картинки для продукта



                    if($row['Kartinki'] AND  $row['Kartinki'] != '')
                     {
// ##########################################
                       //$tmp1 = $row['Artikul_postavki'];
                       //$tmp2 = $row['Kartinki'];
                       //drupal_set_message("--------------Pole Kartinki opredeleno!!!!!!!", 'error');
                       //drupal_set_message("--------------Artikul_postavki = $tmp1, Kartinki = $tmp2", 'error');

// вводим в базу картинки для продукта

                                       switch($form_values['pictures_handling'])
                                        {
                                          case 'Skip': // если в общих настройках на первом экране сказано пропускать картинки, то пропускаем это поле

                                             //drupal_set_message("Zadan GLOBALNYI propusk obrabotki kartinok. Pole s kartinkami propuskaetsjia!", 'error');
                                             break (2);

                                          case 'UseAllPicsOrAddOne': // если найдены картинки (и добавлены в этот продукт) в других продуктах с таким же названием или штрих-кодом
                                                                     // то не создавать новых картинок
                                                                     // иначе создать одну новую картинку

                                           $row['Kartinki'] = '*'; // считаем, как будто во всех продуктах это поле содержит *
                                             break;

                                          case 'AddOneNewIfNoSelfPicsBefore': // если продукт не содержал уже своих картинок, то добавляяется одна картинка
                                                                              // поиск картинок по другим продуктам НЕ производится

                                             $row['Kartinki'] = '!?'; // считаем, как будто во всех продуктах это поле содержит !?
                                             break;


                                          case 'Fromfile':
                                          default:
                                             // во всех остальных случаях берутся инструкции из файла
                                             break;
				        				}



                                       // если поле равно '' или '0' или 'skip'
 				       				   // ничего не делать с этим полем
                                       if( $row['Kartinki'] == '' OR $row['Kartinki'] == '0' OR $row['Kartinki'] == 'skip')
                                         break;






                                       // Подготовим вывод в файл картинок в несколько строк в одной ячейке
                                       // начало текста в ячейке с именами файлов картинок


                                       $r_t_f = $r_t_f . '"';

                                       //$r_t_f = $r_t_f . "1111111" . "\n";
                                       //$r_t_f = $r_t_f . "22222222222" . "\n";

                                       //$r_t_f = $r_t_f . '"';



                                       // начальная инициализация данных

                                       // берём для имени файла имя продукта, делаем все маленькие буквы
                                       // удаляем из него все лишние символы и преобразауем в транслит
				       		           $image_name = strtolower(preg_replace($pattern, $separator, strtr($row['Name'], $translations)));
				       		           //drupal_set_message("1. image_name = $image_name", 'error');
                                       // определяем следующий за последним номер fid в таблице files
                                       $files_fid = 1+ db_result(db_query("SELECT id FROM {sequences} WHERE name = 'files_fid'"));

                                       //каталог для картинок $file_directory_path определяется единожды в начале функции


                                       $delta = 0;

                                       // если в общих настройках на первом экране сказано добавлять картинки пропускать картинки
                                       // пропускаем



                                       // в зависимости от содержимого поля "Kartinki" выполняем различные действия
                                       switch($row['Kartinki'][0])
                                        {
                                          case '!': // установка новых картинок на основе имени продукта
                                                    // количество добавляемых картинок определяется числом, следующим за "!"

                                                // добавляем картинки к текущей ноде и текущей ревизии

                                                // если в файле после "!" (или "!?") указано число "х", это значит,
                                                // что необходимо добавить "х" картинок, что и делаем
                                                // для каждой последующей картинки к имени файла добавляем "~х", начиная с 2. (~2, ~3 и т.д...)
                                                // если оно больше 1, то значит необходимо добавить ещё указанное число - 1 (так как уже одну добавили) картинок

                                                // определим это число
                                                if($row['Kartinki'][1] == '?') // если второй символ (за !) в поле ?, то числом вставляемых картинок будет третяя позиция (это может быть и двухзначное число)
                                                  {
                                                  	$add_pics_count = explode("?", $row['Kartinki']);
                                                    $add_pics_count = $add_pics_count[1];
                                                    //если там не число, а какая-нибудь другая чепуха, то считаем, что там 0.
                                                    drupal_set_message("add_pics_count if ? = $add_pics_count", 'error');
                                                    if(!is_numeric($add_pics_count))
                                                      $add_pics_count = 1;
                                                    //drupal_set_message("add_pics_count if ? = $add_pics_count", 'error');
                                                  }
                                                else   // иначе число вставляемых картинок - это число за ! (это может быть и двухзначное число)
                                                  {
                                                  	$add_pics_count = explode("!", $row['Kartinki']);
                                                    $add_pics_count = $add_pics_count[1];
                                                    //если там не число, а какая-нибудь другая чепуха, то считаем, что там 0.
                                                    drupal_set_message("add_pics_count = $add_pics_count", 'error');
                                                    if(!is_numeric($add_pics_count))
                                                      $add_pics_count = 1;
                                                    //drupal_set_message("add_pics_count if NUM = $add_pics_count", 'error');
                                                  }



                                                db_query("INSERT INTO {files} (fid, nid, filename, filepath, filemime) VALUES ('%s', '%s', '%s', '%s', '%s')", $files_fid, $nid, $image_name.'.jpg', $file_directory_path . '/' . $image_name . '.jpg', 'image/jpeg');

                                             	// выведем название первого добавленного файла, если у продукта ещё не было картинок
                                                $pics_name = $file_directory_path . '/' . $image_name . '.jpg';
                                                $index_pics = 1;
                                                drupal_set_message("K productu dobavleny kartinki:", 'error');
                                                drupal_set_message("$index_pics: $pics_name", 'error');

                                                // выводим имена картинок в файл
                                                $r_t_f = $r_t_f . "K productu dobavleny kartinki: \n";
                                                $r_t_f = $r_t_f . $pics_name . "\n";

                                                // увеличиваем системный счётчик файлов в таблице sequences
                                                db_query("UPDATE {sequences} SET id = %s WHERE name = 'files_fid'", $files_fid);


                                                // добавляем запись в content_field_image_cache

                                                // записываем ссылку на картинку в таблицу content_field_image_cache с найденной нодой
                                                // и со ссылкой на только что введенную картинку в таблице files
                                                db_query("INSERT INTO {content_field_image_cache} (vid, delta, nid, field_image_cache_fid) VALUES ('%s', '%s', '%s', '%s')", $vid, $delta, $nid, $files_fid);







                                                if($add_pics_count > 1)
                                                 {

                                                  $row['Kartinki'][1] = $row['Kartinki'][1] + $delta;
                                                  while($delta < $row['Kartinki'][1] - 1 )
                                                   {
                                                     $delta++;

                                                     $files_fid++;
                                                     $counter = $delta + 1; // чтобы нумерация картинок продолжалась не с ~1, а с ~2

                                                     // добавляем картинки к текущей ноде и текущей ревизии
                                                     db_query("INSERT INTO {files} (fid, nid, filename, filepath, filemime) VALUES ('%s', '%s', '%s', '%s', '%s')", $files_fid, $nid, $image_name . '~' . $counter . '.jpg', $file_directory_path . '/' . $image_name . '~' . $counter . '.jpg', 'image/jpeg');
                                                     // увеличиваем системный счётчик файлов в таблице sequences
                                                     db_query("UPDATE {sequences} SET id = %s WHERE name = 'files_fid'", $files_fid);

                                                     // записываем ссылку на картинку в таблицу content_field_image_cache с найденной нодой
                                                     // и со ссылкой на только что введенную картинку в таблице files
                                                     db_query("INSERT INTO {content_field_image_cache} (vid, delta, nid, field_image_cache_fid) VALUES ('%s', '%s', '%s', '%s')", $vid, $delta, $nid, $files_fid);

                                                     // выводим по очереди остальные названия картинок, добавленные к продукту
                                                     $pics_name = $file_directory_path . '/' . $image_name . '~' . $counter . '.jpg';
                                                	 $index_pics = $index_pics + 1;
                                                     drupal_set_message("$index_pics: $pics_name", 'error');

                                                     // выводим то же название файла в файл
                                                     $r_t_f = $r_t_f . $pics_name . "\n";
                                                   }

                                                 }



                                                // нужно очистить кеш (cache_content), чтобы данные на сайте обновились
                                                // сделаем это один раз в конце функции


                                                break; // end of case '!':




                                             case '?':
                                                // поиск уже существующих в базе картинок и установка дополнительно новых на основе имени продукта
                                                // "?+х" (или "?-х") - поиск продуктов с таким же названием и копирование всех картинок в этот продукт.
                                                // Как вариант, может также пытаться искать продукты с таким же штрих-кодом или артикулом производителя; Если задано "+х", то к найденным прибавит ещё "х" новых и поставит их в конец списка (в каталоге будут отображаться сначала найденные, а потом вновь созданные). Если задано "-х", то вновь созданные поставятся в начало списка и будут отображаться в каталоге первыми.
                                                // Если ничего не найдено, то будет создано "х" картинок.

                                                $product_name = $row['Name'];


                                                // определим штрих-код текущего продукта
                                                $current_product_bar = $row['Bar'];

                                                // если после окончания проверки эта переменная будет больше или равна нулю
                                                // значит были найдены картинки для использования
                                                $found_pics_index = -1;

                                                // вводится новый продукт, значит изначально содникаких картинок в нём нет
                                                $existed_pics_filepath_index = -1;


                                                // массив $found_pics_fids, который будет содержать fid новых картинок, которые мы найдём среди существующих в базе продуктов и скопируем в наш продукт
                                                $found_pics_filepath = array();

                                                // находим в базе все ноды (продукты) с таким же именем
                                                // ИЛИ с таким же штрих-кодом, как у данного продукта
                                                // (кроме самого текущего продукта) и с типом, как у текущего продукта
                                                // для поиска по названию рассматриваем только продукты аналогичного с данным типа, предполагая, что в продуктах другого типа нет нужных нам продуктов... Да и так мы существенно сокращаем время поиска

                                                // Тип продукта
                                                $product_type = $row['Type'];

                                                // тип продукта при поиске одинаковых штрих-кодов не оговаривается (так как невозможно за один запрос выяснить и штрих-коды и типы, а таблица со  штрих-кодами не содержит описания типа продуктов), но будем считать, что одинаковых штрих-кодов не может быть у продуктов разных типов!

                                                $is_similar_names = 0; // флаг наличия продуктов с таким же именем
                                                $is_similar_bars = 0;  // флаг наличия продуктов с таким же штрих-кодом


                                                $similar_name_nodes = db_query("SELECT nid, vid, title FROM {node} WHERE title = '%s' AND nid != '%s' AND type = '%s'", $product_name, $nid, $product_type);
                                                $similar_name_node_temp1 = db_fetch_object($similar_name_nodes);
                                                if(is_numeric($similar_name_node_temp1->nid))
                                                   $is_similar_names = 1;

                                                if($current_product_bar >= 0 AND $current_product_bar != '')
                                                 {
                                                  $similar_bar_nodes = db_query("SELECT nid, vid FROM {content_field_bar} WHERE field_bar_value = '%s' AND nid != '%s'", $current_product_bar, $nid);
                                                  $similar_name_node_temp2 = db_fetch_object($similar_bar_nodes);
                                                  if($similar_name_node_temp2->nid > 0)
                                                     $is_similar_bars = 1;
                                                 }

                                                //drupal_set_message(" ------is_similar_names =  $is_similar_names, is_similar_bars = $is_similar_bars,,,,, temp1_nid = $temp1_nid, temp2_nid = $temp2_nid ", 'error');

                                                if($is_similar_names OR $is_similar_bars)    // если есть продукты с таким же именем или с таким же штрихкодом
                                                 {

                                                   if($is_similar_names AND !$is_similar_bars) // если есть только ноды с таким же именем, но нет продуктов с таким же штрих-кодом
                                                     {
                                                       // создадим sql-строку, которая за один раз вытащит из таблицы  files все только что найденные продукты с таким же названием, как у текущего продукта, вместе с названиями файлов
                                                       $sql_similar_name_or_bar_fids = "SELECT nid, filename, filepath FROM {files} WHERE nid = ";

                                                       // возьмём первое значение
                                                       $sql_similar_name_or_bar_fids = $sql_similar_name_or_bar_fids . $similar_name_node_temp1->nid;

                                                        // выведем названия продуктов для найденных продуктов
                                                       drupal_set_message("!Naideny propucti s takim zhe nazvaniem $product_name:", 'error');
                                                       //$tmp1 = $similar_name_node_temp1->nid;
                                                       //$tmp1_count = 1;
                                                       //drupal_set_message("$tmp1_count: nid of product = $tmp1", 'error');


                                                       // добавим все остальные ноды
                                                       while($similar_name_node_temp1 = db_fetch_object($similar_name_nodes))
                                                        {
                                                          $sql_similar_name_or_bar_fids = $sql_similar_name_or_bar_fids . ' OR nid = ' . $similar_name_node_temp1->nid;

                                                          // выведем номера нодов для остальных найденных продуктов
                                                          //$tmp1 = $similar_name_node_temp1->title;
                                                          //$tmp1_count = $tmp1_count + 1;
                                                          //drupal_set_message("$tmp1_count: nid of product = $tmp1", 'error');
                                                        }
                                                       //drupal_set_message("====1 is Similar names ********sql_similar_name_or_bar_fids = $sql_similar_name_or_bar_fids", 'error');

                                                     }
                                                   if(!$is_similar_names AND $is_similar_bars)  // если есть только ноды с таким же штрих-кодом, но нет продуктов с таким же именем
                                                     {
                                                       // создадим sql-строку, которая за один раз вытащит из таблицы  files все только что найденные продукты c таким же штрих-кодом, как у текущего продукта, вместе с названиями файлов
                                                       $sql_similar_name_or_bar_fids = "SELECT nid, filename, filepath FROM {files} WHERE nid = ";

                                                       // возьмём первое значение
                                                       $sql_similar_name_or_bar_fids = $sql_similar_name_or_bar_fids . $similar_name_node_temp2->nid;

                                                        // выведем номера нодов для найденных продуктов
                                                       drupal_set_message("!Naideny propucti s takim zhe bar-codom $current_product_bar:", 'error');
                                                       //$tmp2 = $similar_name_node_temp2->nid;
                                                       //$tmp2_count = 1;
                                                       //drupal_set_message("$tmp2_count: nid of product = $tmp2", 'error');

                                                       // добавим все остальные ноды
                                                       while($similar_name_node_temp2 = db_fetch_object($similar_bar_nodes))
                                                         {
                                                          $sql_similar_name_or_bar_fids = $sql_similar_name_or_bar_fids . ' OR nid = ' . $similar_name_node_temp2->nid;

                                                          // выведем номера нодов для остальных найденных продуктов
                                                          //$tmp2 = $similar_name_node_temp2->nid;
                                                          //$tmp2_count = $tmp2_count + 1;
                                                          //drupal_set_message("$tmp2_count: nid of product = $tmp2", 'error');
                                                         }

                                                     }
                                                   if($is_similar_names AND $is_similar_bars)  // если есть продукты и с таким же именем, и с таим же штрих-кодом
                                                     {
                                                       // создадим sql-строку, которая за один раз вытащит из таблицы  files все только что найденные продукты, у которых названия или штрих-коды равны, вместе с названиями файлов
                                                       // стоит обратить внимание, что AND в данном случае не говорит о том, что у продуктов одновременно равны и названия и штрих-коды. Это говорит, что среди найденных продуктов есть продукты и с таким же названием, и с таким же штрих-кодом.
                                                       $sql_similar_name_or_bar_fids = "SELECT nid, filename, filepath FROM {files} WHERE nid = ";

                                                       // сначала добавим все продукты с таким же названием
                                                       // возьмём первое значение
                                                       $sql_similar_name_or_bar_fids = $sql_similar_name_or_bar_fids . $similar_name_node_temp1->nid;

                                                        // выведем номера нодов для найденных продуктов с таким же названием
                                                       drupal_set_message("!Naideny propucti s takim zhe nazvaniem $product_name:", 'error');
                                                       //$tmp1 = $similar_name_node_temp1->nid;
                                                       //$tmp1_count = 1;
                                                       //drupal_set_message("$tmp1_count: nid of product = $tmp1", 'error');

                                                       // добавим все остальные названия найденных нодов с таким же названием
                                                       while($similar_name_node_temp1 = db_fetch_object($similar_name_nodes))
                                                        {
                                                          $sql_similar_name_or_bar_fids = $sql_similar_name_or_bar_fids . ' OR nid = ' . $similar_name_node_temp1->nid;

                                                          // выведем номера нодов для остальных найденных продуктов с таким же названием
                                                          //$tmp1 = $similar_name_node_temp1->nid;
                                                          //$tmp1_count = $tmp1_count + 1;
                                                          //drupal_set_message("$tmp1_count: nid of product = $tmp1", 'error');
                                                        }


                                                       // теперь добавим сюда же продукты с таким же штрих-кодом
                                                       // первую проверку пропускаем, так как она сделана ранее (при инициализации флага $is_similar_bars)
                                                       $sql_similar_name_or_bar_fids = $sql_similar_name_or_bar_fids . ' OR nid = ' . $similar_name_node_temp2->nid;

                                                       // выведем номера нодов для найденных продуктов c таким же бар-кодом
                                                       drupal_set_message("!Naideny propucti s takim zhe bar-codom $current_product_bar:", 'error');
                                                       //$tmp2 = $similar_name_node_temp2->nid;
                                                       //$tmp2_count = 1;
                                                       //drupal_set_message("$tmp2_count: nid of product = $tmp2", 'error');


                                                       // добавим все остальные ноды с таким же бар-кодом
                                                       while($similar_name_node_temp2 = db_fetch_object($similar_bar_nodes))
                                                         {
                                                          $sql_similar_name_or_bar_fids = $sql_similar_name_or_bar_fids . ' OR nid = ' . $similar_name_node_temp2->nid;

                                                          // выведем номера нодов для остальных найденных продуктов с таким же бар-кодом
                                                          //$tmp2 = $similar_name_node_temp2->nid;
                                                          //$tmp2_count = $tmp2_count + 1;
                                                          //drupal_set_message("$tmp2_count: nid of product = $tmp2", 'error');
                                                         }


                                                       //drupal_set_message("====3 is Similar names and bars********sql_similar_name_or_bar_fids = $sql_similar_name_or_bar_fids", 'error');

                                                     }



                                                   $similar_name_or_bar_nodes = db_query($sql_similar_name_or_bar_fids);

                                                   // определим масив, который будет содержать штрих-коды для всех найденных продуктов
                                                   // чтобы для одинаковых нодов каждый раз не определять заново штрих-код, обращаясь к базе
                                                   $bar_codes = array();


                                                   for($count = 0; $similar_name_node = db_fetch_object($similar_name_or_bar_nodes); $count++)
                                          	    	{
                                            	     $similar_name_node_nid = $similar_name_node->nid;
                                            	     //$similar_name_node_vid = $similar_name_node->vid;
                                            	     //drupal_set_message("current_product_nid = $nid, similar_name_node_nid = $similar_name_node_nid, product_type = $product_type", 'error');

                                            	     // для каждого продукта проверим, не различаются ли штрихкоды данного (который вводом) продукта и рассматриваемого
                                            	     // для этого проверим, определены ли штрихкоды для обоих продуктов?

                                            	     // тут, конечно, лучше было бы использовать vid, но таблица files не имеет такого поля, поэтому используем nid.
                                            	     // при желании более точно подходить к вопросу, можно делать дополнительный запрос к базе (к таблице nodes), чтобы выяснить текущую vid

                                                     // но пока условимся, что штрих-коды равны для всех ревизий

                                                     if($bar_codes[$similar_name_node_nid][0])
                                                      {
                                                       $test_product_bar = $bar_codes[$similar_name_node_nid][1];
                                                      }
                                                     else
                                                      {
                                                       $test_product_bar = trim(db_result(db_query("SELECT field_bar_value FROM {content_field_bar} WHERE nid = '%s'", $similar_name_node->nid))); // на всякий случай убираем лишние пробелы
                                                       $bar_codes[$similar_name_node_nid][0] = 1; // флаг, что штрих-код для данной ноды найден
                                                      }

                                                     //drupal_set_message("count = $count, xxx-----test_product_bar = $test_product_bar, current_product_bar = $current_product_bar => similar_name_node_nid = $similar_name_node_nid", 'error');

                                            	     if(( ($test_product_bar > 0) AND ($current_product_bar > 0) ) AND ($test_product_bar != $current_product_bar))
                                            	      {
                                            	       //если оба штрих-кода определены, но не равны, значит это разные объекты и картинки брать нельзя
                                            	       // значит пропускаем этот продукт
                                                       //drupal_set_message("test_product_bar = $test_product_bar (NEEEEEEEE Ravno!!!) current_product_bar = $current_product_bar => similar_name_node_nid = $similar_name_node_nid", 'error');
                                                       continue;
                                            	      }

                                                     //иначе или штрих-коды равны, или не определены для одного из значений, значит предполагаем, что продукты равны и картинки рассматриваемого продукта использовать можно
                                                     //drupal_set_message("test_product_bar = $test_product_bar (Ravno!!!) current_product_bar = $current_product_bar => similar_name_node_nid = $similar_name_node_nid", 'error');



                                                     // проверяем, нет ли уже среди внесённых в новый массив очередной проверяемой картинки?
                                                     for($in = 0; $in <= $found_pics_index; $in++)
                                                        {
                                                          // если такой fid уже содержится в массиве, пропускаем этот fid
                                                          if($found_pics_filepath[$in][0] == $similar_name_node->filepath)
                                                            {
                                                              //drupal_set_message("2) Sovpadenie #2: (s tol'ko chto naidennymi pics) na $similar_name_node->filepath, nid = $similar_name_node->nid, PROPUSKAEM!", 'error');
                                                              continue (2);
                                                            }
                                                        }


                                                      // если мы дошли до этого шага, значит такого fid в массиве нет
                                                      // и значит мы его добавляем
                                                      $found_pics_index++;
                                                      $found_pics_filepath[$found_pics_index][0] = $similar_name_node->filepath;
                                                      $found_pics_filepath[$found_pics_index][1] = $similar_name_node->filename;

                                                      //$tmp = $found_pics_filepath[$found_pics_index][0];
                                                      //$xxx = found_pics_index;
                                                      //drupal_set_message("found_pics_filepath[$xxx][0] = $tmp", 'error');

                                                    } // конец перебора нодов с таким же именем, как у текущего продукта, имебщих картинки

                                                 } // конец проверки, есть ли продукты таким же именем с картинками      if(($similar_name_nodes = db_query("SELECT nid, vid FROM {node} WHERE title = '%s' AND nid != '%s' AND type = '%s'", $product_name, $nid, $product_type)) > 0 )












                                                 // теперь
                                                 // если переменная $found_pics_index больше нуля, то картинки найдены


                                                 // если после знака вопроса стоял ещё и  "+",
                                                 // до ещё добавляем в базу столько названий файлов, сколько указано после плюса
                                                 $add_pics_count = 0;
                                                 if($row['Kartinki'][1] == '+')
                                                   {
                                                    $add_pics_count = explode("+", $row['Kartinki']);
                                                    $add_pics_count = $add_pics_count[1];
                                                    //drupal_set_message("-------add_pics_count = $add_pics_count", 'error');
                                                    //drupal_set_message("found_pics_index = $found_pics_index, existed_pics_filepath_index = $existed_pics_filepath_index", 'error');

                                                    for($count = 1; $count <= $add_pics_count; $count++)
                                                      {

                                                        $index_tmp = $found_pics_index + 1 + $count; // "+1" - для компенсации начального значения индекса, который в начале функции = -1.

                                                        // filepath
                                                        // если это первая картинка, то номер с тильдой ей не нужен
                                                        if($index_tmp == 1)
                                                          $found_pics_filepath[$found_pics_index + $count][0] = $file_directory_path . '/' . $image_name  . ".jpg";
                                                        else
                                                          $found_pics_filepath[$found_pics_index + $count][0] = $file_directory_path . '/' . $image_name . '~' . $index_tmp  . ".jpg";

                                                        //$tmp = $found_pics_filepath[$found_pics_index + $count][0];
                                                        //drupal_set_message("+found_pics_filepath[found_pics_index + count][0] = $tmp", 'error');

                                                        // filename
                                                        // если это первая картинка, то номер с тильдой ей не нужен
                                                        if($index_tmp == 1)
                                                          $found_pics_filepath[$found_pics_index + $count][1] = $image_name;
                                                        else
                                                          $found_pics_filepath[$found_pics_index + $count][1] = $image_name . '~' . $index_tmp;
                                                      }


                                                   }



                                                 // выведем все скопированные из других продуктов с таким же названием или штрих-кодом

                                                 if($found_pics_index >= 0)
                                                   drupal_set_message("!Found pictures in other product with the same name: ", 'error');

                                                 for($count = 0; $found_pics_index >= $count; $count++)
                                                   {
                                                    $tmp = $found_pics_filepath[$count][0];
                                                    $index = $count + 1;
                                                    drupal_set_message("$index: $tmp", 'error');
                                                   }

                                                 // выведем все созданные новые картинки для продукта (количество указано в файле в поле с картинками после *)

                                                 //if(($found_pics_index + $add_pics_count) >= 0)
                                                 if($add_pics_count > 0)
                                                   drupal_set_message("!Created new pictures for the product: ", 'error');

                                                 for($count = $found_pics_index + 1; $count <= $found_pics_index + $add_pics_count; $count++)
                                                   {
                                                    $tmp = $found_pics_filepath[$count][0];
                                                    $index = $count + 1;
                                                    drupal_set_message("$index: $tmp", 'error');
                                                   }






                                                 // теперь занесём в базу найденные картинки в других продуктах с таким же названием и/или вновь созданные картинки
                                                 for($count = 0, $delta_new = 0; $found_pics_index + $add_pics_count >= $count; $count++, $delta_new++)
                                                   {

                                                    $flag_new_pics = 1; // если эта переменная будет установлена, значит новые картинки были добавлены

                                                    $tmp = $found_pics_filepath[$count][0]; // [0] это filepath, [1] это filename



                                                    // вносим в базу найденные картинки
                                                    // начальный номер для первой из вводимых картинок будет ($delta_new = existed_pics_filepath_index + 1 = 0)

                                                    // $files_fid максимальный номер файла в таблице files, полученный из таблицы sequenses
                                                    // должен обновиться в таблице sequenses после добавления файлов в базу

                                                    $new_files_fid = $files_fid + $count;
                                                    // добавляем файл в таблицу files
                                                    db_query("INSERT INTO {files} (fid, nid, filename, filepath, filemime) VALUES ('%s', '%s', '%s', '%s', '%s')", $new_files_fid, $nid, $found_pics_filepath[$count][1], $found_pics_filepath[$count][0], 'image/jpeg');

                                                    // добавляем файл в таблицу content_field_image_cache
                                                    db_query("INSERT INTO {content_field_image_cache } (vid, delta, nid, field_image_cache_fid) VALUES ('%s', '%s', '%s', '%s')", $vid, $delta_new, $nid, $new_files_fid);
                                                    //drupal_set_message(">>>>count = $count, new_files_fid = $new_files_fid, files_fid = $files_fid, found_pics_filepath[count][0] = $tmp", 'error');




                                                    // выведем то же самое в ячейку Kartinki в файле с соответствубщими пометками
                                                    if($found_pics_index >= 0 AND $count == 0)
                                                       $r_t_f = $r_t_f . "Found in other products:"	. "\n";

                                                    if($add_pics_count > 0 AND ($count == ($found_pics_index + 1)) )
                                                     	$r_t_f = $r_t_f . "Created new pictures:"	. "\n";

                                                    $r_t_f = $r_t_f . $found_pics_filepath[$count][1] . "\n";

                                                   }

                                                 // если были добавлены новые картинки, значит нужно изменить и $files_fid в таблице sequenses
                                                 if($flag_new_pics)
                                                  {
                                                    db_query("UPDATE {sequences} SET id = '%s' WHERE name = 'files_fid'", $new_files_fid);
                                                  }


                                                 break;  // конец варианта, когда в поле картинки стоит "?"








                                             case '*':
                                                // "*х" - добавляет "х" новых картинок (названий файлов по названию продукта) только в том случае, если в продукте не было картинок и во всей базе не найдено картинок у продуктов с таким же названием.
												// Если в продукте были картинки, то это поле пропускается.
												// Если в базе были картинки, то они все добавляются, новые картинки не создаются.


                                                $product_name = $row['Name'];


                                                // штрих-код продукта
                                                $current_product_bar = $row['Bar'];

                                                // если после окончания проверки эта переменная будет больше или равна нулю
                                                // значит были найдены картинки для использования
                                                $found_pics_index = -1;

                                                // продукт изначально содержал картинки, значит после окончания цикла эта переменная не изменится
                                                $existed_pics_filepath_index = -1;

                                                $existed_pics_filepath = array();




                                                // массив $found_pics_fids, который будет содержать fid новых картинок, которые мы найдём среди существующих в базе продуктов и скопируем в наш продукт
                                                $found_pics_filepath = array();

                                                // находим в базе все ноды (продукты) с таким же именем
                                                // ИЛИ с таким же штрих-кодом, как у данного продукта
                                                // (кроме самого текущего продукта) и с типом, как у текущего продукта
                                                // для поиска по названию рассматриваем только продукты аналогичного с данным типа, предполагая, что в продуктах другого типа нет нужных нам продуктов... Да и так мы существенно сокращаем время поиска

                                                // Определим тип продукта. Ранее этого не сделали, чтобы не обращаться к базе, так на предыдущих проверках продукт мог быть пропущен из-за отсутствия города, отдела и т.д...
                                                $product_type = $row['Type'];

                                                // тип продукта при поиске одинаковых штрих-кодов не оговаривается (так как невозможно за один запрос выяснить и штрих-коды и типы, а таблица со  штрих-кодами не содержит описания типа продуктов), но будем считать, что одинаковых штрих-кодов не может быть у продуктов разных типов!

                                                $is_similar_names = 0; // флаг наличия продуктов с таким же именем
                                                $is_similar_bars = 0;  // флаг наличия продуктов с таким же штрих-кодом


                                                $similar_name_nodes = db_query("SELECT nid, vid FROM {node} WHERE title = '%s' AND nid != '%s' AND type = '%s'", $product_name, $nid, $product_type);
                                                $similar_name_node_temp1 = db_fetch_object($similar_name_nodes);
                                                if(is_numeric($similar_name_node_temp1->nid))
                                                   $is_similar_names = 1;

                                                $similar_bar_nodes = db_query("SELECT nid, vid FROM {content_field_bar} WHERE field_bar_value = '%s' AND nid != '%s'", $current_product_bar, $nid);
                                                $similar_name_node_temp2 = db_fetch_object($similar_bar_nodes);
                                                if($similar_name_node_temp2->nid > 0)
                                                   $is_similar_bars = 1;


                                                //drupal_set_message(" ------is_similar_names =  $is_similar_names, is_similar_bars = $is_similar_bars,,,,, temp1_nid = $temp1_nid, temp2_nid = $temp2_nid ", 'error');

                                                if($is_similar_names OR $is_similar_bars)    // если есть продукты с таким же именем или с таким же штрихкодом
                                                 {

                                                   if($is_similar_names AND !$is_similar_bars) // если есть только ноды с таким же именем, но нет продуктов с таким же штрих-кодом
                                                     {
                                                       // создадим sql-строку, которая за один раз вытащит из таблицы  files все только что найденные продукты с таким же названием, как у текущего продукта, вместе с названиями файлов
                                                       $sql_similar_name_or_bar_fids = "SELECT nid, filename, filepath FROM {files} WHERE nid = ";

                                                       // возьмём первое значение
                                                       $sql_similar_name_or_bar_fids = $sql_similar_name_or_bar_fids . $similar_name_node_temp1->nid;

                                                        // выведем названия продуктов для найденных продуктов
                                                       drupal_set_message("!Naideny propucti s takim zhe nazvaniem $product_name:", 'error');
                                                       //$tmp1 = $similar_name_node_temp1->nid;
                                                       //$tmp1_count = 1;
                                                       //drupal_set_message("$tmp1_count: nid of product = $tmp1", 'error');


                                                       // добавим все остальные ноды
                                                       while($similar_name_node_temp1 = db_fetch_object($similar_name_nodes))
                                                        {
                                                          $sql_similar_name_or_bar_fids = $sql_similar_name_or_bar_fids . ' OR nid = ' . $similar_name_node_temp1->nid;

                                                          // выведем номера нодов для остальных найденных продуктов
                                                          //$tmp1 = $similar_name_node_temp1->title;
                                                          //$tmp1_count = $tmp1_count + 1;
                                                          //drupal_set_message("$tmp1_count: nid of product = $tmp1", 'error');
                                                        }
                                                       //drupal_set_message("====1 is Similar names ********sql_similar_name_or_bar_fids = $sql_similar_name_or_bar_fids", 'error');

                                                     }
                                                   if(!$is_similar_names AND $is_similar_bars)  // если есть только ноды с таким же штрих-кодом, но нет продуктов с таким же именем
                                                     {
                                                       // создадим sql-строку, которая за один раз вытащит из таблицы  files все только что найденные продукты c таким же штрих-кодом, как у текущего продукта, вместе с названиями файлов
                                                       $sql_similar_name_or_bar_fids = "SELECT nid, filename, filepath FROM {files} WHERE nid = ";

                                                       // возьмём первое значение
                                                       $sql_similar_name_or_bar_fids = $sql_similar_name_or_bar_fids . $similar_name_node_temp2->nid;

                                                        // выведем номера нодов для найденных продуктов
                                                       drupal_set_message("!Naideny propucti s takim zhe bar-codom $current_product_bar:", 'error');
                                                       //$tmp2 = $similar_name_node_temp2->nid;
                                                       //$tmp2_count = 1;
                                                       //drupal_set_message("$tmp2_count: nid of product = $tmp2", 'error');

                                                       // добавим все остальные ноды
                                                       while($similar_name_node_temp2 = db_fetch_object($similar_bar_nodes))
                                                         {
                                                          $sql_similar_name_or_bar_fids = $sql_similar_name_or_bar_fids . ' OR nid = ' . $similar_name_node_temp2->nid;

                                                          // выведем номера нодов для остальных найденных продуктов
                                                          //$tmp2 = $similar_name_node_temp2->nid;
                                                          //$tmp2_count = $tmp2_count + 1;
                                                          //drupal_set_message("$tmp2_count: nid of product = $tmp2", 'error');
                                                         }

                                                     }
                                                   if($is_similar_names AND $is_similar_bars)  // если есть продукты и с таким же именем, и с таим же штрих-кодом
                                                     {
                                                       // создадим sql-строку, которая за один раз вытащит из таблицы  files все только что найденные продукты, у которых названия или штрих-коды равны, вместе с названиями файлов
                                                       // стоит обратить внимание, что AND в данном случае не говорит о том, что у продуктов одновременно равны и названия и штрих-коды. Это говорит, что среди найденных продуктов есть продукты и с таким же названием, и с таким же штрих-кодом.
                                                       $sql_similar_name_or_bar_fids = "SELECT nid, filename, filepath FROM {files} WHERE nid = ";

                                                       // сначала добавим все продукты с таким же названием
                                                       // возьмём первое значение
                                                       $sql_similar_name_or_bar_fids = $sql_similar_name_or_bar_fids . $similar_name_node_temp1->nid;

                                                        // выведем номера нодов для найденных продуктов с таким же названием
                                                       drupal_set_message("!Naideny propucti s takim zhe nazvaniem $product_name:", 'error');
                                                       //$tmp1 = $similar_name_node_temp1->nid;
                                                       //$tmp1_count = 1;
                                                       //drupal_set_message("$tmp1_count: nid of product = $tmp1", 'error');

                                                       // добавим все остальные названия найденных нодов с таким же названием
                                                       while($similar_name_node_temp1 = db_fetch_object($similar_name_nodes))
                                                        {
                                                          $sql_similar_name_or_bar_fids = $sql_similar_name_or_bar_fids . ' OR nid = ' . $similar_name_node_temp1->nid;

                                                          // выведем номера нодов для остальных найденных продуктов с таким же названием
                                                          //$tmp1 = $similar_name_node_temp1->nid;
                                                          //$tmp1_count = $tmp1_count + 1;
                                                          //drupal_set_message("$tmp1_count: nid of product = $tmp1", 'error');
                                                        }


                                                       // теперь добавим сюда же продукты с таким же штрих-кодом
                                                       // первую проверку пропускаем, так как она сделана ранее (при инициализации флага $is_similar_bars)
                                                       $sql_similar_name_or_bar_fids = $sql_similar_name_or_bar_fids . ' OR nid = ' . $similar_name_node_temp2->nid;

                                                       // выведем номера нодов для найденных продуктов c таким же бар-кодом
                                                       drupal_set_message("!Naideny propucti s takim zhe bar-codom $current_product_bar:", 'error');
                                                       //$tmp2 = $similar_name_node_temp2->nid;
                                                       //$tmp2_count = 1;
                                                       //drupal_set_message("$tmp2_count: nid of product = $tmp2", 'error');


                                                       // добавим все остальные ноды с таким же бар-кодом
                                                       while($similar_name_node_temp2 = db_fetch_object($similar_bar_nodes))
                                                         {
                                                          $sql_similar_name_or_bar_fids = $sql_similar_name_or_bar_fids . ' OR nid = ' . $similar_name_node_temp2->nid;

                                                          // выведем номера нодов для остальных найденных продуктов с таким же бар-кодом
                                                          //$tmp2 = $similar_name_node_temp2->nid;
                                                          //$tmp2_count = $tmp2_count + 1;
                                                          //drupal_set_message("$tmp2_count: nid of product = $tmp2", 'error');
                                                         }


                                                       //drupal_set_message("====3 is Similar names and bars********sql_similar_name_or_bar_fids = $sql_similar_name_or_bar_fids", 'error');

                                                     }




                                                   $similar_name_or_bar_nodes = db_query($sql_similar_name_or_bar_fids);

                                                   // определим масив, который будет содержать штрих-коды для всех найденных продуктов
                                                   // чтобы для одинаковых нодов каждый раз не определять заново штрих-код, обращаясь к базе
                                                   $bar_codes = array();


                                                   for($count = 0; $similar_name_node = db_fetch_object($similar_name_or_bar_nodes); $count++)
                                          	    	{
                                            	     $similar_name_node_nid = $similar_name_node->nid;
                                            	     //$similar_name_node_vid = $similar_name_node->vid;
                                            	     //drupal_set_message("current_product_nid = $nid, similar_name_node_nid = $similar_name_node_nid, product_type = $product_type", 'error');

                                            	     // для каждого продукта проверим, не различаются ли штрих-коды данного (который вводом) продукта и рассматриваемого
                                            	     // для этого проверим, определены ли штрих-коды для обоих продуктов?

                                            	     // тут, конечно, лучше было бы использовать vid, но таблица files не имеет такого поля, поэтому используем nid.
                                            	     // при желании более точно подходить к вопросу, можно делать дополнительный запрос к базе (к таблице nodes), чтобы выяснить текущую vid

                                                     // но пока условимся, что штрих-коды равны для всех ревизий

                                                     if($bar_codes[$similar_name_node_nid][0])
                                                      {
                                                       $test_product_bar = $bar_codes[$similar_name_node_nid][1];
                                                      }
                                                     else
                                                      {
                                                       $test_product_bar = trim(db_result(db_query("SELECT field_bar_value FROM {content_field_bar} WHERE nid = '%s'", $similar_name_node->nid))); // на всякий случай убираем лишние пробелы
                                                       $bar_codes[$similar_name_node_nid][0] = 1; // флаг, что штрих-код для данной ноды найден
                                                      }

                                                     //drupal_set_message("count = $count, xxx-----test_product_bar = $test_product_bar, current_product_bar = $current_product_bar => similar_name_node_nid = $similar_name_node_nid", 'error');

                                            	     if(( ($test_product_bar > 0) AND ($current_product_bar > 0) ) AND ($test_product_bar != $current_product_bar))
                                            	      {
                                            	       //если оба штрих-кода определены, но не равны, значит это разные объекты и картинки брать нельзя
                                            	       // значит пропускаем этот продукт
                                                       drupal_set_message("test_product_bar = $test_product_bar (NEEEEEEEE Ravno!!!) current_product_bar = $current_product_bar => similar_name_node_nid = $similar_name_node_nid", 'error');
                                                       continue;
                                            	      }

                                                     //иначе или штрих-коды равны, или не определены для одного из значений, значит предполагаем, что продукты равны и картинки рассматриваемого продукта использовать можно
                                                     //drupal_set_message("test_product_bar = $test_product_bar (Ravno!!!) current_product_bar = $current_product_bar => similar_name_node_nid = $similar_name_node_nid", 'error');


                                                     // проверяем, нет ли уже среди внесённых в новый массив очередной проверяемой картинки?
                                                     for($in = 0; $in <= $found_pics_index; $in++)
                                                        {
                                                          // если такой fid уже содержится в массиве, пропускаем этот fid
                                                          if($found_pics_filepath[$in][0] == $similar_name_node->filepath)
                                                            {
                                                              //drupal_set_message("2) Sovpadenie #2: (s tol'ko chto naidennymi pics) na $similar_name_node->filepath, nid = $similar_name_node->nid, PROPUSKAEM!", 'error');
                                                              continue (2);
                                                            }
                                                        }


                                                      // если мы дошли до этого шага, значит такого fid в массиве нет
                                                      // и значит мы его добавляем
                                                      $found_pics_index++;
                                                      $found_pics_filepath[$found_pics_index][0] = $similar_name_node->filepath;
                                                      $found_pics_filepath[$found_pics_index][1] = $similar_name_node->filename;

                                                      //$tmp = $found_pics_filepath[$found_pics_index][0];
                                                      //$xxx = found_pics_index;
                                                      //drupal_set_message("found_pics_filepath[$xxx][0] = $tmp", 'error');

                                                    } // конец перебора нодов с таким же именем, как у текущего продукта, имебщих картинки

                                                 } // конец проверки, есть ли продукты таким же именем с картинками      if(($similar_name_nodes = db_query("SELECT nid, vid FROM {node} WHERE title = '%s' AND nid != '%s' AND type = '%s'", $product_name, $nid, $product_type)) > 0 )







                                                 // теперь
                                                 // если переменная $found_pics_index больше нуля, то картинки найдены

                                                 //drupal_set_message("!!found_pics_index = $found_pics_index+1", 'error');

                                                 // если и продукт не содержал ни одной картинки (а он и не содержал, так как это новый продукт), и не найдено в других продуктах с таким же названием картинок
                                                 // тогда добавим в продукт столько картинок (по названию продукта в транслитерации), сколько указано после * в поле с картинками в файле
                                                 if( !($existed_pics_filepath_index >= 0 OR $found_pics_index >= 0) )
                                                  {
													// если после знака вопроса стоял ещё и  "+",
                                                 	// до ещё добавляем в базу столько названий файлов, сколько указано после плюса
                                                 	$add_pics_count = 0;
                                                 	$add_pics_count = explode("*", $row['Kartinki']);
                                             	    $add_pics_count = $add_pics_count[1];

                                              	    if($add_pics_count <= 0)
                                              	       $add_pics_count = 1;

                                             	    for($count = 1; $count <= $add_pics_count; $count++)
                                             	      {
                                             	         $index_tmp = $found_pics_index + 1 + $count; // "+1" - для компенсации начального значения индекса, которые в начале функции = -1.

                                               	         // filepath
                                              	         // если это первая картинка, то номер с тильдой ей не нужен
                                         	             if($index_tmp == 1)
                                          	               $found_pics_filepath[$found_pics_index + $count][0] = $file_directory_path . '/' . $image_name  . ".jpg";
                                           	   		     else
                                            	           $found_pics_filepath[$found_pics_index + $count][0] = $file_directory_path . '/' . $image_name . '~' . $index_tmp  . ".jpg";

                                                         // если это первая картинка, то номер с тильдой ей не нужен
                                                         if($index_tmp == 1)
                                                           $found_pics_filepath[$found_pics_index + $count][1] = $image_name;
                                                         else
                                                           $found_pics_filepath[$found_pics_index + $count][1] = $image_name . '~' . $index_tmp;

                                                      } // end of for ... конец добавления новых картинок, если в продукте их не было и с других продуктов с таким же названием не скопировано

                                                  }  // end of if... конец проверки, были ли в продукте картинки или в других продуктах с таким же названием картинки



                                                 // выведем все скопированные из других продуктов с таким же названием или штрих-кодом
                                                 if($found_pics_index >= 0)
                                                   drupal_set_message("!Found pictures in other product with the same name: ", 'error');

                                                 for($count = 0; $found_pics_index >= $count; $count++)
                                                   {
                                                    $tmp = $found_pics_filepath[$count][0];
                                                    $index = $count + 1;
                                                    drupal_set_message("$index: $tmp", 'error');
                                                   }

                                                 // выведем все созданные новые картинки для продукта (количество указано в файле в поле с картинками после *)




                                                  // выведем все созданные новые картинки для продукта (количество указано в файле в поле с картинками после *)
                                                 // выводим только в том случае, если продукт не содержал сам картинок и ничего не найдено в других продуктах
                                                 if( ($add_pics_count > 0) AND ($found_pics_index < 0) )
                                                  {
                                                    drupal_set_message("!Created new pictures for the product: ", 'error');

                                                    for($count = $found_pics_index + 1; $count <= $found_pics_index + $add_pics_count; $count++)
                                                      {
                                                       $tmp = $found_pics_filepath[$count][0];
                                                       $index = $count + 1;
                                                       drupal_set_message("$index: $tmp", 'error');

                                                      }

                                                  }


                                                 if( $found_pics_index >= 0 )
                                                     $add_pics_count = 0;

                                                 // а теперь занесём в базу найденные картинки в других продуктах с таким же названием (если были найдены) или вновь созданные картинки
                                                 for($count = 0, $delta_new = 0; $found_pics_index + $add_pics_count >= $count; $count++, $delta_new++)
                                                  {
                                                    $flag_new_pics = 1; // если эта переменная будет установлена, значит новые картинки были добавлены

                                                    $tmp = $found_pics_filepath[$count][0]; // [0] это filepath, [1] это filename

                                                    // вносим в базу найденные картинки
                                                    // начальный номер для первой из вводимых картинок будет (delta = existed_pics_filepath_index + 1)

                                                    // $files_fid максимальный номер файла в таблице files, полученный из таблицы sequenses
                                                    // должен обновиться в таблице sequenses после добавления файлов в базу

                                                    $new_files_fid = $files_fid + $count;
                                                    // добавляем файл в таблицу files
                                                    db_query("INSERT INTO {files} (fid, nid, filename, filepath, filemime) VALUES ('%s', '%s', '%s', '%s', '%s')", $new_files_fid, $nid, $found_pics_filepath[$count][1], $found_pics_filepath[$count][0], 'image/jpeg');

                                                    // добавляем файл в таблицу content_field_image_cache
                                                    db_query("INSERT INTO {content_field_image_cache } (vid, delta, nid, field_image_cache_fid) VALUES ('%s', '%s', '%s', '%s')", $vid, $delta_new, $nid, $new_files_fid);
                                                    //drupal_set_message(">>>>count = $count, new_files_fid = $new_files_fid, files_fid = $files_fid, found_pics_filepath[count][0] = $tmp", 'error');




                                                    // выведем то же самое в ячейку Kartinki в файле с соответствубщими пометками
                                                    if($found_pics_index >= 0 AND $count == 0)
                                                       $r_t_f = $r_t_f . "Found in other products:"	. "\n";

                                                    if($add_pics_count > 0 AND ($count == ($found_pics_index + 1)) )
                                                     	$r_t_f = $r_t_f . "Created new pictures:"	. "\n";

                                                    $r_t_f = $r_t_f . $found_pics_filepath[$count][1] . "\n";



                                                  }

                                                 // если были добавлены новые картинки, значит нужно изменить и $files_fid в таблице sequenses
                                                 if($flag_new_pics)
                                                  {
                                                    db_query("UPDATE {sequences} SET id = '%s' WHERE name = 'files_fid'", $new_files_fid);
                                                  }


                                                 break;  // конец варианта, когда в поле картинки стоит "*"




                                              default: // установка в качестве имени картинки строки из этого поля в файле
                                                  // пока ничего не делаем, если в этом поле стоят не управляющие символы, потом напишем функцию ввода названия файла из этого поля
                                                break; // конец варианта с установки в качестве имени файла содержимого этого поля

                                        } // end of switch перебор вариантов первого символа поля с картинками (?, !...)



                                        // Окончание текста в ячейке с именами файлов картинок
                                        $r_t_f = $r_t_f . '"' . ";";






// ###########################################
                     } // end of  if(определено поле Картинки)
                   else
                     {
                       //$tmp1 = $row['Artikul_postavki'];
                       //$tmp2 = $row['Kartinki'];
                       //drupal_set_message("*******Pole Kartinki NE opredeleno!!!!!!!", 'error');
                       //drupal_set_message("************Artikul_postavki = $tmp1, Kartinki = $tmp2", 'error');

                     }







                     // вводим все остальные определённые в файле поля

// ###########################################################################################

         			for($i = 0; isset($form_values['column_'.$i]); $i++)
           			 {
           			  if(!empty($form_values['column_'.$i]))  // ... we have map info for this column
             	        switch($form_values['column_'.$i])
	         				{


// свойства-категории (предопределённые свойства, по которым можно затем группировать товары)
	         	 				case 'Svoistva':
                                      // если поле равно '' или '0' или 'skip'
		                       		  // ничего не делать с этим полем
                                      if( $row['Svoistva'] == '' OR $row['Svoistva'] == '0' OR $row['Svoistva'] == 'skip')
                                         break;


                                       //$tmp = $row['Svoistva'];
                                       //drupal_set_message("row['Svoistva'] = $tmp", 'error');
                                       $svoistva = explode(")", $row['Svoistva']);
                                       foreach($svoistva as $index => $svoistvo)
                                        {
                                         if(!$svoistvo) break;
                                         //drupal_set_message("svoistvo = $svoistvo, index = $index, svoistva[index] = $svoistva[index], svoistva = $svoistva", 'error');
                                         $svoistva_topic = explode("(", $svoistvo);
                                         foreach($svoistva_topic as $index_topic => $svoistvo_topic)
                                           {

                                            if(!$svoistvo_topic) break; //прервать, если нет данных

                                            if($index_topic == 0)
                                              {
                                                // это название раздела (Материал, Фасон и т.д)
                                                //drupal_set_message("Razdel: $svoistvo_topic", 'error');

                                                $topic = trim($svoistvo_topic); //удаляем лишние пробелы из начала строки
                                                //выясняем номер этой категории в таблице

                                                // сначала найдём все категории из словаря
                                                // кстати, номер словаря Свойства = $svoistva_vid - был определён вначале этой функции, где определяются основные переменные
                                                $tid_svoistvo_razdel = db_result(db_query("SELECT tid FROM {term_data} WHERE vid = '%s' AND name = '%s'", $svoistva_vid, $topic));

                                               // если нет такого раздела (категории) в базе или эта категория имеет родителя (parent != 0), то значит ошибочная категория или новая и её нужно создать (если пользователь это указал на первом экране)
                                               if(!($tid_svoistvo_razdel > 0) OR (db_result(db_query("SELECT parent FROM {term_hierarchy} WHERE tid = '%s'", $tid_svoistvo_razdel))) != '0')
                                                 {
                                                      //если пользователь указал на первом экране создавать новый раздел для свойств
                                                      if($form_values['Create_New_Svoistvo_Razdel'])
                                                        {
                                                           // если да, то создаём новый раздел в таблице term_data в словаре свойств
                                                           db_query("INSERT INTO {term_data} (vid, name, description) VALUES ('%s', '%s', '')", $svoistva_vid, $topic);
                                                           //его tid создаётся автоматически, поэтому после создания выясняем его и присваиваем нашей рабочей переменной,
                                                           $tid_svoistvo_razdel = db_result(db_query("SELECT tid FROM {term_data} WHERE vid = '%s' AND name = '%s'", $svoistva_vid, $topic));
                                                           // прописываем раздел в таблице иерархии термов для того, чтобы этот раздел являлся корневым разделом (родителем для свойств). Если этого не сделать, раздел (и впоследствии его свойства) не появится в списке термов (категорий)
                                                           db_query("INSERT INTO {term_hierarchy} (tid, parent) VALUES ('%s', '0')", $tid_svoistvo_razdel);
                                                           // теперь также необходимо обновить переменную, содержащую максимальный номер tid таблицы term_data в таблице sequences
                                                           db_query("UPDATE {sequences} SET id = '%s' WHERE name = 'term_data_tid'", $tid_svoistvo_razdel);
                                                           // вообщаем о том, что ввели в базу новый раздел для свойств
                                                           drupal_set_message("VVVnimanie! V baze sozdan new razdel dlia svoistv = $topic (User set a creation of new razdel for svoistva if it's not exist)!", 'error');
                                                           // и дальше продолжаем, как будто бы атрибут изначально присутствовал в базе
                                                           //break;
                                                        }
                                                       else
                                                        {
                                                           // если пользователь не указывал вводить новый раздел для свойств, значит пропускаем этот раздел вместе с его свойствами
                                                           drupal_set_message("VVVnimanie! V baze v svoistvah net takogo razdela = $topic. Etot razdel propuskaetsia!", 'error');
                                                           continue (2); //прерываем цикл обработки этого раздела
                                                        }

                                                 }


                                                //drupal_set_message("tids_svoistva = $tids_svoistva", 'error');


                                                continue;
                                              }
                                             else
                                              {
                                                ; //drupal_set_message("Harakteristiki:", 'error');
                                              }

                                             // уберём из строки все лишние '~', которые могли быть ошибочно повтороно введены (в конце, в середине, двойные ~~)
         									 $svoistvo_topic = trim($svoistvo_topic, "~");
         									 $svoistvo_topic = str_replace("~~", "~", $svoistvo_topic);

                                             $svoistva_topic_feature = explode("~", $svoistvo_topic);
                                             foreach($svoistva_topic_feature as $index_topic_feature => $svoistvo_topic_feature)
                                              {

                                               //убираем лишние пробелы и из этих данных
                                               $svoistvo_topic_feature = trim($svoistvo_topic_feature);

                                               // это отдельные характеристики, которые теперь нужно внести в базу
                                               //drupal_set_message("$svoistvo_topic_feature", 'error');
                                               //вводим характеристики в таблицу content_field_svoistva
                                               // родитель для каждого свойства - найденный только что раздел $topic в этой таблице
                                               // и только что мы нашли его еомер tid в таблице term_data. Это $tid_svoistvo_razdel

                                               //выясняем номера tid всех свойств, у которых родитель текущий раздел $tid_svoistvo_razdel
                                               //ведь их обычно несколько
                                               $tids_svoistva = db_query("SELECT tid FROM {term_hierarchy} WHERE parent = '%s' ", $tid_svoistvo_razdel);

                                               // теперь находим среди них tid с текущим свойством
                                               $tid_svoistvo = 0; // обнуляем переменную
                                               while($tid_svoistva = db_fetch_object($tids_svoistva))
                                                 {

                                                   $tmp = db_result(db_query("SELECT name FROM {term_data} WHERE tid = '%s' ", $tid_svoistva->tid));
                                                   if($svoistvo_topic_feature == $tmp)
                                                    {
                                                     $tid_svoistvo = $tid_svoistva->tid;
                                                     break;
                                                    }
                                                 }


                                               // если в базе нет такого свойства в базе, что делать?
                                               if(!($tid_svoistvo > 0))
                                                 {

                                                   //если пользователь указал на первом экране создавать новыое свойство для этого раздела
                                                   if($form_values['Create_New_Svoistvo_Svoistvo'])
                                                     {
                                                        // если да, то создаём новое свойство для текущего раздела в таблице term_data в словаре свойств
                                                        db_query("INSERT INTO {term_data} (vid, name, description) VALUES ('%s', '%s', '')", $svoistva_vid, $svoistvo_topic_feature);
                                                        //его tid создаётся автоматически, поэтому после создания выясняем его и присваиваем нашей рабочей переменной,
                                                        $tid_svoistvo = db_result(db_query("SELECT tid FROM {term_data} WHERE vid = '%s' AND name = '%s'", $svoistva_vid, $svoistvo_topic_feature));
                                                        // связываем свойство с разделом в таблице иерархии термов
                                                        db_query("INSERT INTO {term_hierarchy} (tid, parent) VALUES ('%s', '%s')", $tid_svoistvo, $tid_svoistvo_razdel);
                                                        // теперь также необходимо обновить переменную, содержащую максимальный номер tid таблицы term_data в таблице sequences
                                                        db_query("UPDATE {sequences} SET id = '%s' WHERE name = 'term_data_tid'", $tid_svoistvo);
                                                        // вообщаем о том, что ввели в базу новое свойство для текущего раздела для свойств
                                                        drupal_set_message("VVVnimanie! V baze sozdano new svoistvo $svoistvo_topic_feature dlia razdela $topic (User set a creation of new svoistvo dlia razdela if it's not exist)!", 'error');
                                                        // и дальше продолжаем, как будто бы атрибут изначально присутствовал в базе
                                                     }
                                                   else
                                                     {
                                                       // если пользователь не указал создавать новое свойство в базе, выводим сообщение И пропускаем его
                                                       drupal_set_message("VVVnimanie! V baze net takogo svoistva = $svoistvo_topic_feature dlia razdela $topic. Eto svoistvo propuskaetsia!", 'error');
                                                       continue;
                                                     }


                                                 }

                                            /*
                                               //а если принять, что у нас не повторяются названия свойств в разных разделах, то можно найти tid текущего свойство одной строкой
                                               // кстати, номер словаря Свойства = $svoistva_vid - был определён вначале этой функции, где определяются основные переменные

                                               $tid_svoistvo = db_result(db_query("SELECT tid FROM {term_data} WHERE vid = '%s' AND name = '%s'", $svoistva_vid, $svoistvo_topic_feature));
                                               if(!($tid_svoistvo > 0))
                                                 {
                                                   // если в базе нет такого свойства, пропускаем его и выводим сообщение
                                                   drupal_set_message("Vnimanie! V baze net takogo svoistva = $svoistvo_topic_feature. Eto svoistvo propuskaetsia!", 'error');
                                                   continue;
                                                 }
                                             */

                                               // печатаем на экране текущее свойство
                                               //drupal_set_message("svoistvo_topic_feature = $svoistvo_topic_feature, tid = $tid_svoistvo", 'error');

                                               //добавляем свойство в таблицу content_field_svoistva к текущему продукту
                                               db_query("INSERT INTO {content_field_svoistva} (nid, vid, delta, field_svoistva_tid) VALUES (%s, %s, %s, %s)", $nid, $vid, $tid_svoistvo, $tid_svoistvo);



                                               // если в свойствах в таблице node_field для поля field_svoistva установлена опция "сохранять свойства как категории"
                                               // добавляем такие же категории в таблицу term_node, чтобы они стали и ссылками (именно по ним потом можно будет группировать однотипные продукты)
                                               // $content_field_add_category определяется один раз вначале функции, где и остальные переменные
                                               if($content_field_add_category)
                                                  {
                                                    db_query("INSERT INTO {term_node} (nid, tid) VALUES (%s, %s)", $nid, $tid_svoistvo);

                                                  }

                                               // обнуляем кэш, иначе данные на сайте не обновятся
                                               // обнулим его единожды в конце функии!
                                               //db_query("TRUNCATE TABLE {cache_content}");


                                              } // end of foreach($svoistva_topic_feature as $index_topic_feature...
                                           } //end of foreach($svoistva_topic as $index_topic...
                                        } //end of foreach($svoistva as $index...

                                        break; // конец блока с  изменением свойств продукта




// устанавливаем атрибуты, которые может выбирать пользователь для этого продукта (размер, цвет и т.д.)
	         	 				case 'Atributy':

									   // если поле равно '' или '0' или 'skip'
		          					   // ничего не делать с этим полем
                                       if( $row['Atributy'] == '' OR $row['Atributy'] == '0' OR $row['Atributy'] == 'skip')
                                         break;



                                       $atributy = explode(")", $row['Atributy']);
                                       foreach($atributy as $index => $attrs_and_opts)
                                        {
                                         if(!$attrs_and_opts) break;
                                         //drupal_set_message("attrs_and_optso = $attrs_and_opts, index = $index, attrs_and_opts svoistva[index] = $$attrs_or_opts svoistva[index], attrs_or_opts = $attrs_and_opts", 'error');
                                         $attrs = explode("(", $attrs_and_opts);
                                         foreach($attrs as $index_attr => $attr)
                                           {
                                            if(!$attr) break; //прервать, если нет больше данных
                                            if($index_attr == 0)
                                              {
                                                // это название атрибута (Размер, Цвет и т.д)
                                                //drupal_set_message("Attribute: $attr", 'error');

                                                $attr = trim($attr); //удаляем лишние пробелы из начала строки
                                                $current_attr = $attr;
                                                //выясняем номер этого атрибута  в таблице uc_attributes
                                                $aid_attr = db_result(db_query("SELECT aid FROM {uc_attributes} WHERE name = '%s'", $attr));

//#####################################################################
                                                // если нет такого атрибута в базе, то значит ошибочный или новый атрибут,
                                                // что делать?
                                                if(!($aid_attr > 0))
                                                  {
                                                      // пользователь на первом экране указал создавать новые атрибуты?
                                                      if($form_values['Create_New_Attribute'])
                                                        {
                                                           // если да, то создаём новый артрибут в таблице uc_attributes
                                                           db_query("INSERT INTO {uc_attributes} (name, display) VALUES ('%s', '1')", $attr);
                                                           //его aid создаётся автоматически, поэтому после создания выясняем его и присваиваем нашей рабочей переменной,
                                                           $aid_attr = db_result(db_query("SELECT aid FROM {uc_attributes} WHERE name = '%s'", $attr));
                                                           drupal_set_message("VVVnimanie! V baze sozdan new attribut = $current_attr (User set a creation of new attribut if it's not exist)!", 'error');
                                                           // и дальше продолжаем, как будто бы атрибут изначально присутствовал в базе
                                                           //break;
                                                        }
                                                      else
                                                        {  // если такого атрибута нет в базе и пользователь на первом экране не указал создавать новые атрибуты,
                                                           // то пропускаем этот атрибут (вместе с его опциями)
                                                      	   drupal_set_message("VVVnimanie! V baze net takogo atributa = $current_attr. Etot atribut propuskaetsia (vmeste s ego options)!", 'error');
                                                           //break (2); //прерываем цикл обработки этого атрибута
                                                           continue (2);
                                                        }
                                                  }

                                                // заносим в таблицу uc_product_attributes инфо о новом атрибуте
                                                db_query("INSERT INTO {uc_product_attributes} (nid, aid, display) VALUES (%s, %s, %s)", $nid, $aid_attr, '1');
                                                // ещё осталось задать option по умолчанию, но эта опция станет известна только на следующей итерации
                                                // так что её добавим позже
                                                continue;
                                              }   // end of обработки, если это атрибут (а не опция атрибута)
                                             else
                                              {
                                              	//drupal_set_message("Options:", 'error');

                                                // уберём из строки все лишние '~', которые могли быть ошибочно повтороно введены (в конце, в середине, двойные ~~)
         									    $attr = trim($attr, "~");
         									    $attr = str_replace("~~", "~", $attr);

                                             	$options = explode("~", $attr);
                                             	foreach($options as $index_options => $option)
                                             	 {

                                             	  //убираем лишние пробелы и из этих данных
                                             	  $option = trim($option);

                                             	  // это отдельные опции, которые теперь нужно внести в базу
                                             	  // drupal_set_message("$option", 'error');
                                             	  // вводим опции в таблицу uc_product_options

                                             	  //выясняем номер oid опции
                                             	  $oid_option = db_result(db_query("SELECT oid FROM {uc_attribute_options} WHERE aid = '%s' AND name = '%s'", $aid_attr, $option));

                                                  // что делаеть, если в базе нет такой опции у данного атрибута?
                                              	  if(!($oid_option > 0))
                                              	   {
                                                      // пользователь на первом экране указал создавать новые свойства для атрибутов?
                                                      if($form_values['Create_New_Attribute_Options'])
                                                        {
                                                           // если да, то создаём новый артрибут в таблице uc_attributes
                                                           db_query("INSERT INTO {uc_attribute_options} (aid, name) VALUES ('%s', '%s')",  $aid_attr, $option);
                                                           //его oid создаётся автоматически, поэтому после создания выясняем его и присваиваем нашей рабочей переменной,
                                                           $oid_option = db_result(db_query("SELECT oid FROM {uc_attribute_options} WHERE name = '%s'", $option));
                                                           drupal_set_message("VVVnimanie! V baze sozdan new option = $option dlia attributa $current_attr (User set a creation of new options if it's not exist)!", 'error');
                                                           // и дальше продолжаем, как будто бы это свойство этого атрибута изначально присутствовало в базе
                                                           //break;
                                                        }
                                                      else
                                                        {
                                                           // если такого свойства у данного атрибута нет в базе и пользователь на первом экране не указал создавать новые свойства для атрибутов
                                                           // то пропускаем это свойство атрибута
                                                      	   drupal_set_message("VVVnimanie! V baze net takogo option = $option u attributa $attr. Etot option propuskaetsia!", 'error');
                                                           continue; //прерываем цикл обработки этого свойства атрибута
                                                        }

                                                   }


                                               	  // печатаем на экране текущию опцию
                                                  //drupal_set_message("Option = $option, oid = $oid_option", 'error');

                                                  //добавляем опцию в таблицу uc_product_options  к текущему продукту
                                               	  // тут можно было бы ещё и цену и прочие характеристики внести, когда придумаю, как их обозначать в файле
                                               	  db_query("INSERT INTO {uc_product_options } (nid, oid) VALUES ('%s', '%s')", $nid, $oid_option);

                                               	  // первую опцию в списке устанавливаем опцией по умолчанию для текущего атрибута этого продукта
                                                  if($index_options == 0)
                                                 	db_query("UPDATE {uc_product_attributes} SET default_option = '%s' WHERE nid = %s AND aid = %s", $oid_option, $nid, $aid_attr);


                                                  // тут ещё можно было бы указать и картинку для текущей опции
                                                  // когда придумаю, как обрабатывать картинки

                                                 }  // end of обработки (перебора) свойств атрибута foreach($options as $index_options...

                                              }  // end of else обработки, если это свойство атрибута (а не сам атрибут)

                                           } //end of foreach...

                                        } //end of foreach...


                                       break; // конец блока с  изменением атрибутов продукта








                                default: // для всех остальных полей в файле ничего не делаем

                                   break;

                	        }

                     }

                    //drupal_set_message("!Test exit on nid = $nid. Artikul_zp = $artikul_zp, otdel_products_count = $otdel_products_count", 'error');
                    //return;

                    $product_created_count++;


                } // end of else (конец блока обработки, когда нет совпадения), то есть, конец ввода нового продукта









/* Работа со ссылками на изображения


                // IMAGE

                // Generate the image name if a pattern has been passed
                if(empty($row['image']) and !empty($form_values['images_name_pattern']))
                {
                    $patterns = $replacement = array();
                    foreach(uc_import_csv_m_image_filename_tokens($form_values) as $pattern => $data_index)
                    {
                        $patterns[] = $pattern;
                        // split incase its a comma seperated list, in which case take the first value
                        $replacement[] = array_shift(split(',', $row[$data_index]));
                    }

                    $row['image'] = strtolower(str_replace($patterns, $replacement, $form_values['images_name_pattern']));
                }

                // Prepend the given default folder to look for the images in
                if(!empty($form_values['images_path']) and !empty($row['image']))
                    $row['image'] = $form_values['images_path'].'/'.$row['image'];

                if(!file_exists($row['image']))
                    $row['image'] = '';



*/


/*  оригинальная генерация XML

                // PRODUCT
                // Get this particular products XML by 'name' (so must be unique and on every row).
                if($node = $store_xml->xpath("/store/products/product[name='".$row['name']."']"))
                {
                    // ... one already exists so work with it
                    $product_xml = $node[0];
                }
                else
                {
                    // ... not found so create one.
                    $product_xml = $store_xml->products->addChild('product');
                    $product_count++;
                }

                module_invoke_all('uc_import_csv_m_row', $product_xml, $row, $store_xml);
*/


        }  // конец обработки файла с продуктами




            // обнуляем кэш, иначе данные на сайте не обновятся
            // делаем это единожды в конце функии!
            db_query("TRUNCATE TABLE {cache_content}");



            drupal_set_message("Processed $row_count rows of the CSV file $csvfile_name.");
            drupal_set_message($product_created_count.' products created.');
            drupal_set_message($product_updated_count.' products updated.');


            //$r_t_f = '1"Title";"Snippet";"Link";"Type","Author","Date","Comments","Attachments","Score"'."\n".'2"Title","Snippet","Link","Type","Author","Date","Comments","Attachments","Score"';
            $output_i_results = $r_t_f;

            variable_set('output_i_results_var', $output_i_results);



/*  оригинальная генерация XML

            if($form_values['show_xml'])
            {
                header('Content-Type: text/xml');
                echo $store_xml->asXML();
                die();
            }
            else
            {
                drupal_set_message('XML submitted to the Ubercart Importer.');
                // Send to the Importer
                uc_importer_import($store_xml->asXML());
            }
*/





    } // if(intval($form_values['step']) == 3)


}














//  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - //
// Fucntions to implement hooks defined here for modules that haven't.
// Hooks are invoked as follows:
//      'uc_import_csv_m_row'             in  uc_import_csv_m_multiform_submit()
//      'uc_import_csv_m_fields_list'     in  uc_import_csv_m_multiform()
//      'uc_import_csv_m_filename_tokens' in  uc_import_csv_m_image_filename_tokens()
//  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - //

function uc_attribute_uc_import_csv_m_filename_tokens($values)
{
    $attrs = uc_attribute_uc_import_csv_m_fields_list($values);

    $out = array();

    foreach($attrs['Attributes'] as $key => $name)
        $out[preg_replace('/[^a-z0-9]/', '_', strtolower($name))] = $key;

    return $out;
}

/**
 * Load in attributes of the class if one was selected
 */
function uc_attribute_uc_import_csv_m_fields_list($values)
{
    $attributes = array();

    if(isset($values['class']) and !empty($values['class']))
    {
        $sql = 'SELECT  a.aid, a.name
                FROM    {uc_attributes} AS a
                    LEFT JOIN {uc_class_attributes} AS ca
                        ON  a.aid = ca.aid
                        AND ca.pcid = %d
                ORDER BY a.ordering';

        $query = db_query($sql, $values['class']);

        while($attr = db_fetch_object($query))
            $attributes['aid_'.$attr->aid] = $attr->name;
    }

    return array('Attributes' => $attributes);
}



/**
 * Implements hook_uc_import_csv_m_fields_list()
 *
 * Add in a list of Taxonomys. Values in the column will be
 * considered terms in the taxonomy
 */
function taxonomy_uc_import_csv_m_fields_list($values)
{
    // we could filter by passing 'product' but with classes their
    // own type now might not work, or would have to do it for each
    // type :O

    $vocab_list = array();

    foreach(taxonomy_get_vocabularies() as $Vocab)
        $vocab_list['vid_'.$Vocab->vid] = $Vocab->name;

    return array('Kategorii' => $vocab_list);
}