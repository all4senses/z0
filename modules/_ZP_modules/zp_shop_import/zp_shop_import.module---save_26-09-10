<?php

global $version;
$version = '2.1b 20-05-10';




// название полей с данными в таблице в исходном файле
global $fields;
$fields = array();
  
// данные о запланированных и реализованных задачах
global $reported_tasks;
$reported_tasks = array();
global $scheduled_tasks; 
$scheduled_tasks = array(); 
  
// исходные данные из файла (кроме табличных)
global $zp_input_data;
$zp_input_data = array();
global $zp_input_data_commented;
$zp_input_data_commented  = array();

// массив с исходными табличными данными из файла
global $zp_catalog; 
$zp_catalog = array(); 
    
// массив выходных данных, которые уже прошли обработку 
//(у них будут сняты все пометки о необходимости редактирования 
// и добавлена метка error в поле 'Действие / результат', если булут какие-либо проблемы при обработке)
global $zp_catalog_processed;
$zp_catalog_processed = array();
 
// дополнительные текущие данные, в том числе название файлов для обработки
global $zp_preprocess_data;
$zp_preprocess_data = array();

// ----- считываем из файла исходных данных имя файла с данными, с которыми придётся работать
$zp_preprocess_data['zp_shop_input_data'] = '---zp_shop_input_data.csv';
//$file_name = '---zp_shop_input_data.csv';
//$file_name = $form_values['csvfile'];

// катарол на сервере с исходными и выходными файлами с данными
global $zp_server_directory;
//$zp_server_directory = 'http://www.zapokupkami.com/zp_import_data/';


//$zp_server_directory = 'D:\\WebServers\\home\\zapokupkami2.com\\www\\zpwrk\\shop_import\\';
$zp_server_directory = $_SERVER['DOCUMENT_ROOT'] . base_path() . 'zpwrk/shop_import_data/';



/**
 * Implementation of hook_menu().
 */
function zp_shop_import_menu($may_cache)
{
    global $form_values;
  $items = array();
    $items[] = array(
        'path' => 'admin/store/products/import/zp_shop_import',
        'access' => user_access('import'),
        //'title' => t('ZP Shop Import /Ver. '. Version),
        'title' => t('ZP Shop Import'),
        'callback' => 'drupal_get_form',
        'callback arguments' => array('zp_shop_import_multiform'),
        'type' => MENU_NORMAL_ITEM,
    );


  return $items;
}




function zp_shop_import_get_delimiter($in = '')
{
    $delimiter_map = array(
        'semi colin'    => ';',
        'comma'         => ',',
        'tab'           => "\t"
    );
    if(isset($delimiter_map[$in]))
        return $delimiter_map[$in];
    elseif(empty($in))
        return  ';';
}







// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------

// Multistep form for collecting the import options before processing the

function zp_shop_import_multiform($values = NULL)
{
    //global $output_i_results;
	global $version;
	
	
	global $fields;
	global $reported_tasks;
	global $scheduled_tasks; 
	global $zp_input_data;
	global $zp_input_data_commented;
	global $zp_catalog; 
	global $zp_catalog_processed;
	global $zp_preprocess_data;
	
	
	
    $form = array();

    $form['#multistep'] = TRUE;
    $form['#redirect'] = FALSE;

    // Find out which step we are on. If $values is NULL,
    // that means we are on step 1.
    $step = !is_null($values) ? (int) $values['step'] : 1;

    // переменная для возврата на первое окно импорта
    global $new_import;
    if($new_import != 0) $step = $new_import;

    $form['step'] = array(
        '#type' => 'hidden',
        '#value' => $step + 1
    );

    switch($step)
    {
        case 1:     // STEP 1

        
        	  
  			$error_mesage = zp_load_data_from_files();	
  			
  			if($error_mesage)
  			{
  			  	//echo $error_mesage;
  			  
            	$form['step1'] = array(
                '#type' => 'fieldset',
                '#collapsible' => TRUE,
                '#collapsed' => FALSE,
                '#title' => t('Шаг 1: Исходные данные /Ver. ' . $version)
            	);
            
            	$form['step1']['errors'] = array(
                '#type'             => 'textarea',
                '#title'            => 'Обнаруженные ошибки загрузки исходных данных',
                '#default_value'    => $error_mesage,
                //'#description'      => t('Path to the images on the server. Its assumed you have already uploaded the images. You can define the file name for each product in a column in your CSV file.'),
            	);
            
             	// заменяем кнопку Submit на ссылку на начальную страницу импорта (фактически, перезагружаем страницу)
            	$form['step1']['reload'] = array(
			  	'#type' => 'item',
  				//'#title' => l(t('Перезагрузить страницу'), 'admin/store/products/import/zp_shop_import', array('title' => t('Обновить страницу'))),
  				'#value' => l(t('Перезагрузить страницу'), 'admin/store/products/import/zp_shop_import', array('title' => t('Обновить страницу'))),
  				'#prefix' => '<strong>',
  				'#suffix' => '</strong>', 
				);

            	/*
            	// кнопка  Submit
	    		$form['submit'] = array(
	        	'#type' => 'submit',
	        	'#value' => t('Обновить эту страницу после загрузки новых данных')
	        	);
	        	*/

              	$new_import = 1; // вернуться на первую страницу (первый шаг)

              	//break;
              	return $form;
  			}


  			 $form['step1'] = array(
                '#type' => 'fieldset',
                '#collapsible' => TRUE,
                '#collapsed' => FALSE,
                '#title' => t('Шаг 1: Исходные данные /Ver. ' . $version)
            );

  			$source_files = 'Главный файл с описанием файлов с исходными данными: ' . $zp_preprocess_data['zp_shop_input_data'] . '
  			
' . 'Расписание задач: ' . $zp_preprocess_data['zp_schedule_file'] . '
' . 'Ранее выполненные задачи (отчёт): ' . $zp_preprocess_data['zp_schedule_report'] . '
' . 'Табличные данные для загрузки в базу данных: ' . $zp_input_data['catalog_filename'] . '

';		
  			// если загрузка не первая из этого файла, то уже известно название выходного файла с обработанной таблицей
  			if($zp_preprocess_data['processed_catalog_filename'])
  			  $source_files = $source_files . 'Файл с обработанными табличными данными (в него записывается результат работы): ' . $zp_preprocess_data['processed_catalog_filename'];
			
  			  
  			 //echo 'step 1 zp_preprocess_data[processed_catalog_filename] = ' . $zp_preprocess_data['processed_catalog_filename'];
  			
  			$form['step1']['source_files'] = array(
                '#type'             => 'textarea',
                '#title'            => 'Файлы с исходными данными (данные считаны из файла' . $zp_preprocess_data['zp_shop_input_data'] . ')',
                '#default_value'    => $source_files,
                //'#description'      => t('Принято в обработку ' . $count_processed . ' строк из '. $count_whole . ' строк (c ' . $zp_preprocess_data['start_num_string'] . ' по ' . $zp_preprocess_data['stop_num_string'] .  '), указанных в задании (из них пустых ' . ($count_whole - $count_processed) .' строк не показаны и обрабатываться не будут)'),
            	);
            	
            
  
            $all_scheduled_tasks = '';	
            foreach($zp_preprocess_data['scheduled_tasks'] as $scheduled_task)
             $all_scheduled_tasks = $all_scheduled_tasks . '
' . $scheduled_task;
            
            $form['step1']['scheduled_task'] = array(
                '#type'             => 'textarea',
                '#title'            => 'Все задачи из файла с расписанием задач ' . $zp_preprocess_data['zp_schedule_file'],
                '#default_value'    => $all_scheduled_tasks,
                '#description'      => t('Часть задач уже может быть выполнена (см. ниже содержимое файла отчёта с уже выполненными задачами)'),
            	);
  			
            $all_reported_tasks = '';	
            foreach($zp_preprocess_data['reported_tasks'] as $reported_task)
             $all_reported_tasks = $all_reported_tasks . '
' . $reported_task;

             $form['step1']['reported_task'] = array(
                '#type'             => 'textarea',
                '#title'            => 'Уже выполненные задачи из файла с расписанием задач ' . $zp_preprocess_data['zp_schedule_report'],
                '#default_value'    => $all_reported_tasks,
                '#description'      => t('Эти задачи уже выполняться не будут'),
            	);
             
            
            	
            if($zp_preprocess_data['inverse'] == 'yes')
  			 $process_order = ', инвертированный порядок обработки строк (с конца в начало), полезно при удалении элементов';
  			  
            $form['step1']['current_task'] = array(
                '#type'             => 'textarea',
                '#title'            => 'Текущая (очередная) задача (строки из файла ' . $zp_input_data['catalog_filename'] . '), готовая к обработке',
                '#default_value'    => 'Строки ' . $zp_preprocess_data['current_task'] . ' из исходной таблицы' . $process_order,
                '#description'      => t('Задача выбрана из расписания задач ' . $zp_preprocess_data['zp_schedule_file'] . ', с учётом уже выполненных задач (по данным из файла отчёта' . $zp_preprocess_data['zp_schedule_report'] . ')'),
            	);
  			 

  			
  			$string = '';
  			foreach ($fields as $field)
  			  $string = $string . ' > ' . $field;
  			$string = $string . '

';
  			$count_whole = 0;
  			$count_processed = 0;
  			foreach($zp_catalog as $values)
  			{
  				$count_whole++;
  				if(trim($values['Действие / результат']) == '' OR  trim($values['Действие / результат']) == '>>')
  				  continue;
  				  
  				$count_processed++;
   				foreach($values as $value)
     			   $string = $string . ' > ' . $value;
     			$string = $string . '

';
			}
  
 	
			// все данные из файла в форме массива
			//$real_data = $zp_catalog;
			//foreach ($real_data as $key => $value) 
		if(is_array($zp_catalog))
			foreach ($zp_catalog as $key => $value) 
			{
				if($value['Тип записи'] == '' OR $value['Тип записи'] == ' ')
				{
					//unset($real_data[$key]);
					continue;
				}
				if($value['Тип записи'] == 'подотдел' OR $value['Тип записи'] == 'подгруппа')
					$real_data[$key . '-' . $value['Действие / результат'] . '-' . $value['Название сокращённое']] = $zp_catalog[$key];	
				else
					$real_data[$key . '-' . $value['Действие / результат'] . '-' . $value['Название']] = $zp_catalog[$key];
					
			}
			
			// элементы (строки), требующие обработки (добавления, изменения и т.д.) из файла в форме массива
		if(is_array($real_data))
			foreach ($real_data as $key => $value) 
			{
				if($value['Действие / результат'] == '' OR $value['Действие / результат'] == ' ')
				{
					//unset($real_data[$key]);
					continue;
				}
				$data_to_process[$key] =  $real_data[$key];
			}
			
			
			$start_row = $zp_preprocess_data['start_num_string'];
			$stop_row = $zp_preprocess_data['stop_num_string'];
			if($count_whole < ($stop_row - $start_row))
				$stop_row = $start_row + $count_whole;
			
			$form['step1']['all_data'] = array(
                '#type'             => 'textarea',
                '#title'            => 'Все данные, считанные из файла ' . $zp_input_data['catalog_filename'] . ' в соответствием с заданием (расписанием)',
                '#default_value'    => print_r($real_data, TRUE), //print_r($zp_catalog, TRUE),
                '#description'      => t('Файл содержит '. $count_whole . ' элементов (c ' . $start_row . ' по ' . $stop_row .  '), указанных в задании (из них пустых ' . ($count_whole - $count_processed) .' строк показаны, но обрабатываться не будут)'),
            	);
			
			
			
        	$form['step1']['data_to_process'] = array(
                '#type'             => 'textarea',
                '#title'            => 'Данные, считанные из файла ' . $zp_input_data['catalog_filename'] . ' в соответствием с заданием (расписанием) и готовые к обработке',
                '#default_value'    => print_r($data_to_process, TRUE), //$string,
                '#description'      => t('Принято в обработку ' . $count_processed . ' элементов из '. $count_whole . ' строк (c ' . $start_row . ' по ' . $stop_row .  '), указанных в задании (из них пустых ' . ($count_whole - $count_processed) .' строк не показаны и обрабатываться не будут)'),
            	);
            	  
  

	   		 // кнопка  Submit
	    	$form['submit'] = array(
	        	'#type' => 'submit',
	        	'#value' => t('Внести данные в базу')
	        );

            $new_import = 0;

            break;






        case 2:     // STEP 2


// Save data from perivious step to pass on to next step (hidden)...
// сохранение полей выбора пользователя
// если здесь не прописать все поля, то на последующих шагах не сохранятся значения, выбранные пользователем
// соответственно, не будет к ним доступа (они все будут неопределены) и их нельзя будет использовать

            
			//echo 'STEP 2 starts... with file ' . $zp_preprocess_data['zp_shop_input_data'] . '<br>';
			
			zp_process_loaded_data();
			
			
			
			
            $form['step2'] = array(
                '#type' => 'fieldset',
                //'#title' => t('Step 2: Map CSV columns to Ubercart product data.'),
                '#title' => t('Шаг 2: Результаты обработки данных'),
                //'#description' => t('For each column in the CSV listed bellow select what it maps to on a Product. Items with a * after their name mus be mapped to something.')
            );
			
			
			
			
			// сформируем название полей табличных данных (чтобы показать их в исходных и обработанных табличных данных)
			
			$fields_string = '';
  			foreach ($fields as $field)
  			  $fields_string = $fields_string . ' > ' . $field;
  			$fields_string = $fields_string . '

';
  			// выведем исходные табличные данные для сравнения
  			$string = '';
  			$count_whole = 0;
  			$count_processed = 0;
  		if(is_array($zp_catalog))	
  			foreach($zp_catalog as $values)
  			{
  				$count_whole++;
  				if(trim($values['Действие / результат']) == '' OR  trim($values['Действие / результат']) == '>>')
  				  continue;
  				  
  				$count_processed++;
   				foreach($values as $value)
     			   $string = $string . ' > ' . $value;
     			$string = $string . '

';
 			    //echo 'данные для обработки =  ' .  $string  .'<br>';
			}
  	
			$string = $fields_string . $string;
			
			
			
			
			
			
			
			// все данные из файла в форме массива
		if(is_array($zp_catalog))
			foreach ($zp_catalog as $key => $value) 
			{
				if($value['Тип записи'] == '' OR $value['Тип записи'] == ' ')
				{
					//unset($real_data[$key]);
					continue;
				}
				if($value['Тип записи'] == 'подотдел' OR $value['Тип записи'] == 'подгруппа')
					$real_data[$key . '-' . $value['Действие / результат'] . '-' . $value['Название сокращённое']] = $zp_catalog[$key];	
				else
					$real_data[$key . '-' . $value['Действие / результат'] . '-' . $value['Название']] = $zp_catalog[$key];
					
			}
			
			// элементы (строки), требующие обработки (добавления, изменения и т.д.) из файла в форме массива
		if(is_array($real_data))
			foreach ($real_data as $key => $value) 
			{
				if($value['Действие / результат'] == '' OR $value['Действие / результат'] == ' ')
				{
					//unset($real_data[$key]);
					continue;
				}
				$data_to_process[$key] =  $real_data[$key];
			}
			
			
			
			
			
			$form['step2']['previous_data'] = array(
                '#type' => 'fieldset',
                //'#title' => t('Step 2: Map CSV columns to Ubercart product data.'),
                '#title' => t('Исходные данные (для сравнения)'),
                '#description' => t('Данные, считанные из исходных файлов'),
                '#collapsible' => TRUE,
                '#collapsed' => TRUE,
            );
 	
        	$form['step2']['previous_data']['data_to_process'] = array(
                '#type'             => 'textarea',
                '#title'            => 'Данные, считанные из файла ' . $zp_input_data['catalog_filename'] . ' в соответствием с заданием (расписанием) и затем обработанные (результат см. ниже)',
                '#default_value'    => print_r($data_to_process, TRUE), //$string,
                '#description'      => t('Принято в обработку ' . $count_processed . ' строк из '. $count_whole . ' строк (c ' . $zp_preprocess_data['start_num_string'] . ' по ' . $zp_preprocess_data['stop_num_string'] .  '), указанных в задании (из них пустых ' . ($count_whole - $count_processed) .' строк не показаны и обрабатываться не будут)'),
            	);

            	
            	
            	
            	
            // выводим результаты работы
            
			$form['step2']['results_data'] = array(
                '#type' => 'fieldset',
                //'#title' => t('Step 2: Map CSV columns to Ubercart product data.'),
                '#title' => t('Результаты работы'),
                '#description' => t('Данные, обработанные программой из исходных файлов. Часть или полностью могут быть загружены в базу (в зависимости от наличия или отсутствия ошибок в данных)'),
                '#collapsible' => TRUE,
                '#collapsed' => FALSE,
            );            

            

            
   
             
            // выведем данные о выполненном задании, обновлённом расписанием 
            // (с учётом только что обработанных данных), исходных и выходных файлах и т.д.

  			 $form['step2']['results_data']['schedule'] = array(
                '#type' => 'fieldset',
                '#collapsible' => TRUE,
                '#collapsed' => TRUE,
                '#title' => t('Данные об исходных, выходных файлах и выполненном задании')
            );

  			$source_files = 'Главный файл с описанием файлов с исходными данными: ' . $zp_preprocess_data['zp_shop_input_data'] . '
  			
' . 'Расписание задач: ' . $zp_preprocess_data['zp_schedule_file'] . '
' . 'Ранее выполненные задачи (отчёт): ' . $zp_preprocess_data['zp_schedule_report'] . '
' . 'Исходные табличные данные для загрузки в базу данных: ' . $zp_input_data['catalog_filename'] . '

';		

  			// если загрузка не первая из этого файла, то уже известно название выходного файла с обработанной таблицей
  			if($zp_preprocess_data['processed_catalog_filename'])
  			  $source_files = $source_files . 'Файл с успешно обработанными табличными данными (в него записан результат работы): ' . $zp_preprocess_data['processed_catalog_filename'] . '_out.csv

';

  			if($zp_preprocess_data['processed_catalog_filename_errors'])
  			  $source_files = $source_files . 'Файл с описанием ошибок или замечаний, возникших при обработке табличных данных (по каждому элементу): ' . $zp_preprocess_data['processed_catalog_filename_errors'];
  			
  			$form['step2']['results_data']['schedule']['source_and_result_files'] = array(
                '#type'             => 'textarea',
                '#title'            => 'Файлы с исходными и выходными данными (исходные данные считаны из файла' . $zp_preprocess_data['zp_shop_input_data'] . ')',
                '#default_value'    => $source_files,
                //'#description'      => t('Принято в обработку ' . $count_processed . ' строк из '. $count_whole . ' строк (c ' . $zp_preprocess_data['start_num_string'] . ' по ' . $zp_preprocess_data['stop_num_string'] .  '), указанных в задании (из них пустых ' . ($count_whole - $count_processed) .' строк не показаны и обрабатываться не будут)'),
            	);
            	
            
  			 /*
            $all_scheduled_tasks = '';	
            foreach($zp_preprocess_data['scheduled_tasks'] as $scheduled_task)
             $all_scheduled_tasks = $all_scheduled_tasks . '
' . $scheduled_task;
            
            $form['step2']['results_data']['schedule']['scheduled_task'] = array(
                '#type'             => 'textarea',
                '#title'            => 'Все задачи из файла с расписанием задач ' . $zp_preprocess_data['zp_schedule_file'],
                '#default_value'    => $all_scheduled_tasks,
                '#description'      => t('Часть задач уже может быть выполнена'),
            	);
  			
            $all_reported_tasks = '';	
            foreach($zp_preprocess_data['reported_tasks'] as $reported_task)
             $all_reported_tasks = $all_reported_tasks . '
' . $reported_task;

            
             $form['step2']['results_data']['schedule']['reported_task'] = array(
                '#type'             => 'textarea',
                '#title'            => 'Все задачи из файла с расписанием задач ' . $zp_preprocess_data['zp_schedule_report'],
                '#default_value'    => $all_reported_tasks,
                '#description'      => t('Эти задачи уже выполняться не будут'),
            	);
             */
             
  			if($zp_preprocess_data['inverse'] == 'yes')
  			 $process_order = ', инвертированный порядок обработки строк (с конца в начало), полезно при удалении элементов';
  			 
            $form['step2']['results_data']['schedule']['current_task'] = array(
                '#type'             => 'textarea',
                '#title'            => 'Выполненная (текущая) задача (строки из файла ' . $zp_input_data['catalog_filename'] . '), готовая к обработке',
                '#default_value'    => 'Строки ' . $zp_preprocess_data['current_task'] . ' из исходной таблицы' . $process_order,
                '#description'      => t('Задача выбрана из расписания задач ' . $zp_preprocess_data['zp_schedule_file'] . ', с учётом уже выполненных задач (по данным из файла отчёта' . $zp_preprocess_data['zp_schedule_report'] . ')'),
            	);
  			 
            

            	
            	
            	           
            	 
            
            // выведем все обработанные табличные данные		  
			$string = '';
			$count_whole = 0;
  			$count_processed = 0;
  			
  			if(is_array($zp_catalog_processed))
  			{
  				foreach($zp_catalog_processed as $values)
  				{
  					$count_whole++;
  					if(trim($values['Действие / результат']) == '>>')
  				  		continue;
  				  
  					$count_processed++;
   					if(is_array($values))
  					foreach($values as $value)
     			   		$string = $string . ' > ' . $value;
     				$string = $string . '

';
 			    	//echo 'данные для обработки =  ' .  $string  .'<br>';
				}
			
				
				
				
				
				
				// все обработанные табличные данные в форме массива
				if(is_array($zp_catalog_processed))
				foreach ($zp_catalog_processed as $key => $value) 
				{
					if(trim($value['Тип записи']) == '')
						continue;
					
					if($value['Тип записи'] == 'подотдел' OR $value['Тип записи'] == 'подгруппа')
						$all_result_elements[$key . '-' . $value['Действие / результат'] . '-' . $value['Название сокращённое']] = $zp_catalog_processed[$key];	
						//$all_result_elements[$key . '-' . $data_to_process[$key]['Действие / результат'] . '-' . $value['Название сокращённое']] = $zp_catalog_processed[$key];	// $data_to_process[$key] используется потому, что поле с действием после успешной обработки очищается, а его желательно запомнить, чтобы было понятнее
					else
						$all_result_elements[$key . '-' . $value['Действие / результат'] . '-' . $value['Название']] = $zp_catalog_processed[$key];
						//$all_result_elements[$key . '-' . $data_to_process[$key]['Действие / результат'] . '-' . $value['Название']] = $zp_catalog_processed[$key]; // $data_to_process[$key] используется потому, что поле с действием после успешной обработки очищается, а его желательно запомнить, чтобы было понятнее
					
				}
			
				// успешно обработанные и проблемные элементы в форме массивов
				if(is_array($all_result_elements))
				foreach ($all_result_elements as $key => $value) 
				{
					if(trim($value['Действие / результат']) != '')
						$problem_result_elements['Ошибка: ' . $key] =  $all_result_elements[$key];
					else 
					if(trim($value['Предупреждения']) != '')
						$problem_result_elements['Предупреждение: ' . $key] =  $all_result_elements[$key];
					else
						$success_result_elements[$key] =  $all_result_elements[$key];
				}
			
				

				
				
				
				
	  		} // end of if(is_array($zp_catalog_processed))
			
            
			if($string)
			  $string = $fields_string . $string;	
			else 
			  $string = 'Не обработано ни одного элемента';
			
            $form['step2']['results_data']['processed_data_all'] = array(
                '#type'             => 'textarea',
                '#title'            => 'Все обработанные табличные данные, считанные из файла ' . $zp_input_data['catalog_filename'] . ' в соответствии с заданием (расписанием)',
                '#default_value'    => print_r($all_result_elements, TRUE), //$string,
                '#description'      => t('Обработано ' . $count_processed . ' строк из '. $count_whole . ' строк (c ' . $zp_preprocess_data['start_num_string'] . ' по ' . $zp_preprocess_data['stop_num_string'] .  '), указанных в задании (из них пустых ' . ($count_whole - $count_processed) .' строк не показаны и не обрабатывались)'),
            	);
            
            	
            	
            		
  			// выведем обработанные табличные данные, внесённые в базу, в которых не возникло ошибок или замечаний/предупреждений
			$string = '';
			$count_whole = 0;
  			$count_processed = 0;
  			if(is_array($zp_catalog_processed))
  			foreach($zp_catalog_processed as $values)
  			{
  				$count_whole++;
  				if(trim($values['Действие / результат']) != '')
  				  continue;
  				  
  				$count_processed++;
   				if(is_array($values))
  				foreach($values as $value)
     			   $string = $string . ' > ' . $value;
     			$string = $string . '

';
 			    //echo 'данные для обработки =  ' .  $string  .'<br>';
			}            	
            
			if($string)
			  $string = $fields_string . $string;	
			else 
			  $string = 'Нет элементов, успешно обработанных и внесённых в базу';
            	
            $form['step2']['results_data']['processed_data_ok'] = array(
                '#type'             => 'textarea',
                '#title'            => 'Успешно обработанные (без ошибок и предупреждений) табличные данные, считанные из файла ' . $zp_input_data['catalog_filename'] . ' в соответствии с заданием (расписанием) и записанные в выходной файл ' . $zp_preprocess_data['processed_catalog_filename'] . '_out.csv',
                '#default_value'    => print_r($success_result_elements, TRUE), //$string,
                '#description'      => t('Показаны только те данные (из общего количества, показанного в предыдущей таблице), при обработке которых не возникло проблем или замечаний. Успешно обработано ' . $count_processed . ' строк из '. $count_whole . ' строк'),
            	);            	
            	
            	
            	
			// выведем обработанные табличные данные, НЕ внесённые в базу, в которых возникли ошибки или замечания/предупреждений
			$string = '';
			$count_whole = 0;
  			$count_processed = 0;
  			foreach($zp_catalog_processed as $values)
  			{
  				$count_whole++;
  				if(trim($values['Действие / результат']) == '' OR trim($values['Действие / результат']) == '>>')
  				  continue;
  				  
  				$count_processed++;
   				foreach($values as $value)
     			   $string = $string . ' > ' . $value;
     			$string = $string . '

';
 			    //echo 'данные для обработки =  ' .  $string  .'<br>';
			}            	
			
			if($string)
			  $string = $fields_string . $string;	
			else 
			  $string = 'Нет элементов, при обработке которых возникли проблемы или замечания';
			
			if($zp_preprocess_data['processed_catalog_filename_errors'])
			  $errors = ' (записаны в файл ' . $zp_preprocess_data['processed_catalog_filename_errors'] . ')';
            	
            $form['step2']['results_data']['processed_data_not_ok'] = array(
                '#type'             => 'textarea',
                '#title'            => 'Табличные данные, при обработке которых возникли ошибки или предупреждения' . $errors ,
                '#default_value'    => print_r($problem_result_elements, TRUE), //$string,
                '#description'      => t('Показаны только те данные (из общего количества, показанного в предыдущей таблице), при обработке которых возникли проблемы или замечания. Из них ' . $count_processed . ' элементов (обработанных строк) из '. $count_whole . ' строк общего количества обработанных данных, которые вызвали остановку программы.'),
            	);                   	
            	
            	
            	
            	
            	
            	
              	
            
            /*
			
            $form['csvfile'] = array(
                '#type' => 'hidden',
                '#value' => $csv_file
            );
            
            */
           
            /*
            $form['delimiter'] = array(
                '#type' => 'hidden',
                '#value' => $values['delimiter']
            );
            */


            // заменяем кнопку Submit на ссылку на первую начальную страницу загрузки
            $form['step2']['reload'] = array(
			  	'#type' => 'item',
  				//'#title' => l(t('Загрузить следующее задание'), 'admin/store/products/import/zp_shop_import', array('title' => t('Загрузить следующее задание'))),
  				'#value' => l(t('Загрузить следующее задание'), 'admin/store/products/import/zp_shop_import', array('title' => t('Загрузить следующее задание'))),
  				'#prefix' => '<strong>',
  				'#suffix' => '</strong>', 
				);
				
			/*	
			// кнопка  Submit
    		$form['submit'] = array(
        		'#type' => 'submit',
        		'#value' => t('Загрузить следующее задание')
        	);
        	*/
			
        	$new_import = 1;

            break;




            
        case 3:     // STEP 3
              $form['save_report_csv'] = array(
                '#type' => 'hidden',
                '#value' => $values['save_report_csv']
            );

            $form['step3'] = array(
                '#type' => 'fieldset',
                '#title' => t('Step 3: Map CSV columns to Ubercart product data.'),
                '#description' => t('For each column in the CSV listed bellow select what it maps to on a Product. Items with a * after their name mus be mapped to something.')
            );


            // кнопка  Submit
            $form['submit'] = array(
            '#type' => 'submit',
            '#value' => t('Save results or New Import')
            );
            
            
			/*
            $tmp = variable_get('save_report_csv', $form_values['save_report_csv']);
            //drupal_set_message("save_report_csv = $tmp", 'error');
            if($tmp == 'Save')
               $new_import = 4; //значит слеждующий шаг - на первое (начальное) окно импорта
            else 
              */
              $new_import = 1;

            break;

            
            


        case 4:     // STEP 4

            $form['step4'] = array(
                '#type' => 'fieldset',
                '#title' => t('Step 4: Map CSV columns to Ubercart product data.'),
                '#description' => t('For each column in the CSV listed bellow select what it maps to on a Product. Items with a * after their name mus be mapped to something.')
            );


            /*
            
			//$output_i_results = '"Title";"Snippet";"Link";"Type","Author","Date","Comments","Attachments","Score"'."\n".'2"Title","Snippet","Link","Type","Author","Date","Comments","Attachments","Score"';
            $output_i_results = variable_get('output_i_results_var', $output_i_results);
			drupal_set_message("r_t_f = $output_i_results", 'error');
			$output_i_results = utf8_win($output_i_results);
			drupal_set_message("r_t_f = $output_i_results", 'error');
			// если пользователь на первом экране указал производить запись результатов импорта в файл
            // и если есть, что записывать в файл (были добавления новых продуктов или их изменения), делаем это
			//if(0)
			if ($output_i_results != '' AND $form_values['save_report_csv'] == 'Save')
  			  {
   		 	    if($file = file_save_data($output_i_results, file_directory_temp() ."/product_import_results_" . date("MjS_H-i") . ".csv", FILE_EXISTS_REPLACE))
			      {
       				//drupal_set_message(print_r($file, true));
       				file_transfer($file, array(
         			'Content-Type: text/x-comma-seperated-values', //application/xml',
         			'Content-Disposition: attachment; filename="'. $file .'"',));
     	          }
  			  }
  			  			  
  			*/
  			  
            $new_import = 1; //значит слеждующий шаг - на первое (начальное) окно импорта

            break;
           
            

    } // end of switch($step)

    
    return $form;
}











// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// Validate handler for form ID 'zp_shop_import_multiform'.

function zp_shop_import_multiform_validate($form_id, $form_values, $form)
{
	
	global $fields;
	global $reported_tasks;
	global $scheduled_tasks; 
	global $zp_input_data;
	global $zp_input_data_commented;
	global $zp_catalog; 
	global $zp_catalog_processed;
	global $zp_preprocess_data;
	
	/*

    if(isset($form_values['step']))
    {
        $step = $form_values['step'] - 1;

        switch($step)
        {
            case 1:

                if($File = file_check_upload('csvfile'))
                {
                    variable_set('zp_shop_import_filename', $File->filepath);
                    //form_set_value($form['csvfile'], $File->filepath);    // not working??
                    form_set_value($form['csvfile_path'], $File->filepath);

                    drupal_set_message('Got file: '.$File->filename.' (on server: '.$File->filepath.')');
                    echo 'Got file: '.$File->filename.' (on server: '.$File->filepath.')';
                }
                else
                {
                    //form_set_error('csvfile', 'Problem uploading CSV file. Could not proceed to next step.');
                }

                variable_set('uc_importer_handle_duplicates', $form_values['handle_duplicates']);
                variable_set('save_report_csv', $form_values['save_report_csv']);

                break;


            default:
                break;
        }
    }
    else
        form_set_error('step', 'Can not determine process step number?');
        
        
  */        
}











// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// основная функция обработки файла с таблицей ----------------------------------------

function zp_shop_import_multiform_submit($form_id, $form_values)
{
	global $fields;
	global $reported_tasks;
	global $scheduled_tasks; 
	global $zp_input_data;
	global $zp_input_data_commented;
	global $zp_catalog; 
	global $zp_catalog_processed;
	global $zp_preprocess_data;
	
	
	
   // отключим вывод ошибок
   //@error_reporting(0);
  
	
   // Have all the data, time to process it...
   if(intval($form_values['step']) != 3)
     return;

   //drupal_set_message('Step 3: File handling starts...', 'error'); // просто контрольная точка
	//echo 'step = ' . intval($form_values['step']) . '<br>';
   
   
   //global $user; // для доступа к данных о текущем юзере

        
// Единожды для всех строк (продуктов) в выбранном файле выполняем различные действия, в том числе, уcтанавливаем различные переменные

   //$delimiter = zp_shop_import_get_delimiter($form_values['delimiter']);
   //$csvfile_name = $form_values['csvfile'];

   
   //echo 'delimiter =  ' . $delimiter . '<br>';

   
   /*
   //эту функцию для возможности использования транслитерации pathauto вызовем один раз в начале функции
   _pathauto_include();
   // инициализируем данные для возможности транслитерации, с использованием pathauto
   static $i18n_loaded = false;
   static $translations = array();
   if (!$i18n_loaded)
    {
 	 $path = drupal_get_path('module', 'pathauto');
	 if (is_file($path. '/i18n-ascii.txt'))
	   {
	     $translations = parse_ini_file($path. '/i18n-ascii.txt');
       }
           $i18n_loaded = true;
    }
   $pattern = '/[^a-zA-Z0-9]/'; // символы, которые останутся в строке (имени файла, например) после фильтрации
   $separator = ''; // этим будут заменены остальные символы в строке... Пустота "" означает, что лишние символы просто будут удалены

   $r_t_f = "No:;Product_name;Artikul_postavki;Proizvoditel;Artikul_proizv;Bar;Gorod->Magazin->Otdel(s);Artikul_zp;Action;Notice;Price;Kol-vo;Kartinki;" . "\n";

   */ 
      
      
// Перебираем последовательно все строки файла, пока файл не закончится
//-------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------

  
  // zp_load_data_from_files();

  
    



//--------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------
// окончание функции

   //drupal_set_message("Processed $row_count rows of the CSV file $csvfile_name.");
   //drupal_set_message($product_created_count.' products created.');
   //drupal_set_message($product_updated_count.' products updated.');

   //$r_t_f = '1"Title";"Snippet";"Link";"Type","Author","Date","Comments","Attachments","Score"'."\n".'2"Title","Snippet","Link","Type","Author","Date","Comments","Attachments","Score"';
   //$output_i_results = $r_t_f;
   //variable_set('output_i_results_var', $output_i_results);

   // обнуляем кэш, иначе данные на сайте не обновятся! Делаем это единожды в конце функии!
   //db_query("TRUNCATE TABLE {cache_content}");
   return;
}











// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// начало обработки данных из файлов ------------------------------------------------------------

function zp_process_loaded_data()
{
//--------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------  
// начало обработки данных------------------------------------------------------------
  

	
	global $fields;
	global $reported_tasks;
	global $scheduled_tasks; 
	global $zp_input_data;
	global $zp_input_data_commented;
	global $zp_catalog; 
	global $zp_catalog_processed;
	global $zp_preprocess_data;



  //echo 'zp_process_loaded_data' . '<br>';


  
  if($zp_preprocess_data['inverse'] == 'yes')
  {
  	for($i = count($zp_catalog) - 1; $i >= 0; $i--)
  	{
  		//echo 'обратный порядок)))))) элемент № ' . $i . ', поле с номером ' . $zp_catalog[$i]['#'] . '<br>';
  		
  		// если в поле Действие не указано действие, пропустить этот элемент и добавить его в список обработанных элементов
  		if(!$zp_catalog[$i]['Действие / результат'] OR $zp_catalog[$i]['Действие / результат'] == '' OR $zp_catalog[$i]['Действие / результат'] == '>>')
  	  		$zp_catalog_processed[] = $zp_catalog[$i];
  		else 
  		{ 
  	  		$result = zp_process_shop_item($zp_catalog[$i]);
  	  		$zp_catalog_processed[] = $result;
  	  
  	  		if($result['Действие / результат'] != '' AND $result['Действие / результат'] != ' ')
  	  			break; // выходим из цикла, если наткнулись на ошибку
  		} 
  	}
  	
  }
  else
  {
   foreach($zp_catalog as $shop_item)
	{
  		//echo 'прямой порядок)))))) элемент № ' . $i . ', поле с номером ' . $zp_catalog[$i]['#'] . '<br>';
  	
   		// если в поле Действие не указано действие, пропустить этот элемент и добавить его в список обработанных элементов
  		if(!$shop_item['Действие / результат'] OR $shop_item['Действие / результат'] == '' OR $shop_item['Действие / результат'] == '>>')
  	  	$zp_catalog_processed[] = $shop_item;
	  	else 
  		{ 
    
  			//echo '<PRE>';
	  		//print_r($shop_item);
  			//echo '</PRE>';
  		
	  	  $result = zp_process_shop_item($shop_item);
  		  $zp_catalog_processed[] = $result;
  	  
	  	  if($result['Действие / результат'] != '' AND $result['Действие / результат'] != ' ')
  		  	break; // выходим из цикла, если наткнулись на ошибку
  		} 
	}
   
   	// тест, убрать эту строку
 	//$zp_catalog_processed =  $zp_catalog;
   
  }

	
  
  	
    
 	// переписываем алиас с помощью транслита pathauto
	// для этого сначала удаляем существующий алиас,
	// а потом запускаем функцию node_pathauto_bulkupdate, которая создаёт алиасы для всех нодов, к которых нет алиасов
	
	//db_query("DELETE FROM {url_alias}  WHERE src = '%s'", 'node/'.$nid);
	//db_query("DELETE FROM {url_alias}  WHERE src = '%s'", 'node/'.$nid.'/edit');

	//для возможности вызова node_pathauto_bulkupdate один раз вначале текущей функции вызываем _pathauto_include();
	_pathauto_include();
	node_pathauto_bulkupdate();
  
  
  
  
  
  
  
  // Clear the cache so an anonymous poster can see the node being added or updated.
  //cache_clear_all();		
  zp_clear_cache_drupal();
  
  //print '<PRE>';
  //print_r($zp_catalog_processed);
  //print '</PRE>';

  
  // записать результаты в файлы обработанных данных и отметки заданий-----------------------
  
  zp_write_results($zp_catalog_processed,
                    $fields, 
                    $zp_input_data, 
                    $zp_input_data_commented, 
                    $zp_preprocess_data['start_num_string'],
                    $zp_preprocess_data['stop_num_string'], 
                    $zp_preprocess_data['real_stop_num_string']);

   
   
   
   return 0; // 0 = нет ошибок

}









// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// функция-коллектор обработки элементов магазина ---------------------------------------

function zp_process_shop_item($shop_item)
{
	
	switch ($shop_item['Действие / результат'])
	{
		case 'new':
			if($shop_item['Тип записи'] == 'производитель' OR $shop_item['Тип записи'] == 'поставщик')
				$shop_item = zp_item_new_mc($shop_item);
			else 
				$shop_item = zp_item_new($shop_item);
			break;
			
		case 'change':
			if($shop_item['Тип записи'] == 'производитель' OR $shop_item['Тип записи'] == 'поставщик')
				$shop_item = zp_item_change_mc($shop_item);
			else 
				$shop_item = zp_item_change($shop_item);
			break;
		
			
		case 'delete':
			if($shop_item['Тип записи'] == 'производитель' OR $shop_item['Тип записи'] == 'поставщик')
				$shop_item = zp_item_delete_mc($shop_item);
			else 
				$shop_item = zp_item_delete($shop_item);
			break;
				
		
		case 'hide':
			$shop_item = zp_item_hide_and_unhide($shop_item, 'hide');
			break;
			
			
		case 'unhide':
			//$shop_item = zp_item_hide_and_unhide($shop_item, 'unhide');
			break;
			
		
		default:
			break;	
	}

	return $shop_item;
}













// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// функция убирает в полученной строке дубликаты кавычек и кавычки по краям
function zp_correct_quotes($string)
{
	// проверим, нет ли в полученной строке дубликатов кавычек
	// и если есть, заменим две на одну, а одинарные (по краям) вообще уберём

	if(strpos($string, '""') !== FALSE)
	{

		$string = str_replace('""', '"', $string);
		
		if($string[0] = '"')
			$string[0] = ' ';
		
		$last = strlen($string) - 1;
		if($string[$last] = '"')
			$string[$last] = ' ';
			
		$string = trim($string);
	}

	return $string;
}
		 		





// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// функция восстанавливает в полученной строке дубликаты кавычек и кавычки по краям, 
// если изначально были такие дубликаты в строке
function zp_restore_quotes($string)
{
	// проверим, нет ли в полученной строке кавычек
	// и если есть, заменим одну на две и добавим по одной по краям
	 			
	
	if(strpos($string, '"') !== FALSE)
	{
		$string = str_replace('"', '""', $string);
		$string = '"' . $string . '"';
	}
			 			
	return $string;
}


















// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// функция изменения видимости элемента -------------------------------------------------

function zp_item_hide_and_unhide($shop_item, $action)
{
				// сбрасываем флаг действия
				$shop_item['Действие / результат'] = '';
				
				
	
				// создатим новый объект типа нода, в который будем заносить некоторые необходимые данные по элементу
				$node = new stdClass();
				// и вспомогательный объект $zp_element для прочих данных по элементу
				$zp_element = array();
				
				
				// если значение поля содержит тип (в формате "значение***тип"), выясняем этот тип
				//$value = $shop_item['Тип записи'];
				$zp_element['type'] = zp_correct_quotes($shop_item['Тип записи']);
				
				//echo ' >>> type = ' . $zp_element['type'] . ', type of type = ' . $zp_element['type_of_type'];
				
				$zp_element['type_of_type'] = strpos($zp_element['type'], '***');
  				if($zp_element['type_of_type'] !== false) 
  				{
				  $zp_element['type_of_type'] = explode('***', $zp_element['type']);
				  $zp_element['type'] = $zp_element['type_of_type'][0];
				  $zp_element['type_of_type'] = $zp_element['type_of_type'][1];
				} 
				
				//echo 'shop_item[Тип записи] = ' . $shop_item['Тип записи'] . ', value = ' . $value . ', value_type = ' . $zp_element['type_of_type'];
				
				// уберём в полученных строках дубликаты кавычек и кавычки по краям
		 		$zp_element['type'] = $zp_element['type'];
		 		$zp_element['type_of_type'] = $zp_element['type_of_type'];
		 		
		 		
	
				// если не задан тип элемента, выходим
				if(!$zp_element['type'] OR $zp_element['type'] == '' OR $zp_element['type'] == ' ')
				{
					$shop_item['Действие / результат'] = 'hide-unhide error: не указан тип элемента'; 
						return $shop_item;
				}
				
				//echo ' >>>2 type = ' . $zp_element['type'] . ', type of type = ' . $zp_element['type_of_type'];
				
				// правильно ли указан тип элемента?
				switch($zp_element['type'])
				{
					case 'страна':
					case 'населённый пункт':
					case 'район':
					case 'магазин':
					case 'подотдел':
					case 'товар': 
						break; 
						
					case 'подгруппа':
						$shop_item['Действие / результат'] = 'hide-unhide error: подгруппу нельзя скрыть или показать. Скрыть можно только реальные элементы (страна, город, район, магазин, подотдел, товар)'; 
						return $shop_item;
						
					default:
						$shop_item['Действие / результат'] = 'hide-unhide error: указан неизвестный или неправильный тип элемента'; 
						return $shop_item;
				}

							
				//echo ' >>>2 type = ' . $zp_element['type'] . ', type of type = ' . $zp_element['type_of_type'];
				
				
				/*
				// если не задан тип элемента, выходим
				if(!$zp_element['type'] == 'товар' AND (!$zp_element['type_of_type'] OR $zp_element['type_of_type'] == '' OR $zp_element['type_of_type'] == ' '))
				{
					$shop_item['Действие / результат'] = 'hide-unhide error: не указан тип товара';
						return $shop_item;
				}
				*/
				
				//echo ' >>>2 type = ' . $zp_element['type'] . ', type of type = ' . $zp_element['type_of_type'];
				
				
				// проверим, есть ли какие-либо изменения в элементе
				$changes_exists = 0;
				$shop_item_changed = array();
				foreach ($shop_item as $key => $value)
				{
					//echo '---key = ' . $key . ', value = ' . $value . '<br>';
					
					// исправим лишние кавычки, если есть
					$value = zp_correct_quotes($value);
					
					/* // на всякий случай все поля добавляем в промежуточный массив... всё равно лишние поля не обрабатываются...
					
					// данные по артикулу не добавляем в промежуточный массив
				    if($key == 'Страна' OR
					   $key == 'Город' OR
					   $key == 'Район' OR
					   $key == 'Магазин' OR
					   $key == 'Подотдел' OR
					   //$key == 'Подгруппа / тип элемента' OR  // это поле используется не только при изменении артикулов, поэтому его тоже добавляем в общий массив
					   $key == 'Товар / родительский подотдел'
					  )
					continue; 
					*/

				//echo ' >>> key = ' . $key . ', value = ' . $value . '<br>';
					
					
					if($value[0] . $value[1] . $value[2] == '###')
					{	
						$shop_item_changed[$key] = $value;
						//echo '---shop_item_changed[key] = ' . $shop_item_changed[$key] . ', where key = ' . $key;
		  				$changes_exists = 1;
		  				
		  				// пометим, были ли изменения в артикуле и связях
					}
				}
					
				//echo ' >>>2 type = ' . $zp_element['type'] . ', type of type = ' . $zp_element['type_of_type'];
				
				// если изменений нет, выходим
				if($changes_exists)
				{
					$shop_item['Действие / результат'] = 'hide-unhide error: элемент содержит указания к изменению в некоторых полях. Сначала очистите указания к изменениям, а затем показывайте или прячьте элемент элемент';
						return $shop_item;
				}
				
				
				//echo ' >>>2 type = ' . $zp_element['type'] . ', type of type = ' . $zp_element['type_of_type'];

				
				
				
				//echo '_zp_element[type] = ' . $zp_element['type'] . '<br>';
				
				
				
				$artikul_changes_exists = 0;
				$new_value_with_history = array();
				
				// перебираем все поля из артикула и выясним текущие значения номеров артикула
				foreach ($shop_item as $key => $value)
				{
					// работаем только с полями артикула
					if($key != 'Страна' AND
					   $key != 'Город' AND
					   $key != 'Район' AND
					   $key != 'Магазин' AND
					   $key != 'Подотдел' AND
					   $key != 'Подгруппа / тип элемента' AND
					   $key != 'Товар / родительский подотдел'
					  )
					continue;
					
					
					// исправим лишние кавычки, если есть
					$value = zp_correct_quotes($value);
				
					
		 			if(strpos($value, '###') !== FALSE) // управляющие символы в середине строки
		 			{
		 				$value = explode('###', $value);
		   	
			
						//$value_old = $value[1];
						$value = $value[0];
						$value_old = $value;
						
						//echo ' hist --- key = ' . $key . ', new value = ' . $value . ', old value = ' . $value_old . '<br>';
						
		 			}
		 			else 
		 			{
		 				$value_old = $value;
		 			}
		 		
		 			
		 			
		 			// уберём в полученной строке дубликаты кавычек и кавычки по краям
		 			// и сохраним в массив 
		 			
		 			$zp_new_artikuls[$key] = $value;
		 			$zp_old_artikuls[$key] = $value_old;
		 			
		 			//if(!$zp_old_artikuls[$key])
		 			  //$zp_old_artikuls[$key] = $zp_new_artikuls[$key]; // если старое значение в истории не задано (например в виде ###однозначение), приравниваем старое значение к новому значению
					
		 			
				} // end of foreach ($shop_item as $key => $value) // перебираем все поля из артикула  и выясним новые и старые значения номеров артикула
				
				
				//echo '_zp_element[type] = ' . $zp_element['type'] . '<br>';
				/*
				foreach($zp_new_artikuls as $key => $value)
				{
					
					echo ' <<<<<<< key = ' . $key . ', new value = ' . $value . '<br>';
					echo ' > old value = ' . $zp_old_artikuls[$key] . '<br>'; 
					//echo ' > value with history = ' . $new_value_with_history[$key] . '<br>'; 
				}
				*/
				
				//echo ' >>>key = ' . $key . ', value = ' . $value . ', art_changed = ' . $artikul_changes_exists . '<br>';				
				
				//echo '_zp_element[type] = ' . $zp_element['type'] . '<br>';
				
				// выясним название элемента, (пока старое, если необходимы изменения)

				// исправим лишние кавычки, если есть
				$value = zp_correct_quotes($shop_item['Название']);
					
				
		 		if(strpos($value, '###') !== FALSE) // управляющие символы в середине строки
		 		{
		 			$value = explode('###', $value);
					$value = $value[0];
		 		}

		 			
		 		//echo '_zp_element[type] = ' . $zp_element['type'] . '<br>';
		 		
				$zp_element['название'] = $value;
					
				//if(!$zp_element['старое_название'])
				 //$zp_element['старое_название'] = $zp_element['новое_название']; // если в таблице не задано старое название, приравниваем его новому
				
				
				//echo ' ===new name = ' . $zp_element['название'] . ', history value = ';				

				//echo '_zp_element[type] = ' . $zp_element['type'];
				
								
				
				

				
				// Определим артикулы для элементов разных типов и их стрые и новые (если заданы) родительские артикулы
				// а также зададим некоторые основные переменные и значения
				switch($zp_element['type'])
				{
					case 'страна':
						
						// если заданы не все составляющие артикула места (и, соответственно, местоположения места)
						// выходим из подпрограммы с указанием ошибки в поле "действие / результат"
						if(!$zp_old_artikuls['Страна'])
						 {
						 	$shop_item['Действие / результат'] = 'hide-unhide error: неправильно указан исходный артикул страны'; 
							return $shop_item;
						 }
						
						// выясним старый и новый артикулы страны
						$zp_element['zp_artikul'] = 'z' . $zp_new_artikuls['Страна']; 
					
						//$node->type = 'c_country';						
						
						//$zp_element['pics_field'] = 'country_img';
						//$zp_element['каталог_с_картинками'] = 'country_img';
						
						break;	
						
						
					case 'населённый пункт': // обычно город
					
						if(!$zp_old_artikuls['Страна'] OR !$zp_old_artikuls['Город'])
						 {
						 	$shop_item['Действие / результат'] = 'hide-unhide error: неправильно указан исходный артикул населённого пункта' ; 
							return $shop_item;
						 }
				
	
						// выясним старый и новый артикулы города
						$zp_element['zp_artikul'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город']; 
								
						// выясним новый и старый артикулы родительской страны
						//$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна']; 

						
						//$node->type = 'c_city';
						
						//$zp_element['pics_field'] = 'city_img';
						//$zp_element['каталог_с_картинками'] = 'city_img';
						
						break;
						
						
					case 'район':
						
						if(!$zp_old_artikuls['Страна'] OR !$zp_old_artikuls['Город'] OR !$zp_old_artikuls['Район'])
						 {
						 	$shop_item['Действие / результат'] = 'hide-unhide error: неправильно указан исходный артикул района' ; 
							return $shop_item;
						 }
						
						// выясним старый и новый артикулы района
						$zp_element['zp_artikul'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район']; 
								
						// выясним новый и старый артикулы родительского города
						//$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город']; 
						
						//$node->type = 'c_rajon';
						
						//$zp_element['pics_field'] = 'rajon_img';
						//$zp_element['каталог_с_картинками'] = 'rajon_img';
						
						break;
						
					
					case 'магазин':
						
						if(!$zp_old_artikuls['Страна'] OR !$zp_old_artikuls['Город'] OR !$zp_old_artikuls['Район'] OR !$zp_old_artikuls['Магазин'])
						 {
						 	$shop_item['Действие / результат'] = 'hide-unhide error: неправильно указан исходный артикул магазина' ; 
							return $shop_item;
						 }
						
						// выясним старый и новый артикулы магазина
						$zp_element['zp_artikul'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин']; 
							
						// выясним новый и старый артикулы родительского района 
						//$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район']; 
						
						//$node->type = 'c_shop';
						
						//$zp_element['pics_field'] = 'shop_img';
						//$zp_element['каталог_с_картинками'] = 'shop_img';
						
						break;
						
						
					case 'подотдел':
								
						
						if(!$zp_old_artikuls['Страна'] OR !$zp_old_artikuls['Город'] OR !$zp_old_artikuls['Район'] OR !$zp_old_artikuls['Магазин'] OR !$zp_old_artikuls['Подотдел'] OR !$zp_old_artikuls['Товар / родительский подотдел'])
						 {
						 	$shop_item['Действие / результат'] = 'hide-unhide error: неправильно указан исходный артикул подотдела' ; 
							return $shop_item;
						 }
						
						// выясним старый и новый артикулы подотдела
						$zp_element['zp_artikul'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин'] . $zp_new_artikuls['Подотдел']; 
								
						
						//if($zp_new_artikuls['Товар / родительский подотдел'] == '000')
							//$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин']; 
						//else
							//$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин'] . $zp_new_artikuls['Товар / родительский подотдел']; 

						
						//$zp_element['родительский подотдел'] = $zp_new_artikuls['Товар / родительский подотдел']; // проверить, где используется эта переменная и нужна ли она вообще
						
						//$node->type = 'c_department';
						
						//$zp_element['pics_field'] = 'dept_img';
						//$zp_element['каталог_с_картинками'] = 'dept_img';
							
						break;
						
						
					case 'подгруппа':	

						
						break;		
						
					
					case 'товар':
						
						if(!$zp_old_artikuls['Страна'] OR !$zp_old_artikuls['Город'] OR !$zp_old_artikuls['Район'] OR !$zp_old_artikuls['Магазин'] OR !$zp_old_artikuls['Подотдел'] OR !$zp_old_artikuls['Подгруппа / тип элемента'] OR !$zp_old_artikuls['Товар / родительский подотдел'])
						 {
						 	$shop_item['Действие / результат'] = 'hide-unhide error: не заданы какие-то из номеров местоположения и товара для формирования внутреннего артикула zp'; 
							return $shop_item;
						 }
						 

						// выясним старый и новый артикулы товара
						$zp_element['zp_artikul'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин'] . $zp_new_artikuls['Подотдел'] . $zp_new_artikuls['Товар / родительский подотдел']; 
						
						$node->model = $zp_element['zp_artikul']; // заранее установим новый артикул, так как на следующем шаге будет произведено изменение артикула, если оно задано в таблице
								
						// выясним новый и старый артикулы родительского отдела 
						//$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин'] . $zp_new_artikuls['Подотдел']; 

						
						// то же самое, но по-другому называется... для совместимости.. вроде где-то дальше используется такая переменная
						// задаём сразу новые значения, так как они будут изменены на следующем шаге
						//$zp_element['parent_otdel_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин'] . $zp_new_artikuls['Подотдел'];
						
						/*
						// в зависимости от типа товара (который указан через *** от слова "товар") зададим типа ноды для товара
						switch($zp_element['type_of_type'])
						{
							case 'продукты':
								$node->type = 'product_food';
								//$zp_element['pics_field'] = 'p_food_img';
								$zp_element['каталог_с_картинками'] = 'p_food_img';
								break;	
								
							case 'вещи':
								$node->type = 'product_clothes';
								//$zp_element['pics_field'] = 'p_clothes_img';
								$zp_element['каталог_с_картинками'] = 'p_clothes_img';
								
								break;
									
							default:
								// иначе тип товара не определён в системе
								$shop_item['Действие / результат'] = 'del error: тип продукта ' . $zp_element['type_of_type'] . ' не определён в системе';
								return $shop_item;
								
						} // end of в зависимости от типа товара (который указан через *** от слова "товар") зададим типа ноды для товара
						*/
						
						break;		
					
									

					default:
						break;
					
				}
				
				
				
				// определим нид и некоторые другие данные текущего элемента, в зависимости от его типа
				switch($zp_element['type'])
				{
					case 'страна':
					case 'населённый пункт': // обычно город
					case 'район':
					case 'магазин':
					case 'подотдел':
					
						// определим нид текущего элемента по старому артикулу
						//$element_nid = db_result(db_query("SELECT nid from {content_field_zp_art_place} WHERE field_zp_art_place_value = '%s'", $zp_element['zp_old_artikul']));
					
						$element_nid = db_fetch_object(db_query("SELECT nid, vid from {content_field_zp_art_place} WHERE field_zp_art_place_value = '%s'", $zp_element['zp_artikul']));
						
						$node->vid = $element_nid->vid; 
						$node->nid = $element_nid->nid;
						 
						//echo '------------- node->vid = ' . $node->vid . ', node->nid = ' . $node->nid . '<br>';
						
						
						
						if(!$node->nid OR !$node->vid)
						{
							$shop_item['Действие / результат'] = 'hide-unhide error: ошибка при чтении базы данных или нет элемента с таким артикулом ' . $zp_element['zp_artikul'] . ' в базе'; 
							return $shop_item;
						}
						
						
						$element_nid = $element_nid->nid;
						
						/*
						
						// определим тид текущего элемента
						$element_tids = taxonomy_node_get_terms_by_vocabulary($element_nid, 1);
   						foreach($element_tids as $element_tid)
    					{
     						$element_tid_name = $element_tid->name;
     						$element_tid = $element_tid->tid;
    					}
    					*/
    					
    					//echo '------------- element_tid = ' . $element_tid . '<br>';
						
    					
						break;	
					
						
					case 'подгруппа':

											
						break;
						
						
						
						
					case 'товар':	
						
						
						$element_nid = db_fetch_object(db_query("SELECT nid, vid from {uc_products} WHERE model = '%s'", $zp_element['zp_artikul']));
						
						$node->vid = $element_nid->vid; 
						$node->nid = $element_nid->nid;
						 
						if(!$node->nid OR !$node->vid)
						{
							$shop_item['Действие / результат'] = 'hide-unhide error: ошибка при чтении базы данных или нет товара с таким артикулом ' . $zp_element['zp_artikul'] . ' в базе'; 
							return $shop_item;
						}
						
						$element_nid = $element_nid->nid;
									
						break;
						
						
					default:
						break;	
				
				}
				
				
				
				
				
				
				
				// на данном этапе изместно, что элемент есть
				
				//echo '<br>Можно изменять видимость элемента!<br>';
				
				switch($zp_element['type'])
				{

					case 'страна':
					case 'населённый пункт': // обычно город
					case 'район':
					case 'магазин':
					case 'подотдел':
					case 'товар':
					
						if($action == 'hide')
						{
							// проверим, а не спрятан ли уже этот элемент (судя по таблице)
							//if($shop_item['статус_элемента'] == 'hidden')
							
							// или лучше судя по базе
							//if(db_result(db_query("SELECT status from {node} WHERE nid = %d", $element_nid)) != 1)
							if(db_result(db_query("SELECT field_status_value FROM {content_field_status} WHERE nid = %d", $element_nid)) == 'hidden')
							{
								$shop_item['Действие / результат'] = 'hide-unhide error: элемент с таким артикулом ' . $zp_element['zp_artikul'] . ' и так уже спрятан.'; 
								return $shop_item;
							}
							
							
							// изменяем статус_элемента в базе
							//db_query("UPDATE {node} SET status = %d WHERE nid = %d", 0, $element_nid);
							db_query("UPDATE {content_field_status} SET field_status_value = '%s' WHERE nid = %d", 'hidden', $element_nid);
							
							
							// прячем пункт меню, связанный с этим элементом
							
							// вясним номер тида из каталога, связанный с этим элементом
							$element_tids = taxonomy_node_get_terms_by_vocabulary($element_nid, 1);
   							foreach($element_tids as $element_tid)
    						{
     							//$element_tid_name = $element_tid->name;
     							$element_tid = $element_tid->tid;
    						}
    						
    						// временно изменим тид на тид+0000
							$new_tid = $element_tid . '0000';
							db_query("UPDATE {term_data} SET tid = %d WHERE tid = %d", $new_tid, $element_tid);
							
							
							// привяжем к этому новому тиду текущий нид (чтобы не потерять номер тида и потом его восстановить)
							db_query("UPDATE {term_node} SET tid = %d WHERE tid = %d AND nid = %d ", $new_tid, $element_tid, $element_nid);
							
							// покажем, что элемент спрятан
							//$shop_item['статус_элемента'] = 'hidden';
							
						}	
						else if($action == 'unhide')
						{
							// проверим, а не показан ли уже этот элемент (судя по таблице)
							//if($shop_item['статус_элемента'] != 'hidden')
							
							// или лучше судя по базе
							//if(db_result(db_query("SELECT status from {node} WHERE nid = %d", $element_nid)) == 1)
							if(db_result(db_query("SELECT field_status_value FROM {content_field_status} WHERE nid = %d", $element_nid)) != 'hidden')
							{
								$shop_item['Действие / результат'] = 'hide-unhide error: элемент с таким артикулом ' . $zp_element['zp_artikul'] . ' и так не спрятан.'; 
								return $shop_item;
							}
							
							// изменяем статус_элемента в базе
							//db_query("UPDATE {node} SET status = %d WHERE nid = %d", 1, $element_nid);
							db_query("UPDATE {content_field_status} SET field_status_value = '%s' WHERE nid = %d", 'normal', $element_nid);
							
							// восстанавливаем пункт меню, связанный с этим элементом
							
							// вясним номер тида из каталога, связанный с этим элементом
							$element_tids = taxonomy_node_get_terms_by_vocabulary($element_nid, 1);
   							foreach($element_tids as $element_tid)
    						{
     							$element_tid_name = $element_tid->name;
     							$element_tid = $element_tid->tid;
    						}
    						
							// восстановим оригинальное значение тида, которое в изменённом виде сейчас должно иметь вид в базе "исходный тид+0000"
    						// вычислим длину и уберём последние четыре символа
							$lenght = strlen($element_tid);
							for($count = 1; $count <= ($lenght - 4); $count++ )
							{
								$new_tid = $new_tid . $element_tid[$count-1]; // $count-1 потому, что нумерация в массиве идёт от нуля, а количество символов массива считаем от единицы
						    }
						    
						    // запишем в базу восстановленный тид
						    db_query("UPDATE {term_data} SET tid = %d WHERE tid = %d", $new_tid, $element_tid);
							
							
							// привяжем к этому восстановленному тиду текущий нид
							db_query("UPDATE {term_node} SET tid = %d WHERE tid = %d AND nid = %d ", $new_tid, $element_tid, $element_nid);
							

							
							// укажем в поле в таблице, что элемент имеет обычный статус normal
							$shop_item['статус_элемента'] = 'normal';
						}
		
						break;
	  		  
					default: 
						break;
				}
				
				
				
				

	
	//echo '<br>Изменение видимости элемента произведено произведено успешно!<br>';

	
	return $shop_item;
				
}				

























// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// функция удаления элемента ------------------------------------------------------------

function zp_item_delete($shop_item)
{
				// сбрасываем флаг действия
				$shop_item['Действие / результат'] = '';
				
				
	
				// создатим новый объект типа нода, в который будем заносить некоторые необходимые данные по элементу
				$node = new stdClass();
				// и вспомогательный объект $zp_element для прочих данных по элементу
				$zp_element = array();
				
				
				// если значение поля содержит тип (в формате "значение***тип"), выясняем этот тип
				//$value = $shop_item['Тип записи'];
				$zp_element['type'] = zp_correct_quotes($shop_item['Тип записи']);
				
				//echo ' >>> type = ' . $zp_element['type'] . ', type of type = ' . $zp_element['type_of_type'];
				
				$zp_element['type_of_type'] = strpos($zp_element['type'], '***');
  				if($zp_element['type_of_type'] !== false) 
  				{
				  $zp_element['type_of_type'] = explode('***', $zp_element['type']);
				  $zp_element['type'] = $zp_element['type_of_type'][0];
				  $zp_element['type_of_type'] = $zp_element['type_of_type'][1];
				} 
				
				//echo 'shop_item[Тип записи] = ' . $shop_item['Тип записи'] . ', value = ' . $value . ', value_type = ' . $zp_element['type_of_type'];
				
				// уберём в полученных строках дубликаты кавычек и кавычки по краям
		 		$zp_element['type'] = $zp_element['type'];
		 		$zp_element['type_of_type'] = $zp_element['type_of_type'];
		 		
		 		
	
				// если не задан тип элемента, выходим
				if(!$zp_element['type'] OR $zp_element['type'] == '' OR $zp_element['type'] == ' ')
				{
					$shop_item['Действие / результат'] = 'del error: не указан тип элемента'; 
						return $shop_item;
				}
				
				//echo ' >>>2 type = ' . $zp_element['type'] . ', type of type = ' . $zp_element['type_of_type'];
				
				// правильно ли указан тип элемента?
				switch($zp_element['type'])
				{
					case 'страна':
					case 'населённый пункт':
					case 'район':
					case 'магазин':
					case 'подотдел':
					case 'подгруппа':
					case 'товар': 
						break; 
						
					default:
						$shop_item['Действие / результат'] = 'del error: указан неизвестный или неправильный тип элемента'; 
						return $shop_item;
				}

							
				//echo ' >>>2 type = ' . $zp_element['type'] . ', type of type = ' . $zp_element['type_of_type'];
				
				// если не задан тип элемента, выходим
				if(!$zp_element['type'] == 'товар' AND (!$zp_element['type_of_type'] OR $zp_element['type_of_type'] == '' OR $zp_element['type_of_type'] == ' '))
				{
					$shop_item['Действие / результат'] = 'del error: не указан тип товара';
						return $shop_item;
				}
				
				//echo ' >>>2 type = ' . $zp_element['type'] . ', type of type = ' . $zp_element['type_of_type'];
				
				
				// проверим, есть ли какие-либо изменения в элементе
				$changes_exists = 0;
				$shop_item_changed = array();
				foreach ($shop_item as $key => $value)
				{
					//echo '---key = ' . $key . ', value = ' . $value . '<br>';
					
					// исправим лишние кавычки, если есть
					$value = zp_correct_quotes($value);
					
					/* // на всякий случай все поля добавляем в промежуточный массив... всё равно лишние поля не обрабатываются...
					
					// данные по артикулу не добавляем в промежуточный массив
				    if($key == 'Страна' OR
					   $key == 'Город' OR
					   $key == 'Район' OR
					   $key == 'Магазин' OR
					   $key == 'Подотдел' OR
					   //$key == 'Подгруппа / тип элемента' OR  // это поле используется не только при изменении артикулов, поэтому его тоже добавляем в общий массив
					   $key == 'Товар / родительский подотдел'
					  )
					continue; 
					*/

	
					
					if($value[0] . $value[1] . $value[2] == '###')
					{	
						$shop_item_changed[$key] = $value;
						//echo '---shop_item_changed[key] = ' . $shop_item_changed[$key] . ', where key = ' . $key;
		  				$changes_exists = 1;
		  				
		  				// пометим, были ли изменения в артикуле и связях
					}
				}
					

				// если указаны изменения, выходим
				if($changes_exists)
				{
					$shop_item['Действие / результат'] = 'del error: элемент содержит указания к изменению в некоторых полях. Сначала очистите указания к изменениям, а затем удаляйте элемент';
						return $shop_item;
				}
				
				

				
				$artikul_changes_exists = 0;
				$new_value_with_history = array();
				
				// перебираем все поля из артикула и выясним текущие значения номеров артикула
				foreach ($shop_item as $key => $value)
				{
					// работаем только с полями артикула
					if($key != 'Страна' AND
					   $key != 'Город' AND
					   $key != 'Район' AND
					   $key != 'Магазин' AND
					   $key != 'Подотдел' AND
					   $key != 'Подгруппа / тип элемента' AND
					   $key != 'Товар / родительский подотдел'
					  )
					continue;
					
					
					// исправим лишние кавычки, если есть
					$value = zp_correct_quotes($value);
				
					
		 			if(strpos($value, '###') !== FALSE) // управляющие символы в середине строки
		 			{
		 				$value = explode('###', $value);
		   	
						//$value_old = $value[1];
						$value = $value[0];
						$value_old = $value;

		 			}
		 			else 
		 			{
		 				$value_old = $value;
		 			}
		 		
		 			
		 			
		 			// уберём в полученной строке дубликаты кавычек и кавычки по краям
		 			// и сохраним в массив 
		 			
		 			$zp_new_artikuls[$key] = $value;
		 			$zp_old_artikuls[$key] = $value_old;
		 			
		 			//if(!$zp_old_artikuls[$key])
		 			  //$zp_old_artikuls[$key] = $zp_new_artikuls[$key]; // если старое значение в истории не задано (например в виде ###однозначение), приравниваем старое значение к новому значению
					
		 			
				} // end of foreach ($shop_item as $key => $value) // перебираем все поля из артикула  и выясним новые и старые значения номеров артикула
				
				
				
				/*
				foreach($zp_new_artikuls as $key => $value)
				{
					
					echo ' <<<<<<< key = ' . $key . ', new value = ' . $value . '<br>';
					echo ' > old value = ' . $zp_old_artikuls[$key] . '<br>'; 
					//echo ' > value with history = ' . $new_value_with_history[$key] . '<br>'; 
				}
				*/
				

				// выясним название элемента, (пока старое, если необходимы изменения)

				// исправим лишние кавычки, если есть
				if($shop_item['Подгруппа / тип элемента'] == 'подотдел' OR $shop_item['Подгруппа / тип элемента'] == 'подгруппа')
			    	$value = zp_correct_quotes($shop_item['Название сокращённое']);
			    else
					$value = zp_correct_quotes($shop_item['Название']);
					
				
		 		if(strpos($value, '###') !== FALSE) // управляющие символы в середине строки
		 		{
		 			$value = explode('###', $value);
					$value = $value[0];
		 		}


				$zp_element['название'] = $value;
					
				//if(!$zp_element['старое_название'])
				 //$zp_element['старое_название'] = $zp_element['новое_название']; // если в таблице не задано старое название, приравниваем его новому
				

				
				// Определим артикулы для элементов разных типов и их стрые и новые (если заданы) родительские артикулы
				// а также зададим некоторые основные переменные и значения
				switch($zp_element['type'])
				{
					case 'страна':
						
						// если заданы не все составляющие артикула места (и, соответственно, местоположения места)
						// выходим из подпрограммы с указанием ошибки в поле "действие / результат"
						if(!$zp_old_artikuls['Страна'])
						 {
						 	$shop_item['Действие / результат'] = 'del error: неправильно указан исходный артикул страны'; 
							return $shop_item;
						 }
						
						// выясним старый и новый артикулы страны
						$zp_element['zp_artikul'] = 'z' . $zp_new_artikuls['Страна']; 
					
						break;	
						
						
					case 'населённый пункт': // обычно город
					
						if(!$zp_old_artikuls['Страна'] OR !$zp_old_artikuls['Город'])
						 {
						 	$shop_item['Действие / результат'] = 'del error: неправильно указан исходный артикул населённого пункта' ; 
							return $shop_item;
						 }
				
	
						// выясним старый и новый артикулы города
						$zp_element['zp_artikul'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город']; 
								
						// выясним новый и старый артикулы родительской страны
						$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна']; 

						break;
						
						
					case 'район':
						
						if(!$zp_old_artikuls['Страна'] OR !$zp_old_artikuls['Город'] OR !$zp_old_artikuls['Район'])
						 {
						 	$shop_item['Действие / результат'] = 'del error: неправильно указан исходный артикул района' ; 
							return $shop_item;
						 }
						
						// выясним старый и новый артикулы района
						$zp_element['zp_artikul'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район']; 
								
						// выясним новый и старый артикулы родительского города
						$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город']; 
						
						break;
						
					
					case 'магазин':
						
						if(!$zp_old_artikuls['Страна'] OR !$zp_old_artikuls['Город'] OR !$zp_old_artikuls['Район'] OR !$zp_old_artikuls['Магазин'])
						 {
						 	$shop_item['Действие / результат'] = 'del error: неправильно указан исходный артикул магазина' ; 
							return $shop_item;
						 }
						
						// выясним старый и новый артикулы магазина
						$zp_element['zp_artikul'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин']; 
							
						// выясним новый и старый артикулы родительского района 
						$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район']; 
						
						break;
						
						
					case 'подотдел':
								
						
						if(!$zp_old_artikuls['Страна'] OR !$zp_old_artikuls['Город'] OR !$zp_old_artikuls['Район'] OR !$zp_old_artikuls['Магазин'] OR !$zp_old_artikuls['Подотдел'] OR !$zp_old_artikuls['Товар / родительский подотдел'])
						 {
						 	$shop_item['Действие / результат'] = 'del error: неправильно указан исходный артикул подотдела' ; 
							return $shop_item;
						 }
						
						// выясним старый и новый артикулы подотдела
						$zp_element['zp_artikul'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин'] . $zp_new_artikuls['Подотдел']; 
								
						
						if($zp_new_artikuls['Товар / родительский подотдел'] == '000')
							$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин']; 
						else
							$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин'] . $zp_new_artikuls['Товар / родительский подотдел']; 

						
						$zp_element['родительский подотдел'] = $zp_new_artikuls['Товар / родительский подотдел']; // проверить, где используется эта переменная и нужна ли она вообще
						
	
						break;
						
						
					case 'подгруппа':	
						
						//echo 'Страна = ' . $zp_old_artikuls['Страна'] . '<br>'; 
						//echo 'Город = ' . $zp_old_artikuls['Город'] . '<br>'; 
						//echo 'Район = ' . $zp_old_artikuls['Район'] . '<br>'; 
						//echo 'Магазин = ' . $zp_old_artikuls['Магазин'] . '<br>'; 
						//echo 'Подотдел = ' . $zp_old_artikuls['Подотдел'] . '<br>'; 
						//echo 'старое название = ' . $zp_element['старое_название'] . '<br>';
						
						//return;

						
						//show($zp_element);
						//show($zp_old_artikuls);
						
						if(!$zp_old_artikuls['Страна'] OR !$zp_old_artikuls['Город'] OR !$zp_old_artikuls['Район'] OR !$zp_old_artikuls['Магазин'] OR !$zp_old_artikuls['Подотдел'] OR !$zp_element['название'])
						 {
						 	$shop_item['Действие / результат'] = 'del error: неправильно указан исходный артикул и/или название подгруппы'; 
							return $shop_item;
						 }	
						
						// выясним новый и старый артикулы родительского отдела 
						$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин'] . $zp_new_artikuls['Подотдел']; 
						
						break;		
						
					
					case 'товар':
						
						if(!$zp_old_artikuls['Страна'] OR !$zp_old_artikuls['Город'] OR !$zp_old_artikuls['Район'] OR !$zp_old_artikuls['Магазин'] OR !$zp_old_artikuls['Подотдел'] OR !$zp_old_artikuls['Подгруппа / тип элемента'] OR !$zp_old_artikuls['Товар / родительский подотдел'])
						 {
						 	$shop_item['Действие / результат'] = 'del error: не заданы какие-то из номеров местоположения и товара для формирования внутреннего артикула zp'; 
							return $shop_item;
						 }
						 

						// выясним старый и новый артикулы товара
						$zp_element['zp_artikul'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин'] . $zp_new_artikuls['Подотдел'] . $zp_new_artikuls['Товар / родительский подотдел']; 
						
						$node->model = $zp_element['zp_artikul']; // заранее установим новый артикул, так как на следующем шаге будет произведено изменение артикула, если оно задано в таблице
								
						// выясним новый и старый артикулы родительского отдела 
						$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин'] . $zp_new_artikuls['Подотдел']; 

						
						// то же самое, но по-другому называется... для совместимости.. вроде где-то дальше используется такая переменная
						// задаём сразу новые значения, так как они будут изменены на следующем шаге
						$zp_element['parent_otdel_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин'] . $zp_new_artikuls['Подотдел'];
						

						break;		
					
									

					default:
						break;
					
				}
				
				
				
				// определим нид и некоторые другие данные текущего элемента, в зависимости от его типа
				switch($zp_element['type'])
				{
					case 'страна':
					case 'населённый пункт': // обычно город
					case 'район':
					case 'магазин':
					case 'подотдел':
					
						// определим нид текущего элемента по старому артикулу
						//$element_nid = db_result(db_query("SELECT nid from {content_field_zp_art_place} WHERE field_zp_art_place_value = '%s'", $zp_element['zp_old_artikul']));
					
						$element_nid = db_fetch_object(db_query("SELECT nid, vid from {content_field_zp_art_place} WHERE field_zp_art_place_value = '%s'", $zp_element['zp_artikul']));
						
						$node->vid = $element_nid->vid; 
						$node->nid = $element_nid->nid;
						
						
						if(!$node->nid OR !$node->vid)
						{
							$shop_item['Действие / результат'] = 'del error: ошибка при чтении базы данных или нет элемента с таким артикулом ' . $zp_element['zp_artikul'] . ' в базе'; 
							return $shop_item;
						}
						
						$element_nid = $element_nid->nid;
						
						
						
						// определим тид текущего элемента
						$element_tids = taxonomy_node_get_terms_by_vocabulary($element_nid, 1);
   						foreach($element_tids as $element_tid)
    					{
     						$element_tid_name = $element_tid->name;
     						$element_tid = $element_tid->tid;
    					}
    					
    					
    					// если тид текущего элемента имеет в качестве родителя хоть один другой тид (и, соответственно, нода), то значит элемент имеет потомков, значит её удалять нельзя
						if($child_tid = db_result(db_query("SELECT tid from {term_hierarchy} WHERE parent = %d", $element_tid)))
						{
							$shop_item['Действие / результат'] = 'del error: у данного элемента с названием ' . $zp_element['название'] . ' содержатся другие элементы, поэтому удаление данного элемента невозможно. Сначала освободите элемент от элементов, находяшихся в нём.'; 
							return $shop_item;
						}
    					
						break;	
					
						
					case 'подгруппа':

						// определим нид текущего (старого) родительского отдела
						$parent_otdel_nid = db_fetch_object(db_query("SELECT nid, vid from {content_field_zp_art_place} WHERE field_zp_art_place_value = '%s'", $zp_element['parent_zp_art']));
						
						$parent_otdel_vid = $parent_otdel_nid->vid; 
						$parent_otdel_nid = $parent_otdel_nid->nid;
						 
						if(!$parent_otdel_nid OR !$parent_otdel_vid)
						{
							$shop_item['Действие / результат'] = 'del error: ошибка при чтении базы данных или нет подотдела (заданного как родитель удаляемой подгруппы) с таким артикулом ' . $zp_element['parent_zp_art'] . ' в базе'; 
							return $shop_item;
						}
						
						


	  		  			$parent_otdel_name = db_result(db_query("SELECT title from {node} WHERE nid = %d", $parent_otdel_nid));
									
						// определим тид текущего  родительского отдела
						$parent_otdel_tids = taxonomy_node_get_terms_by_vocabulary($parent_otdel_nid, 1);
   						foreach($parent_otdel_tids as $parent_otdel_tid)
    					{
     						$parent_otdel_tid_name = $parent_otdel_tid->name;
     						$parent_otdel_tid = $parent_otdel_tid->tid;
    					}

    					// найдём всех потомков текущего (старого) родительского отдела, у которых нет своих детей, т.е., найдём все подгруппы родительского отдела, если он их имеет
    					// и среди них найдём потомка с названием текущей подгруппы и возьмём его тид
						$parent_otdel_tid_children = taxonomy_get_children($parent_otdel_tid, 1, 'name'); // taxonomy_get_children($tid, $vid = 0, $key = 'tid');
						$current_podgruppa_tid = FALSE;
						foreach($parent_otdel_tid_children as $child_name => $child_values)
						{
							if(taxonomy_get_children($child_values->tid, 1, 'name'))
								continue; // если потомок имеет своих потомков, значит это не подгруппа, а подотдел-потомок, а нам нужна группа!
									
									  		
							if($child_name == $zp_element['название'])
							{
								$current_podgruppa_tid = $child_values->tid;
								$current_podgruppa_tid_name = $child_values->name;
								break;
							}
						}
								
						// если в текущем родительском отделе нет такой подгруппы, которую нужно удалить
						if(!$current_podgruppa_tid)
						{
							$shop_item['Действие / результат'] = 'del error: в базе в данном отделе с артикулом -' . $zp_element['zp_artikul'] . '- и названием -' . $parent_otdel_name . '- нет подгруппы с названием ' . $zp_element['название'] . ', у которой вы пытаетесь изменить артикул'; 
							return $shop_item;
						}
									
						// если тид текущей подгруппы имеет хоть одна нода (этой нодой может быть только товар), то значит подгруппа имеет потомков, значит её изменять нельзя
						if($child_nid = db_result(db_query("SELECT nid from {term_node} WHERE tid = %d", $current_podgruppa_tid)))
						{
							$shop_item['Действие / результат'] = 'del error: в данной подгруппе с названием ' . $zp_element['название'] . ' содержатся товары, поэтому удаление подгруппы невозможно. Сначала освободите подгруппу от товаров.'; 
							return $shop_item;
						}
						
						
						break;
						
						
						
						
					case 'товар':	
						
						// найдём тид самого элемента по старому артикулу
						$element_nid = db_fetch_object(db_query("SELECT nid, vid from {uc_products} WHERE model = '%s'", $zp_element['zp_artikul']));
						
						$node->vid = $element_nid->vid; 
						$node->nid = $element_nid->nid;
						 
						if(!$node->nid OR !$node->vid)
						{
							$shop_item['Действие / результат'] = 'del error: ошибка при чтении базы данных или нет товара с таким артикулом ' . $zp_element['zp_artikul'] . ' в базе'; 
							return $shop_item;
						}
						
						$element_nid = $element_nid->nid;
									
						break;
						
						
					default:
						break;	
				
				}
				

				
				
				
				// на данном этапе изместно, что элемент есть, у него нет потомков, его можно удалить.
				
				//echo '<br>Можно удалять!<br>';
				
				switch($zp_element['type'])
				{

					case 'страна':
					case 'населённый пункт': // обычно город
					case 'район':
					case 'магазин':
					case 'подотдел':
					case 'товар':
						
						//node_delete($node->nid);
						
						$node_to_del = node_load($node->nid);

  						//if (node_access('delete', $node)) 
  						//{
    						db_query('DELETE FROM {node} WHERE nid = %d', $node_to_del->nid);
    						db_query('DELETE FROM {node_revisions} WHERE nid = %d', $node_to_del->nid);

    						// Call the node-specific callback (if any):
    						node_invoke($node_to_del, 'delete');
    						node_invoke_nodeapi($node_to_del, 'delete');

    						// Clear the cache so an anonymous poster can see the node being deleted.
    						// кеш очищаем в основной функции после обновлении всех нодов
    						// cache_clear_all();

						    // Remove this node from the search index if needed.
    						if (function_exists('search_wipe')) 
    						{
      							search_wipe($node_to_del->nid, 'node');
    						}
    						
    						//drupal_set_message(t('%title has been deleted.', array('%title' => $node->title)));
    						
    						watchdog('content', t('@type: deleted %title.', array('@type' => t($node_to_del->type), '%title' => $node_to_del->title)));
  						//}

						

						
						break;
	  		  
					default: 
						break;
				}
				
				
				
				
				switch($zp_element['type'])
				{

					case 'страна':
					case 'населённый пункт': // обычно город
					case 'район':
					case 'магазин':
					case 'подотдел':

						// удаляем элемент и его терм
						db_query('DELETE FROM {term_data} WHERE tid = %d', $element_tid);
						db_query('DELETE FROM {term_hierarchy} WHERE tid = %d', $element_tid);
						
						break;
			
						
						
					case 'подгруппа':

						// удаляем только терм подгруппы (а больше ничего и нет у подгруппы)
						db_query('DELETE FROM {term_data} WHERE tid = %d', $current_podgruppa_tid);
						db_query('DELETE FROM {term_hierarchy} WHERE tid = %d', $current_podgruppa_tid);

						break;
						
						

					case 'товар':
						
						// удаляем товар и данные о количестве товара из соответствующей таблицы
						
						if( 
							db_result(db_query("SELECT nid from {uc_product_stock} WHERE nid = %d", $node_to_del->nid))
	  	  	  	  		  )
	  	  	  	  		  {
	  	  	  	  		  	if( 
			 					!(db_query('DELETE FROM {uc_product_stock} WHERE nid = %d', $node_to_del->nid))
		  	 			  	  )
		  	 			  	  {
		  						$shop_item['Действие / результат'] = 'del error: Ошибка при удалении данных о количестве товара.'; 
								return $shop_item;
		      			  	  }
	   	  	      		  }
				
						
						break;
						
						
	  		  
					default: 
						break;
				}
	

				
				
				
				
				
				// если для товара были заданы атрибуты, удалить их вместе с опциями
				switch($zp_element['type'])
				{

					case 'товар':
						
						
						/* // это не нужно делать, так как это делается автоматически при удалении ноды (node_invoke($node_to_del, 'delete'); node_invoke_nodeapi($node_to_del, 'delete');)
						
						// выясним, есть ли в базе какие-то атрибуты у этого элемента.. и удаляем все, если есть
						if( 
							db_result(db_query("SELECT aid from {uc_product_attributes} WHERE nid = %d", $node->nid))
	  	  	  	  		  )
	  	  	  	  		  {
	  	  	  	  		  	if( 
			 					!(db_query('DELETE FROM {uc_product_attributes} WHERE nid = %d', $node->nid))
		  	 			  	  )
		  	 			  	  {
		  						$shop_item['Действие / результат'] = 'del error: Возможно, не все данные по этому элементу удалены. Ошибка при удалении атрибутов элемента'; 
								return $shop_item;
		      			  	  }
	   	  	      		  }
				
	   	  	      		// выясним, есть ли в базе какие-то опции атрибутов у этого элемента.. и удаляем все, если есть
						if( 
							db_result(db_query("SELECT oid from {uc_product_options} WHERE nid = %d", $node->nid))
	  	  	  	  		  )
	  	  	  	  		  {
	  	  	  	  		  	if( 
			 					!(db_query('DELETE FROM {uc_product_options} WHERE nid = %d', $node->nid))
		  	 			  	  )
		  	 			  	  {
		  						$shop_item['Действие / результат'] = 'del error: Возможно, не все данные по этому элементу удалены. Ошибка при удалении опций атрибутов элемента'; 
								return $shop_item;
		      			  	  }
	   	  	      		  } 

	   	  	      		  
	   	  	      		  */
	   	  	      		  
						break;
						
						
	  		  
					default: 
						break;
				}
				
				
				
				
				
				
				// если для элемента был задан алиас pathauto, удаляем его
				switch($zp_element['type'])
				{

					case 'страна':
					case 'населённый пункт': // обычно город
					case 'район':
					case 'магазин':
					case 'подотдел':
					case 'товар':
						
			
						/* // это не нужно делать, так как это делается автоматически при удалении ноды (node_invoke($node_to_del, 'delete'); node_invoke_nodeapi($node_to_del, 'delete');)
						if( 
			 				db_result(db_query("SELECT pid from {url_alias} WHERE src = '%s'", 'node/' . $node->nid))
		  			  	  )
		  			  	  {
							if( 
			 					!(db_query("DELETE FROM {url_alias} WHERE src = '%s'", 'node/' . $node->nid))
			 					  OR
			 					!(db_query("DELETE FROM {url_alias} WHERE src = '%s'", 'node/' . $node->nid . '/feed'))
		  	  			  	  )
		  	  			  	  {
		  						$shop_item['Действие / результат'] = 'del error: Не все данные удалены. Ошибка при удалении алиасов pathauto'; 
								return $shop_item;
		      			  	  }

		  			  	  } 
		  			  	  
		  			  	  */
						
						break;
						
						
	  		  
					default: 
						break;
				}
				
	
				
	
	//echo '<br>Удаление произведено успешно!<br>';
	
	$shop_item['статус_элемента'] = 'deleted';
	
	return $shop_item;
				
}				














// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// функция удаления контрагента (производителя или поставщика)

function zp_item_delete_mc($shop_item)
{
				// сбрасываем флаг действия
				$shop_item['Действие / результат'] = '';


				// проверим, есть ли какие-либо изменения в элементе
				$changes_exists = 0;
				$shop_item_changed = array();
				foreach ($shop_item as $key => $value)
				{
					
					// исправим лишние кавычки, если есть
					$value = zp_correct_quotes($value);
					
					if($value[0] . $value[1] . $value[2] == '###')
					{	
						$shop_item_changed[$key] = $value;
		  				$changes_exists = 1;
		  				
		  				// пометим, были ли изменения в артикуле и связях
					}
				}
					
				// если изменения есть, выходим
				if($changes_exists)
				{
					$shop_item['Действие / результат'] = 'del error: элемент содержит флаги изменений в некоторых элементах. Сначала очистите эти флаги изменений.'; 
						return $shop_item;
				}
				
				
					
				
				// и вспомогательный объект $zp_element для прочих данных по элементу
				$zp_element = array();
				
				$new_value_with_history = array();
				
				
				
				// выясним внутренний артикул zp mc элемента

				$value = zp_correct_quotes($shop_item['Внутренний артикул ZP MC']);
					
				$name_changed = FALSE;
		 		if(strpos($value, '###') !== FALSE) // управляющие символы в середине строки
		 		{
		 			$value = explode('###', $value);
					$value = $value[0];
					$value_old = $value;
					
		 		}
		 		else 
		 		{
		 			$value_old = $value;
		 		}
		 		
				$zp_element['артикул_zp_mc'] = $value;
				
				if(!$zp_element['артикул_zp_mc'] OR trim($zp_element['артикул_zp_mc']) == '')
				{
					$shop_item['Действие / результат'] = 'del error: не задан новый zp mc артикул'; // 
					return $shop_item;
				}
				
				

				
				
				
				// получим из базы nid исходного элемента

				
				if(!($element_nid = db_result(db_query("SELECT nid FROM {content_type_mc_descr} WHERE field_zp_mc_artikul_value = '%s'", $zp_element['артикул_zp_mc']))))
				{
					$shop_item['Действие / результат'] = 'change error: ошибка при чтении базы данных или нет элемента с таким артикулом ' . $zp_element['артикул_zp_mc'] . ' в базе'; 
					return $shop_item;
				}

			
				
				
				
				
// на данном этапе изместно, что элемент есть, у него нет потомков, его можно удалить.

						
				$node_to_del = node_load($element_nid);

				db_query('DELETE FROM {node} WHERE nid = %d', $node_to_del->nid);
				db_query('DELETE FROM {node_revisions} WHERE nid = %d', $node_to_del->nid);

				// Call the node-specific callback (if any):
				node_invoke($node_to_del, 'delete');
				node_invoke_nodeapi($node_to_del, 'delete');

				// Clear the cache so an anonymous poster can see the node being deleted.
				// кеш очищаем в основной функции после обновлении всех нодов
    			// cache_clear_all();

			    // Remove this node from the search index if needed.
    			if (function_exists('search_wipe')) 
    			{
      				search_wipe($node_to_del->nid, 'node');
    			}
    						
    			//drupal_set_message(t('%title has been deleted.', array('%title' => $node->title)));
    						
    			watchdog('content', t('@type: deleted %title.', array('@type' => t($node_to_del->type), '%title' => $node_to_del->title)));

				
				
			
				
				
			
				
	
	//echo '<br>Удаление произведено успешно!<br>';
	
	$shop_item['статус_элемента'] = 'deleted';
	
	return $shop_item;
				
}				




















// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// функция изменения элемента в магазине (отдела, подгруппы, товара и т.д.)--------------

function zp_item_change($shop_item)
{
			
				
				// создатим новый объект типа нода, в который будем заносить некоторые необходимые данные по элементу
				$node = new stdClass();
				// и вспомогательный объект $zp_element для прочих данных по элементу
				$zp_element = array();
				
				
				// если значение поля содержит тип (в формате "значение***тип"), выясняем этот тип
				//$value = $shop_item['Тип записи'];
				$zp_element['type'] = zp_correct_quotes($shop_item['Тип записи']);
				
		
				$zp_element['type_of_type'] = strpos($zp_element['type'], '***');
  				if($zp_element['type_of_type'] !== false) 
  				{
				  $zp_element['type_of_type'] = explode('***', $zp_element['type']);
				  $zp_element['type'] = $zp_element['type_of_type'][0];
				  $zp_element['type_of_type'] = $zp_element['type_of_type'][1];
				} 
				
			
				// уберём в полученных строках дубликаты кавычек и кавычки по краям
		 		//$zp_element['type'] = $zp_element['type'];
		 		//$zp_element['type_of_type'] = $zp_element['type_of_type'];
		 		
		 		
	
				// если не задан тип элемента, выходим
				if(!$zp_element['type'] OR trim($zp_element['type']) == '')
				{
					$shop_item['Действие / результат'] = 'change error: не указан тип элемента'; 
						return $shop_item;
				}
				
			
				// правильно ли указан тип элемента?
				switch($zp_element['type'])
				{
					case 'страна':
					case 'населённый пункт':
					case 'район':
					case 'магазин':
					case 'подотдел':
					case 'подгруппа':
					case 'товар': 
						break; 
						
					default:
						$shop_item['Действие / результат'] = 'change error: указан неизвестный или неправильный тип элемента'; 
						return $shop_item;
				}

							
				
				// если не задан тип элемента, выходим
				if(!$zp_element['type'] == 'товар' AND (!$zp_element['type_of_type'] OR trim($zp_element['type_of_type']) == ''))
				{
					$shop_item['Действие / результат'] = 'change error: не указан тип товара';
						return $shop_item;
				}
				

				
				// проверим, есть ли какие-либо изменения в элементе
				$changes_exists = 0;
				$shop_item_changed = array();
				foreach ($shop_item as $key => $value)
				{				
					// исправим лишние кавычки, если есть
					$value = zp_correct_quotes($value);
					
					/* // на всякий случай все поля добавляем в промежуточный массив... всё равно лишние поля не обрабатываются...
					
					// данные по артикулу не добавляем в промежуточный массив
				    if($key == 'Страна' OR
					   $key == 'Город' OR
					   $key == 'Район' OR
					   $key == 'Магазин' OR
					   $key == 'Подотдел' OR
					   //$key == 'Подгруппа / тип элемента' OR  // это поле используется не только при изменении артикулов, поэтому его тоже добавляем в общий массив
					   $key == 'Товар / родительский подотдел'
					  )
					continue; 
					*/


					
					
					if($value[0] . $value[1] . $value[2] == '###')
					{	
						$shop_item_changed[$key] = $value;
						//echo '---shop_item_changed[key] = ' . $shop_item_changed[$key] . ', where key = ' . $key;
		  				$changes_exists = 1;
		  				
		  				// пометим, были ли изменения в артикуле и связях
					}
				}
					

				// если изменений нет, выходим
				if(!$changes_exists)
				{
					$shop_item['Действие / результат'] = 'change error: элемент не содержит изменений или неправильно указан признак изменения'; // сбрасываем флаг необходимости добавления элемента в базу	
						return $shop_item;
				}
				

				
				// изменяем артикулы и, соответственно, связи для разных типов элементов
				$artikul_changes_exists = 0;
				$new_value_with_history = array();
				
				// перебираем все поля из артикула и выясним новые и старые значения номеров артикула
				foreach ($shop_item as $key => $value)
				{
					// работаем только с полями артикула
					if($key != 'Страна' AND
					   $key != 'Город' AND
					   $key != 'Район' AND
					   $key != 'Магазин' AND
					   $key != 'Подотдел' AND
					   $key != 'Подгруппа / тип элемента' AND
					   $key != 'Товар / родительский подотдел'
					  )
					continue;
					
					
					// исправим лишние кавычки, если есть
					$value = zp_correct_quotes($value);

					//$new_value_with_history[$key] = FALSE;
					
					if($value[0] . $value[1] . $value[2] == '###') // управляющие символы в начале строки
		 			{
						$value = explode('###', $value);
		   	
						foreach($value as $k => $val)
						{
							if($k == 0 OR $k == 1)
		      	 		  		$new_value_with_history[$key] = $new_value_with_history[$key] . $val;
		    				else  
		      	 		  		$new_value_with_history[$key] = $new_value_with_history[$key] . '###' . $val;  
						} 
			
						$value_old = $value[2];
						$value = $value[1];
						
						$artikul_changes_exists = 1;  // значит какой-то из номеров артикула изменился
		 			}
		 			else if(strpos($value, '###') !== FALSE) // управляющие символы в середине строки
		 			{
		 				$value = explode('###', $value);
		   	
						foreach($value as $k => $val)
						{
							if($k == 0)
		      	 		 	 	$new_value_with_history[$key] = $new_value_with_history[$key] . $val;
		    				else  
		      	 		 	 	$new_value_with_history[$key] = $new_value_with_history[$key] . '###' . $val;  
						} 
			
						//$value_old = $value[1];
						$value = $value[0];
						$value_old = $value;
						
	
		 			}
		 			else 
		 			{
		 				$value_old = $value;
		 			}
		 		
		 			
		 			
		 			// уберём в полученной строке дубликаты кавычек и кавычки по краям
		 			// и сохраним в массив 
		 			
		 			$zp_new_artikuls[$key] = $value;
		 			$zp_old_artikuls[$key] = $value_old;
		 			
		 			//if(!$zp_old_artikuls[$key])
		 			  //$zp_old_artikuls[$key] = $zp_new_artikuls[$key]; // если старое значение в истории не задано (например в виде ###однозначение), приравниваем старое значение к новому значению
					
		 			
				} // end of foreach ($shop_item as $key => $value) // перебираем все поля из артикула  и выясним новые и старые значения номеров артикула
				

				/*
				foreach($zp_new_artikuls as $key => $value)
				{
					
					echo ' <<<<<<< key = ' . $key . ', new value = ' . $value . '<br>';
					echo ' > old value = ' . $zp_old_artikuls[$key] . '<br>'; 
					echo ' > value with history = ' . $new_value_with_history[$key] . '<br>'; 
				}
				*/

				
				// выясним название элемента, (пока старое, если необходимы изменения)

				// исправим лишние кавычки, если есть
				if($shop_item['Подгруппа / тип элемента'] == 'подотдел' OR $shop_item['Подгруппа / тип элемента'] == 'подгруппа')
			    	$value = zp_correct_quotes($shop_item['Название сокращённое']);
			    else
					$value = zp_correct_quotes($shop_item['Название']);
					
				$name_changed = FALSE;
				if($value[0] . $value[1] . $value[2] == '###') // управляющие символы в начале строки
		 		{
					$value = explode('###', $value);
		   	
					foreach($value as $k => $val)
					{
						if($k == 0 OR $k == 1)
		      		  		$new_value_with_history['Название'] = $new_value_with_history['Название'] . $val;
		    			else  
		      		  		$new_value_with_history['Название'] = $new_value_with_history['Название'] . '###' . $val;  
					} 
			
					
					$value_old = $value[2];
					$value = $value[1];
						
					$name_changed = 1;  // название изменилось
		 		}
		 		else if(strpos($value, '###') !== FALSE) // управляющие символы в середине строки
		 		{
		 			$value = explode('###', $value);
		   	
					foreach($value as $k => $val)
		 			{
						if($k == 0)
		      		 	 	$new_value_with_history['Название'] = $new_value_with_history['Название'] . $val;
		    			else  
		      		 	 	$new_value_with_history['Название'] = $new_value_with_history['Название'] . '###' . $val;  
					} 
			
					//$value_old = $value[1];
					$value = $value[0];
					$value_old = $value;
					
		 		}
		 		else 
		 		{
		 			$value_old = $value;
		 		}
		 			

		 		
				$zp_element['старое_название'] = $value_old;
				$zp_element['новое_название'] = $value;
					
				//if(!$zp_element['старое_название'])
				 //$zp_element['старое_название'] = $zp_element['новое_название']; // если в таблице не задано старое название, приравниваем его новому
				
				
				

				
				// Определим старые и новые (если заданы) артикулы для элементов разных типов и их стрые и новые (если заданы) родительские артикулы
				// а также зададим некоторые основные переменные и значения
				switch($zp_element['type'])
				{
					case 'страна':
						
						// если заданы не все составляющие артикула места (и, соответственно, местоположения места)
						// выходим из подпрограммы с указанием ошибки в поле "действие / результат"
						if(!$zp_old_artikuls['Страна'])
						 {
						 	$shop_item['Действие / результат'] = 'change error: неправильно указан исходный артикул страны'; 
							return $shop_item;
						 }
						
						// выясним старый и новый артикулы страны
						$zp_element['zp_old_artikul'] = 'z' . $zp_old_artikuls['Страна']; 
						$zp_element['zp_artikul'] = 'z' . $zp_new_artikuls['Страна']; 

						 
						 // задаём zp номер страны (зададим новый номер заранее)
						$zp_element['zp_number'] = $zp_new_artikuls['Страна'];
						
						$node->type = 'c_country';						

						break;	
						
						
						
					case 'населённый пункт': // обычно город
					
						if(!$zp_old_artikuls['Страна'] OR !$zp_old_artikuls['Город'])
						 {
						 	$shop_item['Действие / результат'] = 'change error: неправильно указан исходный артикул населённого пункта' ; 
							return $shop_item;
						 }
				
	
						// выясним старый и новый артикулы города
						$zp_element['zp_old_artikul'] = 'z' . $zp_old_artikuls['Страна'] . $zp_old_artikuls['Город']; 
						$zp_element['zp_artikul'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город']; 
								
						// выясним новый и старый артикулы родительской страны
						$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна']; 
						$zp_element['parent_zp_old_art'] = 'z' . $zp_old_artikuls['Страна']; 
						
						
						// задаём номер населённого пункта (внутри его страны)
						$zp_element['zp_number'] = $zp_new_artikuls['Город'];
						
						$node->type = 'c_city';
						

						break;
						
						
						
					case 'район':
						
						if(!$zp_old_artikuls['Страна'] OR !$zp_old_artikuls['Город'] OR !$zp_old_artikuls['Район'])
						 {
						 	$shop_item['Действие / результат'] = 'change error: неправильно указан исходный артикул района' ; 
							return $shop_item;
						 }
						
						// выясним старый и новый артикулы района
						$zp_element['zp_old_artikul'] = 'z' . $zp_old_artikuls['Страна'] . $zp_old_artikuls['Город'] . $zp_old_artikuls['Район']; 
						$zp_element['zp_artikul'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район']; 
								
						// выясним новый и старый артикулы родительского города
						$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город']; 
						$zp_element['parent_zp_old_art'] = 'z' . $zp_old_artikuls['Страна'] . $zp_old_artikuls['Город']; 
						
						
						// задаём номер района (внутри населённого пункта, города)
						$zp_element['zp_number'] = $zp_new_artikuls['Район'];
						
						$node->type = 'c_rajon';
						
						break;
						
						
					
					case 'магазин':
						
						if(!$zp_old_artikuls['Страна'] OR !$zp_old_artikuls['Город'] OR !$zp_old_artikuls['Район'] OR !$zp_old_artikuls['Магазин'])
						 {
						 	$shop_item['Действие / результат'] = 'change error: неправильно указан исходный артикул магазина' ; // сбрасываем флаг необходимости добавления элемента в базу	
							return $shop_item;
						 }
						
						// выясним старый и новый артикулы магазина
						$zp_element['zp_old_artikul'] = 'z' . $zp_old_artikuls['Страна'] . $zp_old_artikuls['Город'] . $zp_old_artikuls['Район'] . $zp_old_artikuls['Магазин']; 
						$zp_element['zp_artikul'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин']; 
							
						// выясним новый и старый артикулы родительского района 
						$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район']; 
						$zp_element['parent_zp_old_art'] = 'z' . $zp_old_artikuls['Страна'] . $zp_old_artikuls['Город'] . $zp_old_artikuls['Район']; 
						
												
						
						// задаём номер магазина (внутри внутри района)
						$zp_element['zp_number'] = $zp_new_artikuls['Магазин'];
						
						$node->type = 'c_shop';
						

						break;
						
						
						
					case 'подотдел':
								
						
						if(!$zp_old_artikuls['Страна'] OR !$zp_old_artikuls['Город'] OR !$zp_old_artikuls['Район'] OR !$zp_old_artikuls['Магазин'] OR !$zp_old_artikuls['Подотдел'] OR !$zp_old_artikuls['Товар / родительский подотдел'])
						 {
						 	$shop_item['Действие / результат'] = 'change error: неправильно указан исходный артикул подотдела' ; // сбрасываем флаг необходимости добавления элемента в базу	
							return $shop_item;
						 }
						
						// выясним старый и новый артикулы подотдела
						$zp_element['zp_old_artikul'] = 'z' . $zp_old_artikuls['Страна'] . $zp_old_artikuls['Город'] . $zp_old_artikuls['Район'] . $zp_old_artikuls['Магазин'] . $zp_old_artikuls['Подотдел']; 
						$zp_element['zp_artikul'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин'] . $zp_new_artikuls['Подотдел']; 
								
						// выясним новый и старый артикулы родительского подотдела/магазина 
						if($zp_old_artikuls['Товар / родительский подотдел'] == '000')
							$zp_element['parent_zp_old_art'] = 'z' . $zp_old_artikuls['Страна'] . $zp_old_artikuls['Город'] . $zp_old_artikuls['Район'] . $zp_old_artikuls['Магазин']; 
						else
							$zp_element['parent_zp_old_art'] = 'z' . $zp_old_artikuls['Страна'] . $zp_old_artikuls['Город'] . $zp_old_artikuls['Район'] . $zp_old_artikuls['Магазин'] . $zp_old_artikuls['Товар / родительский подотдел']; 
						
							
						if($zp_new_artikuls['Товар / родительский подотдел'] == '000')
							$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин']; 
						else
							$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин'] . $zp_new_artikuls['Товар / родительский подотдел']; 

							
						// задаём номер подотдела (внутри магазина)
						$zp_element['zp_number'] = $zp_new_artikuls['Подотдел'];
						
						$zp_element['родительский подотдел'] = $zp_new_artikuls['Товар / родительский подотдел']; // проверить, где используется эта переменная и нужна ли она вообще
						
						$node->type = 'c_department';
						

						break;
						
						
						
					case 'подгруппа':	

						if(!$zp_old_artikuls['Страна'] OR !$zp_old_artikuls['Город'] OR !$zp_old_artikuls['Район'] OR !$zp_old_artikuls['Магазин'] OR !$zp_old_artikuls['Подотдел'] OR !$zp_element['старое_название'])
						 {
						 	$shop_item['Действие / результат'] = 'change error: неправильно указан исходный артикул и/или название подгруппы'; // сбрасываем флаг необходимости добавления элемента в базу	
							return $shop_item;
						 }	
						
						// выясним новый и старый артикулы родительского отдела 
						$zp_element['parent_zp_old_art'] = 'z' . $zp_old_artikuls['Страна'] . $zp_old_artikuls['Город'] . $zp_old_artikuls['Район'] . $zp_old_artikuls['Магазин'] . $zp_old_artikuls['Подотдел']; 
						$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин'] . $zp_new_artikuls['Подотдел']; 
						
						break;		
						
						
					
					case 'товар':
						
						if(!$zp_old_artikuls['Страна'] OR !$zp_old_artikuls['Город'] OR !$zp_old_artikuls['Район'] OR !$zp_old_artikuls['Магазин'] OR !$zp_old_artikuls['Подотдел'] OR !$zp_old_artikuls['Подгруппа / тип элемента'] OR !$zp_old_artikuls['Товар / родительский подотдел'])
						 {
						 	$shop_item['Действие / результат'] = 'change error: не заданы какие-то из номеров местоположения и товара для формирования внутреннего артикула zp'; // сбрасываем флаг необходимости добавления элемента в базу	
							return $shop_item;
						 }
						 

						// выясним старый и новый артикулы товара
						$zp_element['zp_old_artikul'] = 'z' . $zp_old_artikuls['Страна'] . $zp_old_artikuls['Город'] . $zp_old_artikuls['Район'] . $zp_old_artikuls['Магазин'] . $zp_old_artikuls['Подотдел'] . $zp_old_artikuls['Товар / родительский подотдел']; 
						$zp_element['zp_artikul'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин'] . $zp_new_artikuls['Подотдел'] . $zp_new_artikuls['Товар / родительский подотдел']; 
						
						$node->model = $zp_element['zp_artikul']; // заранее установим новый артикул, так как на следующем шаге будет произведено изменение артикула, если оно задано в таблице
								
						// выясним новый и старый артикулы родительского отдела 
						$zp_element['parent_zp_old_art'] = 'z' . $zp_old_artikuls['Страна'] . $zp_old_artikuls['Город'] . $zp_old_artikuls['Район'] . $zp_old_artikuls['Магазин'] . $zp_old_artikuls['Подотдел']; 
						$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин'] . $zp_new_artikuls['Подотдел']; 

						
						// то же самое, но по-другому называется... для совместимости.. вроде где-то дальше используется такая переменная
						// задаём сразу новые значения, так как они будут изменены на следующем шаге
						$zp_element['parent_otdel_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин'] . $zp_new_artikuls['Подотдел'];
						
						
						// в зависимости от типа товара (который указан через *** от слова "товар") зададим типа ноды для товара
						switch($zp_element['type_of_type'])
						{
							case 'set_1':
							case 'set_2':
								break;	
								
							default:
								// иначе тип товара не определён в системе
								$shop_item['Действие / результат'] = 'change error: тип продукта ' . $zp_element['type_of_type'] . ' не задан или не определён в системе';
								return $shop_item;
								
						} // end of в зависимости от типа товара (который указан через *** от слова "товар") зададим типа ноды для товара
						
						$node->type = 'product_' . $zp_element['type_of_type'];
						
						break;		
					
									

					default:
						break;
					
				}
				
				
				
				// определим нид и некоторые другие данные текущего элемента, в зависимости от его типа
				switch($zp_element['type'])
				{
					case 'страна':
					case 'населённый пункт': // обычно город
					case 'район':
					case 'магазин':
					case 'подотдел':
					
						// определим нид текущего элемента по старому артикулу
						//$element_nid = db_result(db_query("SELECT nid from {content_field_zp_art_place} WHERE field_zp_art_place_value = '%s'", $zp_element['zp_old_artikul']));
					
						$element_nid = db_fetch_object(db_query("SELECT nid, vid from {content_field_zp_art_place} WHERE field_zp_art_place_value = '%s'", $zp_element['zp_old_artikul']));
						
						$node->vid = $element_nid->vid; 
						$node->nid = $element_nid->nid;
						 
						
						
						if(!$node->nid OR !$node->vid)
						{
							$shop_item['Действие / результат'] = 'change error: ошибка при чтении базы данных или нет элемента с таким артикулом ' . $zp_element['zp_old_artikul'] . ' в базе'; 
							return $shop_item;
						}
						
						$element_nid = $element_nid->nid;
						
						
						
						// определим тид текущего элемента
						$element_tids = taxonomy_node_get_terms_by_vocabulary($element_nid, 1);
   						foreach($element_tids as $element_tid)
    					{
     						$element_tid_name = $element_tid->name;
     						$element_tid = $element_tid->tid;
    					}
    					

    					
						break;	
					
						
					case 'подгруппа':

						// определим нид текущего (старого) родительского отдела
						$parent_nid = db_fetch_object(db_query("SELECT nid, vid from {content_field_zp_art_place} WHERE field_zp_art_place_value = '%s'", $zp_element['parent_zp_old_art']));
						
						$parent_vid = $parent_nid->vid; 
						$parent_nid = $parent_nid->nid;
						 
						if(!$parent_nid OR !$parent_vid)
						{
							$shop_item['Действие / результат'] = 'change error: ошибка при чтении базы данных или нет в базе элемента с артикулом ' . $zp_element['parent_zp_old_art'] . ', заданного в качестве родителя данной подгруппы'; 
							return $shop_item;
						}
						
						
						break;
						
						
					case 'товар':	
						
						// найдём тид самого элемента по старому артикулу
						$element_nid = db_fetch_object(db_query("SELECT nid, vid from {uc_products} WHERE model = '%s'", $zp_element['zp_old_artikul']));
						
						$node->vid = $element_nid->vid; 
						$node->nid = $element_nid->nid;
						 
						if(!$node->nid OR !$node->vid)
						{
							$shop_item['Действие / результат'] = 'change error: ошибка при чтении базы данных или нет элемента с таким артикулом ' . $zp_element['zp_old_artikul'] . ' в базе'; 
							return $shop_item;
						}
						
						$element_nid = $element_nid->nid;
									
						break;
						
						
					default:
						break;	
				
				}
				
				
				
					
					// зададим значение по умолчанию для базы названий картинок
					$zp_element['source_of_pics'] = 0; // а нужно ли это здесь вообще
					
					// не знаю, нужно ли это...
					if($shop_item['На основе чего формируется название картинок'] AND trim($shop_item['На основе чего формируется название картинок']) != '')
					{
						//$source_of_pics = zp_correct_quotes($shop_item['На основе чего формируется название картинок']);
						$source_of_pics = $shop_item['На основе чего формируется название картинок']; // не нужно там никакие кавычки удалять, там их не может быть, т.к. это число
					
						// удалим управляющие символы
						if($source_of_pics[0] . $source_of_pics[1] . $source_of_pics[2] == '###') // управляющие символы в начале строки
		 				{
							$source_of_pics = explode('###', $source_of_pics);
							foreach($value as $k => $val)
							{
								if($k == 0 OR $k == 1)
		      		  				$new_value_with_history['На основе чего формируется название картинок'] = $new_value_with_history['На основе чего формируется название картинок'] . $val;
		    					else  
		      		  				$new_value_with_history['На основе чего формируется название картинок'] = $new_value_with_history['На основе чего формируется название картинок'] . '###' . $val;  
							} 
			
							$source_of_pics = $source_of_pics[1];
							$markers = 'start';
							$zp_element['source_of_pics_markers'] = 'start';
		 				}
		 				else if(strpos($source_of_pics, '###') !== FALSE) // управляющие символы в середине строки
		 				{
			 				$source_of_pics = explode('###', $source_of_pics);
			 				foreach($value as $k => $val)
		 					{
								if($k == 0)
		      		 	 			$new_value_with_history['На основе чего формируется название картинок'] = $new_value_with_history['На основе чего формируется название картинок'] . $val;
		    					else  
		      		 	 			$new_value_with_history['На основе чего формируется название картинок'] = $new_value_with_history['На основе чего формируется название картинок'] . '###' . $val;  
							} 
					
							$source_of_pics = $source_of_pics[0];
							$zp_element['source_of_pics_markers'] = 'middle';
			 			}

						$zp_element['source_of_pics'] = $source_of_pics;
					}
				
				
					
					
					
					
					// определим вес элемента в группе - текущий или требующий изменения
					$zp_element['вес_элемента_в_группе'] = 0;
	
					if($shop_item['Вес элемента в группе'] AND trim($shop_item['Вес элемента в группе']) != '')
					{
						
			    		$value = zp_correct_quotes($shop_item['Вес элемента в группе']);
					
						if($value[0] . $value[1] . $value[2] == '###') // управляющие символы в начале строки
		 				{
							$value = explode('###', $value);
					
							//$value_old = $value[2];
							$value = $value[1];

		 				}
		 				else if(strpos($value, '###') !== FALSE) // управляющие символы в середине строки
		 				{
		 					$value = explode('###', $value);

							$value = $value[0];
							//$value_old = $value;
					
		 				}

						
		 				$zp_element['вес_элемента_в_группе'] = $value;
					}
					
					
					
					
					
					
					
						 			
		 			
		 			
// ---------- начинаем внесение изменений в базу		 			
// ----------------------------------------------------------------------------------				
// ----------------------------------------------------------------------------------
// ----------------------------------------------------------------------------------
// ----------------------------------------------------------------------------------
// ----------------------------------------------------------------------------------
				
					
				
				// если какой-то из номеров артикула или название изменились
				if($artikul_changes_exists OR $zp_element['старое_название'] != $zp_element['новое_название'])
				{   
						
					
					
					// изменяем артикул одним махом для разных типов элементов
					// перебор типов элемента для изменения артикула, подгруппы, названия для некоторых типов
					switch($zp_element['type'])
					  {
							case 'страна':
							
    							// если изменился артикул страны
    							if($zp_element['zp_artikul'] != $zp_element['zp_old_artikul'])
    							{

    	
									// проверим, есть ли сейчас потомки (города) у этой (не изменённой ещё) страны 
									// если артикул должен поменяться и при этом есть потомки, не давать изменять артикул страны, так как при его изменении потомки-города окажутся потерянными
    								if($element_tid_children = taxonomy_get_children($element_tid, 1, 'name')) // taxonomy_get_children($tid, $vid = 0, $key = 'tid');
									{
										$shop_item['Действие / результат'] = 'change error: в даннй стране содержатся города, поэтому менять артикул нельзя, так как тогда эти города окажутся потерянными. Сначала удалите или перенесите в другие страны города-потомки, а потом уже изменяйте артикул (и родителя) этой страны'; 
										return $shop_item;
									}
								
    								
    								// проверим, нет ли в базе элемента с таким артикулом, на который требуется поменять артикул данной страны
    								if($existing_element_nid = db_result(db_query("SELECT nid from {content_field_zp_art_place} WHERE field_zp_art_place_value = '%s'", $zp_element['zp_new_artikul'])))
    								{
    									$shop_item['Действие / результат'] = 'change error: в базе уже есть элемент с таким артикулом ' . $zp_element['zp_new_artikul']; 
										return $shop_item;
    								}

    								
    								
									// если дошли до этого шага, значит можем менять артикул страны на новый
									if(
										!db_query("UPDATE {content_field_zp_art_place} SET field_zp_art_place_value = '%s' WHERE nid = %d", $zp_element['zp_artikul'], $element_nid)
								  	  )
								  	  {
										$shop_item['Действие / результат'] = 'change error: ошибка при изменении артикула страны на новый ' . $zp_element['zp_artikul']; 
										return $shop_item;
	  							  	  }

    							} // end of if($zp_element['zp_artikul'] != $zp_element['zp_old_artikul'])								
								
								
								// если изменилось название, меняем название и у соответствующего терма страны
								// название самой страны изменяется позже, вместе с остальными полями
								if($zp_element['новое_название'] != $zp_element['старое_название'])
								{
									//echo 'Изменилось название<br>';
									
									
									if(
										!db_query("UPDATE {term_data} SET name = '%s' WHERE tid = %d", $zp_element['новое_название'], $element_tid)
								  	  )
								  	  {
										$shop_item['Действие / результат'] = 'change error: ошибка при изменении названия терма страны на новое - ' . $zp_element['новое_название']; 
										return $shop_item;
	  							  	  }
	  							  	  
								}
								
								
								break; // end of case 'страна':
								
								
								
								
								
								
								
								
							case 'населённый пункт': // обычно город

    							// если изменился артикул любым способом (хоть только номер, без изменения родителя, хоть с изменением родителя)
    							if($zp_element['zp_artikul'] != $zp_element['zp_old_artikul'])
    							{
    	
									// проверим, есть ли сейчас потомки (районы) у этого (не изменённого ещё) города 
									// если артикул должен поменяться и при этом есть потомки, не давать изменять артикул и родительскую страны, так как при его изменении потомки города окажутся потерянными
    								if($element_tid_children = taxonomy_get_children($element_tid, 1, 'name')) // taxonomy_get_children($tid, $vid = 0, $key = 'tid');
									{
										$shop_item['Действие / результат'] = 'change error: в данном населённом пункте содержатся районы, поэтому менять артикул нельзя, так как тогда эти районы окажутся потерянными. Сначала удалите или перенесите в другие города районы-потомки, а потом уже изменяйте артикул (и родителя) этого города'; 
										return $shop_item;
									}
								
    								
    								// проверим, нет ли в базе элемента с таким артикулом, на который требуется поменять артикул данного города
    								if($existing_element_nid = db_result(db_query("SELECT nid from {content_field_zp_art_place} WHERE field_zp_art_place_value = '%s'", $zp_element['zp_new_artikul'])))
    								{
    									$shop_item['Действие / результат'] = 'change error: в базе уже есть элемент с таким артикулом ' . $zp_element['zp_new_artikul']; 
										return $shop_item;
    								}
								
    							} // end of if($zp_element['zp_artikul'] != $zp_element['zp_old_artikul'])
    							
    							
    							
    							// если у города не просто меняется номер внутри страны, а меняется и родитель (страна)
    							if($zp_element['parent_zp_art'] != $zp_element['parent_zp_old_art'])
    							{	
    								// проверим, есть ли в новом родительской стране потомки (города) с таким названием, как новое (если изменилось) название этого города
								
									// определим нид новой родительской страны
									// и если нид неопределён, значит заданного нового родителя не существует в базе
									if(
										!($parent_nid = db_result(db_query("SELECT nid from {content_field_zp_art_place} WHERE field_zp_art_place_value = '%s'", $zp_element['parent_zp_art'])))
    								  )
    								  {
    								  		$shop_item['Действие / результат'] = 'change error: не определёна страна с артикулом ' . $zp_element['parent_zp_art'] . ' которая задана в качестве нового родителя для этого города'; 
											return $shop_item;
    								  }
								
									// определим тид новой родительской страны
									$parent_tids = taxonomy_node_get_terms_by_vocabulary($parent_nid, 1);
   									foreach($parent_tids as $parent_tid)
    								{
     									$parent_tid_name = $parent_tid->name;
     									$parent_tid = $parent_tid->tid;
    								}

    								// найдём всех потомков новой родительской страны
    								// и среди них попробуем найти потомка с названием, равным новому назвыванию текущего города
    								// если найдётся, значит назначить заявленные новый артикул/название нельзя
									$parent_tid_children = taxonomy_get_children($parent_tid, 1, 'name'); // taxonomy_get_children($tid, $vid = 0, $key = 'tid');
									foreach($parent_tid_children as $child_name => $child_values)
									{
										if($child_name == $zp_element['новое_название'])
										{
											$shop_item['Действие / результат'] = 'change error: в новой стране в базе уже есть города с таким названием' . $zp_element['новое_название']; 
											return $shop_item;
										}
									}
									
									
									
									// если дошли до этого шага, значит можно менять терм родителя города на новый, терм новой страны
									if(
										!db_query("UPDATE {term_hierarchy} SET parent = %d WHERE tid = %d", $parent_tid, $element_tid)
								  	  )
								  	  {
										$shop_item['Действие / результат'] = 'change error: ошибка при изменении терма родителя города на терм новой родительской страны'; 
										return $shop_item;
	  							  	  }
	
	  							  	  
    							} // end of if($zp_element['parent_zp_art'] != $zp_element['parent_zp_old_art'])
    							
    							
    							
    							if($zp_element['zp_artikul'] != $zp_element['zp_old_artikul'])
    							{
									// если дошли до этого шага, значит можем менять артикул города на новый
									if(
										!db_query("UPDATE {content_field_zp_art_place} SET field_zp_art_place_value = '%s' WHERE nid = %d", $zp_element['zp_artikul'], $element_nid)
								  	  )
								  	  {
										$shop_item['Действие / результат'] = 'change error: ошибка при изменении артикула города на новый ' . $zp_element['zp_artikul']; 
										return $shop_item;
	  							  	  }

    							} // end of if($zp_element['zp_artikul'] != $zp_element['zp_old_artikul'])								
								
								
								// если изменилось название, меняем название и соответствующего терма города
								// название самого города изменяется позже, вместе с остальными полями
								if($zp_element['новое_название'] != $zp_element['старое_название'])
								{
									if(
										!db_query("UPDATE {term_data} SET name = '%s' WHERE tid = %d", $zp_element['новое_название'], $element_tid)
								  	  )
								  	  {
										$shop_item['Действие / результат'] = 'change error: ошибка при изменении названия терма города на новое - ' . $zp_element['новое_название']; 
										return $shop_item;
	  							  	  }
	  							  	  
								}
								
								
								break; // end of case 'населённый пункт':
								
								
								
								
								
								
								
							case 'район':
								
    							// если изменился артикул любым способом (хоть только номер, без изменения родителя, хоть с изменением родителя)
    							if($zp_element['zp_artikul'] != $zp_element['zp_old_artikul'])
    							{
    	
									// проверим, есть ли сейчас потомки (магазины) у этого (не изменённого ещё) района 
									// если артикул должен поменяться и при этом есть потомки, не давать изменять артикул и родительский город, так как при его изменении потомки района окажутся потерянными
    								if($element_tid_children = taxonomy_get_children($element_tid, 1, 'name')) // taxonomy_get_children($tid, $vid = 0, $key = 'tid');
									{
										$shop_item['Действие / результат'] = 'change error: в данном районе содержатся магазины, поэтому менять артикул нельзя, так как тогда эти магазины окажутся потерянными. Сначала удалите или перенесите в другие районы магазины потомки, а потом уже изменяйте артикул (и родителя) этого района'; 
										return $shop_item;
									}
								
    								
    								// проверим, нет ли в базе элемента с таким артикулом, на который требуется поменять артикул данного района
    								if($existing_element_nid = db_result(db_query("SELECT nid from {content_field_zp_art_place} WHERE field_zp_art_place_value = '%s'", $zp_element['zp_new_artikul'])))
    								{
    									$shop_item['Действие / результат'] = 'change error: в базе уже есть элемент с таким артикулом ' . $zp_element['zp_new_artikul']; 
										return $shop_item;
    								}
								
    							} // end of if($zp_element['zp_artikul'] != $zp_element['zp_old_artikul'])
    							
    							
    							
    							// если у района не просто меняется номер внутри города, а меняется и родитель (город)
    							if($zp_element['parent_zp_art'] != $zp_element['parent_zp_old_art'])
    							{	
    								// проверим, нет ли в новом родительском городе потомки (районы) с таким названием, как новое (если изменилось) название этого района
								
									// определим нид нового родительского города
									// и если нид неопределён, значит заданного нового родителя не существует в базе
									if(
										!($parent_nid = db_result(db_query("SELECT nid from {content_field_zp_art_place} WHERE field_zp_art_place_value = '%s'", $zp_element['parent_zp_art'])))
    								  )
    								  {
    								  		$shop_item['Действие / результат'] = 'change error: не определён город с артикулом ' . $zp_element['parent_zp_art'] . ' который задан в качестве нового родителя для этого района'; 
											return $shop_item;
    								  }
    								  
    								  
									// определим тид нового родительского города
									$parent_tids = taxonomy_node_get_terms_by_vocabulary($parent_nid, 1);
   									foreach($parent_tids as $parent_tid)
    								{
     									$parent_tid_name = $parent_tid->name;
     									$parent_tid = $parent_tid->tid;
    								}

    								// найдём всех потомков нового родительского города
    								// и среди них попробуем найти потомка с названием, равным новому назвыванию текущего района
    								// если найдётся, значит назначить заявленные новый артикул/название нельзя
									$parent_tid_children = taxonomy_get_children($parent_tid, 1, 'name'); // taxonomy_get_children($tid, $vid = 0, $key = 'tid');
									foreach($parent_tid_children as $child_name => $child_values)
									{
										if($child_name == $zp_element['новое_название'])
										{
											$shop_item['Действие / результат'] = 'change error: в новом городе в базе уже есть район с таким названием' . $zp_element['новое_название']; 
											return $shop_item;
										}
									}
									
									
									
									// если дошли до этого шага, значит можно менять терм родителя района на новый, терм нового города
									if(
										!db_query("UPDATE {term_hierarchy} SET parent = %d WHERE tid = %d", $parent_tid, $element_tid)
								  	  )
								  	  {
										$shop_item['Действие / результат'] = 'change error: ошибка при изменении терма родителя района на терм нового родительского города'; 
										return $shop_item;
	  							  	  }
	
	  							  	  
    							} // end of if($zp_element['parent_zp_art'] != $zp_element['parent_zp_old_art'])
    							
    							
    							
    							if($zp_element['zp_artikul'] != $zp_element['zp_old_artikul'])
    							{
									// если дошли до этого шага, значит можем менять артикул района на новый
									if(
										!db_query("UPDATE {content_field_zp_art_place} SET field_zp_art_place_value = '%s' WHERE nid = %d", $zp_element['zp_artikul'], $element_nid)
								  	  )
								  	  {
										$shop_item['Действие / результат'] = 'change error: ошибка при изменении артикула района на новый - ' . $zp_element['zp_artikul']; 
										return $shop_item;
	  							  	  }

    							} // end of if($zp_element['zp_artikul'] != $zp_element['zp_old_artikul'])								
								
								
								// если изменилось название, меняем название и соответствующего терма района
								// название самого района изменяется позже, вместе с остальными полями
								if($zp_element['новое_название'] != $zp_element['старое_название'])
								{
									if(
										!db_query("UPDATE {term_data} SET name = '%s' WHERE tid = %d", $zp_element['новое_название'], $element_tid)
								  	  )
								  	  {
										$shop_item['Действие / результат'] = 'change error: ошибка при изменении названия терма района на новое - ' . $zp_element['новое_название']; 
										return $shop_item;
	  							  	  }
	  							  	  
								}
								
								
								break; // end of case 'район':
								
								
								
								
								
							case 'магазин':
								
    							// если изменился артикул любым способом (хоть только номер, без изменения родителя, хоть с изменением родителя)
    							if($zp_element['zp_artikul'] != $zp_element['zp_old_artikul'])
    							{
    	
									// проверим, есть ли сейчас потомки (отделы) у этого (не изменённого ещё) магазина 
									// если артикул должен поменяться и при этом есть потомки, не давать изменять артикул и родительский район, так как при его изменении потомки магазина окажутся потерянными
    								if($element_tid_children = taxonomy_get_children($element_tid, 1, 'name')) // taxonomy_get_children($tid, $vid = 0, $key = 'tid');
									{
										$shop_item['Действие / результат'] = 'change error: в данном магазине содержатся подотделы, поэтому менять артикул нельзя, так как тогда эти подотделы окажутся потерянными. Сначала удалите или перенесите в другие магазины подотделы потомки, а потом уже изменяйте артикул (и родителя) этого магазина'; 
										return $shop_item;
									}
								
    								
    								// проверим, нет ли в базе элемента с таким артикулом, на который требуется поменять артикул данного магазина
    								if($existing_element_nid = db_result(db_query("SELECT nid from {content_field_zp_art_place} WHERE field_zp_art_place_value = '%s'", $zp_element['zp_new_artikul'])))
    								{
    									$shop_item['Действие / результат'] = 'change error: в базе уже есть элемент с таким артикулом ' . $zp_element['zp_new_artikul']; 
										return $shop_item;
    								}
								
    							} // end of if($zp_element['zp_artikul'] != $zp_element['zp_old_artikul'])
    							
    							
    							
    							// если у магазина не просто меняется номер внутри района, а меняется и родитель (район)
    							if($zp_element['parent_zp_art'] != $zp_element['parent_zp_old_art'])
    							{	
    								// проверим, нет ли в новом родительском районе потомки (магазины) с таким названием, как новое (если изменилось) название этого магазина
								
									// определим нид нового родительского района
									// и если нид неопределён, значит заданного нового родителя не существует в базе
									if(
										!($parent_nid = db_result(db_query("SELECT nid from {content_field_zp_art_place} WHERE field_zp_art_place_value = '%s'", $zp_element['parent_zp_art'])))
    								  )
    								  {
    								  		$shop_item['Действие / результат'] = 'change error: не определён район с артикулом ' . $zp_element['parent_zp_art'] . ' который задан в качестве нового родителя для этого магазина'; 
											return $shop_item;
    								  }
								
									// определим тид нового родительского района
									$parent_tids = taxonomy_node_get_terms_by_vocabulary($parent_nid, 1);
   									foreach($parent_tids as $parent_tid)
    								{
     									$parent_tid_name = $parent_tid->name;
     									$parent_tid = $parent_tid->tid;
    								}

    								// найдём всех потомков нового родительского района
    								// и среди них попробуем найти потомка с названием, равным новому назвыванию текущего магазина
    								// если найдётся, значит назначить заявленные новый артикул/название нельзя
									$parent_tid_children = taxonomy_get_children($parent_tid, 1, 'name'); // taxonomy_get_children($tid, $vid = 0, $key = 'tid');
									foreach($parent_tid_children as $child_name => $child_values)
									{
										if($child_name == $zp_element['новое_название'])
										{
											$shop_item['Действие / результат'] = 'change error: в новом районе в базе уже есть магазин с таким названием' . $zp_element['новое_название']; 
											return $shop_item;
										}
									}
									
									
									
									// если дошли до этого шага, значит можно менять терм родителя магазина на новый, терм нового района
									if(
										!db_query("UPDATE {term_hierarchy} SET parent = %d WHERE tid = %d", $parent_tid, $element_tid)
								  	  )
								  	  {
										$shop_item['Действие / результат'] = 'change error: ошибка при изменении терма родителя магазина на терм нового родительского района'; 
										return $shop_item;
	  							  	  }
	
	  							  	  
    							} // end of if($zp_element['parent_zp_art'] != $zp_element['parent_zp_old_art'])
    							
    							
    							
    							if($zp_element['zp_artikul'] != $zp_element['zp_old_artikul'])
    							{
									// если дошли до этого шага, значит можем менять артикул магазина на новый
									if(
										!db_query("UPDATE {content_field_zp_art_place} SET field_zp_art_place_value = '%s' WHERE nid = %d", $zp_element['zp_artikul'], $element_nid)
								  	  )
								  	  {
										$shop_item['Действие / результат'] = 'change error: ошибка при изменении артикула магазина на новый ' . $zp_element['zp_artikul']; 
										return $shop_item;
	  							  	  }

    							} // end of if($zp_element['zp_artikul'] != $zp_element['zp_old_artikul'])								
								
								
								// если изменилось название, меняем название и соответствующего терма магазина
								// название самого магазина изменяется позже, вместе с остальными полями
								if($zp_element['новое_название'] != $zp_element['старое_название'])
								{
									if(
										!db_query("UPDATE {term_data} SET name = '%s' WHERE tid = %d", $zp_element['новое_название'], $element_tid)
								  	  )
								  	  {
										$shop_item['Действие / результат'] = 'change error: ошибка при изменении названия терма магазина на на новое ' . $zp_element['новое_название']; 
										return $shop_item;
	  							  	  }
	  							  	  
								}
								
								
								break; // end of case 'магазин':
								
								
								
								
								
								
								
								
							case 'подотдел':

    							// если хоть как-то изменился артикул (с изменением родителя или просто с изменением номера внутри прежнего родителя)
    							if($zp_element['zp_artikul'] != $zp_element['zp_old_artikul'])
    							{
    								
    								// проверим, нет ли в базе элемента с таким артикулом, на который требуется поменять артикул данного подотдела
    								if($existing_element_nid = db_result(db_query("SELECT nid from {content_field_zp_art_place} WHERE field_zp_art_place_value = '%s'", $zp_element['zp_new_artikul'])))
    								{
    									$shop_item['Действие / результат'] = 'change error: в базе уже есть элемент с таким артикулом ' . $zp_element['zp_new_artikul']; 
										return $shop_item;
    								}
    							
    							
    								// найдём всех потомков текущего подотдела
    								// если потомки есть, значит нельзя изменять артикул и родительский подотдел, так как при его изменении потомки подотдела окажутся потерянными
									if($element_tid_children = taxonomy_get_children($element_tid, 1, 'name')) // taxonomy_get_children($tid, $vid = 0, $key = 'tid');
									{
										$shop_item['Действие / результат'] = 'change error: в данном отделе содержатся подотделы или подгруппы, поэтому менять артикул нельзя, так как тогда эти элементы окажутся потерянными. Сначала удалите или перенесите в другие отделы подотделы потомки, а потом уже изменяйте артикул'; 
										return $shop_item;
									}
    							}
    							
    							
    							
    							// если изменился родитель подотдела
    							if($zp_element['parent_zp_art'] != $zp_element['parent_zp_old_art'])
    							{

									// определим нид нового родительского подотдела
									// и если нид неопределён, значит заданного нового родителя не существует в базе
									if(
										!($parent_nid = db_result(db_query("SELECT nid from {content_field_zp_art_place} WHERE field_zp_art_place_value = '%s'", $zp_element['parent_zp_art'])))
    								  )
    								  {
    								  		$shop_item['Действие / результат'] = 'change error: не определён элемент с артикулом ' . $zp_element['parent_zp_art'] . ' который задан в качестве нового родителя для этого подотдела'; 
											return $shop_item;
    								  }

								
									// определим тид нового родительского отдела
									$parent_tids = taxonomy_node_get_terms_by_vocabulary($parent_nid, 1);
   									foreach($parent_tids as $parent_tid)
    								{
     									$parent_tid_name = $parent_tid->name;
     									$parent_tid = $parent_tid->tid;
    								}

    								// найдём всех потомков нового родительского подотдела
    								// и среди них попробуем найти потомка с названием равным новому назвыванию текущего подотдела
    								// если найдётся, значит назначить заявленные новый артикул/название нельзя
									$parent_tid_children = taxonomy_get_children($parent_tid, 1, 'name'); // taxonomy_get_children($tid, $vid = 0, $key = 'tid');
									foreach($parent_tid_children as $child_name => $child_values)
									{
										if($child_name == $zp_element['новое_название'])
										{
											$shop_item['Действие / результат'] = 'change error: в новом отделе в базе уже есть подотдел с названием ' . $zp_element['новое_название']; 
											return $shop_item;
										}
									}
									
									
									// если дошли до этого шага, значит можем менять связи
									// меняем связь: терм родителя подотдела на терм нового родительского подотдела
									if(
										!db_query("UPDATE {term_hierarchy} SET parent = %d WHERE tid = %d", $parent_tid, $element_tid)
								  	  )
								  	  {
										$shop_item['Действие / результат'] = 'change error: ошибка при изменении терма родителя подотдела на терм нового родительского подотдела'; 
										return $shop_item;
	  							  	  }
	  							  	  
										
    							} // end of if($zp_element['parent_zp_art'] != $zp_element['parent_zp_old_art'])
    								
    							
    							
    							if($zp_element['zp_artikul'] != $zp_element['zp_old_artikul'])
    							{
								
									// если дошли до этого шага, значит можем менять артикул
									if(
										!db_query("UPDATE {content_field_zp_art_place} SET field_zp_art_place_value = '%s' WHERE nid = %d", $zp_element['zp_artikul'], $element_nid)
								  	  )
								  	  {
										$shop_item['Действие / результат'] = 'change error: ошибка при изменении родителя (артикула подотдела) подотдела на новый ' . $zp_element['zp_artikul']; 
										return $shop_item;
	  							  	  }
									

								} // end of if($zp_element['zp_artikul'] != $zp_element['zp_old_artikul'])
								
								
								
								
								// если изменилось название, меняем название соответствующего терма подотдела
								// название самого отдела изменяется позже, вместе с остальными полями
								if($zp_element['новое_название'] != $zp_element['старое_название'])
								{
									
									// пункт 'Прочее' должен стоять самым последним в любом меню
    								if(mb_strtolower($node->title) == 'прочее')
    									//$new_tid_weight = 127;
    									$zp_element['вес_элемента_в_группе'] = 127;
    								//else 
    									//$new_tid_weight = 0;
    				
									
									if(
										!db_query("UPDATE {term_data} SET name = '%s', weight = %d WHERE tid = %d", $zp_element['новое_название'], $zp_element['вес_элемента_в_группе'], $element_tid)
								  	  )
								  	  {
										$shop_item['Действие / результат'] = 'change error: ошибка при изменении названия терма подотдела на на новое ' . $zp_element['новое_название']; 
										return $shop_item;
	  							  	  }
	  							  	  
								} // end of if($zp_element['новое_название'] != $zp_element['старое_название'])
								

								break; // end of case 'подотдел':
								
								
								
								
								
							case 'подгруппа':
							
								// проверим есть ли сейчас потомки у этой (не изменённой ещё) подгруппы 
								// если есть, не давать изменять артикул и название подгруппы, так как при его изменении потомки группы окажутся потерянными
									
								// определим текущий (старый) тид этой подгруппы
								// для этого
									
								// определим тид текущего (старого) родительского отдела
								$parent_tids = taxonomy_node_get_terms_by_vocabulary($parent_nid, 1);
   								foreach($parent_tids as $parent_tid)
    							{
     								$parent_tid_name = $parent_tid->name;
     								$parent_tid = $parent_tid->tid;
    							}

    							// найдём всех потомков текущего (старого) родительского отдела, у которых нет своих детей, т.е., найдём все подгруппы родительского отдела, если он их имеет
    							// и среди них найдём потомка с названием текущей подгруппы и возьмём его тид
								$parent_tid_children = taxonomy_get_children($parent_tid, 1, 'name'); // taxonomy_get_children($tid, $vid = 0, $key = 'tid');
								$current_podgruppa_tid = FALSE;
								foreach($parent_tid_children as $child_name => $child_values)
								{
									if(taxonomy_get_children($child_values->tid, 1, 'name'))
								  		continue; // если потомок имеет своих потомков, значит это не подгруппа, а подотдел-потомок, а нам нужна группа!
									
									  		
									if($child_name == $zp_element['старое_название'])
									{
										$current_podgruppa_tid = $child_values->tid;
										$current_podgruppa_tid_name = $child_values->name;
										break;
									}
								}
										
								
								// если в текущем (старом) родительском отделе нет такой подгруппы (исходной, неизменённой), которой мы хотим изменить артикул
								if(!$current_podgruppa_tid)
								{
									$shop_item['Действие / результат'] = 'change error: в данном отделе в базе нет подгруппы с названием ' . $zp_element['старое_название'] . ', у которой вы пытаетесь изменить артикул'; 
									return $shop_item;
								}
									
									
								// --------------------------------------------------------------------------------------	
								
								// если родительский отдел изменился
								if($zp_element['parent_zp_art'] != $zp_element['parent_zp_old_art'])
								{
									
									
									// если тид текущей подгруппы имеет хоть одна нода (этой нодой может быть только товар), то значит подгруппа имеет потомков, значит её изменять нельзя
									if($child_nid = db_result(db_query("SELECT nid from {term_node} WHERE tid = %d", $current_podgruppa_tid)))
									{
										$shop_item['Действие / результат'] = 'change error: в данной подгруппе с названием ' . $zp_element['старое_название'] . ' содержатся товары, поэтому изменение артикула невозможно. Сначала освободите подгруппу от товаров. Вместо изменения артикула подгруппы можно сначала создать новую подгруппу с новым артикулом, затем перенести в неё товары из этой группы (сделать родителем товаров новую созданную группу), а потом удалить старую подгруппу, освобождённую от товаров'; 
										return $shop_item;
									}
									
									// если дошли до этого шага, значит в подгруппе нет товаров, значит можно менять артикул и, если необходимо, название
									//$zp_element['старое_название'], $zp_element['новое_название'] 
									
									// проверим, нет ли в указанном (с помощью нового артикула) новом родителе этой подгруппы подгруппы с таким же (новым, если оно меняется у подгруппы) названием
									// если есть, то значит мы не можем перенести (и, если нужно, переименовать) текущую подгруппу в новый подотдел, так как там уже есть подгруппа с таким названием
									
									// определим нид нового родительского отдела
									// и если нид неопределён, значит заданного нового родителя не существует в базе
									if(
										!($new_parent_nid = db_result(db_query("SELECT nid from {content_field_zp_art_place} WHERE field_zp_art_place_value = '%s'", $zp_element['parent_zp_art'])))
    								  )
    								  {
    								  		$shop_item['Действие / результат'] = 'change error: не определён подотдел с артикулом ' . $zp_element['parent_zp_art'] . ' который задан в качестве нового родителя для этой подгруппы'; 
											return $shop_item;
    								  }
									
			
									// определим тид нового родительского отдела
									$new_parent_tids = taxonomy_node_get_terms_by_vocabulary($new_parent_nid, 1);
   									foreach($new_parent_tids as $new_parent_tid)
    								{
     									$new_parent_tid_name = $new_parent_tid->name;
     									$new_parent_tid = $new_parent_tid->tid;
    								}

    								// найдём всех потомков нового родительского отдела, у которых нет своих детей, т.е., найдём все подгруппы родительского отдела, если он их имеет
    								// и среди них найдём потомка с названием текущей подгруппы и возьмём его тид
									$new_parent_tid_children = taxonomy_get_children($new_parent_tid, 1, 'name'); // taxonomy_get_children($tid, $vid = 0, $key = 'tid');
									$existing_podgruppa_tid = FALSE;
									foreach($new_parent_tid_children as $child_name => $child_values)
									{
										if(taxonomy_get_children($child_values->tid, 1, 'name'))
									  		continue; // если потомок имеет своих потомков, значит это не подгруппа, а подотдел-потомок, а нам нужна группа!
									
									  		
										if($child_name == $zp_element['новое_название'])
										{
											$existing_podgruppa_tid = $child_values->tid;
											$existing_podgruppa_tid_name = $child_values->name;
											break;
										}
									}
										
								
									// если в текущем (старом) родительском отделе нет такой подгруппы (исходной, неизменённой), которой мы хотим изменить артикул
									if($existing_podgruppa_tid)
									{
										$shop_item['Действие / результат'] = 'change error: в новом отделе, в который вы хотите перенести эту подгруппу, уже есть подгруппа с таким названием ' . $zp_element['новое_название']; 
										return $shop_item;
									}
									
									// теперь ясно, что можно произвести изменение артикула (родителя) и, если нужно, названия подгруппы
									// что и делаем
									// фактически, меняем только связь по термам (что и указываает на артикул родителя) и, если нужно, название
									// $current_podgruppa_tid
									// $new_parent_tid
									
									// меняем родителя подгруппы на нового
									if(
										!db_query("UPDATE {term_hierarchy} SET parent = %d WHERE tid = %d", $new_parent_tid, $current_podgruppa_tid)
								  	  )
								  	  {
										$shop_item['Действие / результат'] = 'change error: ошибка при изменении родителя (артикула) подгруппы на на новый ' . $zp_element['parent_zp_art']; 
										return $shop_item;
	  							  	  }
	  							  	  
	  							  	 // если название подгруппы изменилось, меняем его в базе
	  							  	 if($zp_element['старое_название'] != $zp_element['новое_название'])
	  							  	 {
	  							  	 	
	  							  	 	// пункт 'Прочее' должен стоять самым последним в любом меню
    									if(mb_strtolower($node->title) == 'прочее')
    										//$new_tid_weight = 127;
    										$zp_element['вес_элемента_в_группе'] = 127;
    									//else 
    										//$new_tid_weight = 0;
    									
    										
	  							  	 	if(
											!db_query("UPDATE {term_data} SET name = '%s', weight = %d WHERE tid = %d", $zp_element['новое_название'], $zp_element['вес_элемента_в_группе'], $current_podgruppa_tid)
								  	  	  )
								  	  	  {
											$shop_item['Действие / результат'] = 'change error: ошибка при изменении названия подгруппы на на новое ' . $zp_element['новое_название']; 
											return $shop_item;
	  							  	  	  }
	  							  	 }

								} // end of if($zp_element['parent_zp_art'] != $zp_element['parent_zp_old_art']) // если родительский отдел изменился
								
								// --------------------------------------------------------------------------------------	
								
								else if($zp_element['старое_название'] != $zp_element['новое_название'])
								{
									// если у подгруппы есть потомки (товары), то название подгруппы менять нельзя, так как тогда случится путаница и сбой по связям
									// если так, то сначала надо либо очистить подгруппу от товаров и тогда менять название
									// либо создать новую подгруппу с таким же родителем, но с новым названием, перенести в неё товары из этой группы, а затем эту группу удалить
									// если тид текущей подгруппы имеет хоть одна нода (этой нодой может быть только товар), то значит подгруппа имеет потомков, значит её изменять нельзя
									
									if($child_nid = db_result(db_query("SELECT nid from {term_node} WHERE tid = %d", $current_podgruppa_tid)))
									{
										$shop_item['Действие / результат'] = 'change error: в данной подгруппе с названием ' . $zp_element['старое_название'] . ' содержатся товары, поэтому изменение артикула невозможно. Сначала освободите подгруппу от товаров. Вместо изменения артикула подгруппы можно сначала создать новую подгруппу с новым артикулом, затем перенести в неё товары из этой группы (сделать родителем товаров новую созданную группу), а потом удалить старую подгруппу, освобождённую от товаров'; 
										return $shop_item;
									}
									
									
									// меняем название терма подгруппы
									if(
										!db_query("UPDATE {term_data} SET name = '%s' WHERE tid = %d", $zp_element['новое_название'], $current_podgruppa_tid)
								  	  )
								  	  {
										$shop_item['Действие / результат'] = 'change error: ошибка при изменении названия подгруппы на на новое ' . $zp_element['новое_название']; 
										return $shop_item;
	  							  	  }

								}
								
								break; // end of case 'подгруппа':
								
								
								
								
							case 'товар':
																
								// если родительский отдел изменился
								if($zp_element['parent_zp_art'] != $zp_element['parent_zp_old_art'])
								{
									
									// выясним нет ли в базе уже такого артикула, на который нужно изменить артикул текущего элемента
									if($existing_artikul = db_result(db_query("SELECT nid from {uc_products} WHERE model = '%s'", $zp_element['zp_artikul'])))
									{
										$shop_item['Действие / результат'] = 'change error: нельзя заменить артикул товара, товар с артикулом ' . $zp_element['zp_artikul'] . ' уже существует в базе'; 
										return $shop_item;
									}
									
								
									// определим нид нового родительского отдела
									// и если нид неопределён, значит заданного нового родителя не существует в базе
									if(
										!($parent_nid = db_result(db_query("SELECT nid from {content_field_zp_art_place} WHERE field_zp_art_place_value = '%s'", $zp_element['parent_zp_art'])))
    								  )
    								  {
    								  		$shop_item['Действие / результат'] = 'change error: не определён подотдел с артикулом ' . $zp_element['parent_zp_art'] . ' который задан в качестве нового родителя для этого товара'; 
											return $shop_item;
    								  }
								
									// определим тид нового родительского отдела
									$parent_tids = taxonomy_node_get_terms_by_vocabulary($parent_nid, 1);
   									foreach($parent_tids as $parent_tid)
    								{
     									$parent_tid_name = $parent_tid->name;
     									$parent_tid = $parent_tid->tid;
    								}
								
									// найдём всех потомков нового родительского отдела, у которых нет своих детей, т.е., найдём все подгруппы родительского отдела, если он их имеет
									$parent_tid_children = taxonomy_get_children($parent_tid, 1, 'name'); // taxonomy_get_children($tid, $vid = 0, $key = 'tid');
									$podgruppa_tid = FALSE;
									foreach($parent_tid_children as $child_name => $child_values)
									{
										if(taxonomy_get_children($child_values->tid, 1, 'name'))
									  		continue; // если потомок имеет своих потомков, значит это не подгруппа, а подотдел-потомок, а нам нужна группа!
									
										if($child_name == $zp_new_artikuls['Подгруппа / тип элемента'])
										{
											$podgruppa_tid = $child_values->tid;
											$podgruppa_tid_name = $child_values->name;
											break;
										}
									}
								
								
									// если в родительском отделе нет группы с называнием, на которое требуется изменить подгруппу данного товара
									if(!$podgruppa_tid)
									{
										$shop_item['Действие / результат'] = 'change error: нельзя изменить артикул товара, так как в новом родительском отделе не задана группа ' . $zp_new_artikuls['Подгруппа / тип элемента']; 
										return $shop_item;
									}
								
								
								
									// меняем артикул товара на новый 
									if(
										!db_query("UPDATE {uc_products} SET model = '%s' WHERE nid = %d", $zp_element['zp_artikul'], $element_nid)
								  	  )
								  	  {
										$shop_item['Действие / результат'] = 'change error: ошибка при изменении артикула товара на новый ' . $zp_element['zp_artikul']; 
										return $shop_item;
	  							  	  }
									
    							
    								// меняем терм родителя товара на терм нового родителя - подгруппы $podgruppa_tid
									if(
										//!db_query("UPDATE {term_node} SET parent = %d WHERE tid = %d", $podgruppa_tid, $element_tid)
										//!db_query("UPDATE {term_hierarchy} SET parent = %d WHERE tid = %d", $podgruppa_tid, $element_tid)
										!db_query("UPDATE {term_node} SET tid = %d WHERE nid = %d", $podgruppa_tid, $node->nid)
								  	  )
								  	  {
										$shop_item['Действие / результат'] = 'change error: ошибка при изменении родителя товара с новым артикулом ' . $zp_element['zp_artikul'] . ' на подгруппу ' . $podgruppa_tid_name; 
										return $shop_item;
	  							  	  }
	  							  	
								} // end of if($zp_element['parent_zp_art'] != $zp_element['parent_zp_old_art'])
								else // если родительский отдел не изменился
								{
									if ($zp_old_artikuls['Товар / родительский подотдел'] != $zp_new_artikuls['Товар / родительский подотдел']) 
									{
										// выясним нет ли в текущем отделе в базе уже такого артикула, на который нужно изменить артикул текущего элемента
										if($existing_artikul = db_result(db_query("SELECT nid from {uc_products} WHERE model = '%s'", $zp_element['zp_artikul'])))
										{
											$shop_item['Действие / результат'] = 'change error: нельзя заменить артикул товара (номер товара в своём отделе), товар с артикулом ' . $zp_element['zp_artikul'] . ' уже существует в базе'; 
											return $shop_item;
										}
										
										// меняем артикул товара на новый 
										if(
											!db_query("UPDATE {uc_products} SET model = '%s' WHERE nid = %d", $zp_element['zp_artikul'], $element_nid)
								  	  	  )
								  	  	  {
											$shop_item['Действие / результат'] = 'change error: ошибка при изменении артикула товара (номера товара в своём отделе) на новый ' . $zp_element['zp_artikul']; 
											return $shop_item;
	  							  	      }

									 } // end of if ($zp_old_artikuls['Товар / родительский подотдел'] != $zp_new_artikuls['Товар / родительский подотдел']) 
									
									 
									 
									 
									 if ($zp_old_artikuls['Подгруппа / тип элемента'] != $zp_new_artikuls['Подгруппа / тип элемента']) 
									 {
									 	
									 	
									 	// определим нид нового родительского отдела
										$parent_nid = db_result(db_query("SELECT nid from {content_field_zp_art_place} WHERE field_zp_art_place_value = '%s'", $zp_element['parent_zp_art']));
										
										//echo 'parent_nid = ' . $parent_nid . '<br>';
										
										// определим тид нового родительского отдела
										$parent_tids = taxonomy_node_get_terms_by_vocabulary($parent_nid, 1);
   										foreach($parent_tids as $parent_tid)
    									{
     										$parent_tid_name = $parent_tid->name;
     										$parent_tid = $parent_tid->tid;
    									}

    									
										// найдём всех потомков нового родительского отдела, у которых нет своих детей, т.е., найдём все подгруппы родительского отдела, если он их имеет
										$parent_tid_children = taxonomy_get_children($parent_tid, 1, 'name'); // taxonomy_get_children($tid, $vid = 0, $key = 'tid');
										$podgruppa_tid = FALSE;
										foreach($parent_tid_children as $child_name => $child_values)
										{
											if(taxonomy_get_children($child_values->tid, 1, 'name'))
									  			continue; // если потомок имеет своих потомков, значит это не подгруппа, а подотдел-потомок, а нам нужна группа!
									
											if($child_name == $zp_new_artikuls['Подгруппа / тип элемента'])
											{
												$podgruppa_tid = $child_values->tid;
												$podgruppa_tid_name = $child_values->name;
												break;
											}
										}
										

								
										// если в новом родительском отделе нет группы с называнием, на которое требуется изменить подгруппу данного товара
										if(!$podgruppa_tid)
										{
											$shop_item['Действие / результат'] = 'change error: нельзя изменить подгруппу товара на ' . $zp_new_artikuls['Подгруппа / тип элемента'] . ', так как в родительском отделе не задана такая группа '; 
											return $shop_item;
										}
								
										
   							
    									// меняем терм родителя товара на терм нового родителя - подгруппы $podgruppa_tid
										if(
											!db_query("UPDATE {term_node} SET tid = %d WHERE nid = %d", $podgruppa_tid, $node->nid)
								  	  	  )
								  	  	  {
											$shop_item['Действие / результат'] = 'change error: ошибка при изменении подгруппы товара на ' . $zp_new_artikuls['Подгруппа / тип элемента']; 
											return $shop_item;
	  							  	  	  }
									 	
									 } // end of if ($zp_old_artikuls['Подгруппа / тип элемента'] != $zp_new_artikuls['Подгруппа / тип элемента']) 
									 
										
								} // end of else // если родительский отдел не изменился
								
								break; // end of case 'товар':
								
								
								
							default:
								break;
								 
					   } // end of switch($zp_element['type']) // перебор типов элемента для изменения артикула, подгруппы, называния для некоторых типов
					
					   
					   
					
					   
					// после обработки данных по артикулам помещаем в поля номеров в артикуле сохранённые строки с историей, 
					// убирая маркер изменения ### с начала строки (что значит, что при следующей итерации это поле изменяться не будет)
					foreach ($new_value_with_history as $key => $value)
					{
						// после внесения в базу, сохраняем в поле с названием полную историю изменения названия, лишь убрав из ней первые три символа ### (если они там были)
	 					// перед этим восстанвливаем первоначальный вид кавчек, если они были
						$shop_item[$key] = zp_restore_quotes($new_value_with_history[$key]); // восстанавливаем полное значение поля, если оно имело историю (убирая признак изменения элемента, если он стоял вначале строки.... остальные разделители версий и сами версии названия остаются)
					}	   
					   
					
					
					
					
					
					
					
					
					// если изменился артикул, производим необходимые изменения и по количеству товара...
					
					if($zp_element['zp_artikul'] != $zp_element['zp_old_artikul'])
					{
						// нужно изменить артикул в таблице с количеством товара
						// иначе оно там остаётся старым, и количество товара перестаёт отслеживаться
						
						// для того, чтобы обновить артикул в таблице с количеством товара, нужно, чтобы в поле 'Кол-во' вначале стояли маркеры ### на изменение
						// если не стоят, добавим, а затем добавим это поле в список полей на изменение $shop_item_changed
						$kol_vo = $shop_item['Кол-во'];
						
						// уберём управляющие символы из поля, если они там есть, и возьмём последнее значение
						$markers = FALSE;
						if($kol_vo[0] . $kol_vo[1] . $kol_vo[2] != '###') // управляющие символы в начале строки
		 				{
							$shop_item_changed['Кол-во'] = '###' . $shop_item['Кол-во'];
		 				}
					
					} // end of if($zp_element['zp_artikul'] != $zp_element['zp_old_artikul']) // если изменился артикул, производим необходимые изменения по логотипам и количеству товара...
					

					   
	   			// конец предварительного определения исходных (и новых) значений артикула, связей и названий картинок, связанных с изменением названием или с изменением артикула
					   
				} // end of if($artikul_changes_exists) // если какой-то из номеров артикула изменился
				
				
				
				
				
				
				
				// проверим нужно ли изменять поле Другие атрибуты товара
				// и зададим начальные данные по атрибутам (разберём строку в поле на переменные в массиве)
				// если строка атрибутов задана неправильно, выходим с ошибкой
				
		
				$value = zp_correct_quotes($shop_item['Другие атрибуты товара']);
				$key = 'Другие атрибуты товара'; 
				
				
				if($zp_element['type'] == 'товар' AND $value[0] . $value[1] . $value[2] == '###') // управляющие символы в начале строки
		 		{
					$value = explode('###', $value);
		   	
					foreach($value as $k => $val)
					{
						if($k == 0 OR $k == 1)
		      		  		$new_value_with_history[$key] = $new_value_with_history[$key] . $val;
		    			else  
		      		  		$new_value_with_history[$key] = $new_value_with_history[$key] . '###' . $val;  
					} 
			
					$zp_element['другие_атрибуты_товара'] = $value[1];

					//if(!$zp_element['другие_атрибуты_товара'] OR $zp_element['другие_атрибуты_товара'] == 'Нет' OR $zp_element['другие_атрибуты_товара'] == 'нет' OR $zp_element['другие_атрибуты_товара'] == '0' OR $zp_element['другие_атрибуты_товара'] == 0 OR $zp_element['другие_атрибуты_товара'] == ' ')
					if(!$zp_element['другие_атрибуты_товара'] OR $zp_element['другие_атрибуты_товара'] == 'Нет' OR $zp_element['другие_атрибуты_товара'] == 'нет' OR $zp_element['другие_атрибуты_товара'] == '0' OR $zp_element['другие_атрибуты_товара'] == ' ')
					{
						$zp_element['другие_атрибуты_товара'] = 'нет';
					}
					else 
					{
						
						// проверим, правильно ли задана строка с атрибутами
						// и разберём исходную строку в массив

     	 
     					//$string = 'text***Цвет***Описание атрибута[Красный^^^0---Зелёный^^^3,40]select***Размер[24^^^1.20---43^^^5.21]';

						if(strpos($zp_element['другие_атрибуты_товара'], ']') === FALSE)
 							$error_format = 1;
 
						$str = explode(']', $zp_element['другие_атрибуты_товара']);

						$count = 0;
						foreach($str as $atr)
						{
							if(!$atr)
	 							continue;
		 
							$xxx = array();
	
							if(strpos($atr, '[') === FALSE)
								$error_format = 1;
 
							$atr = explode('[', $atr);
							//$atr_name_type = $atr[0];
	
							if(strpos($atr[0], '***') === FALSE)
								$error_format = 1;
	
							$atr_name_type = explode('***', $atr[0]);
			
							$atr_type = $atr_name_type[0];
			
							if($atr_type != 'text' AND $atr_type != 'select' AND $atr_type != 'radio')
							{
								$shop_item['Действие / результат'] = 'new error: Неверный формат строки с атрибутами ' . $zp_element['другие_атрибуты_товара'] . '. Тип атрибута может быть только text, select, radio, а задан -' . $atr_type . '-'; 
								return $shop_item;
							}     
			
							$atr_name = $atr_name_type[1];
							$atr_descr = $atr_name_type[2];
	
							if(strpos($atr[1], '---') === FALSE)
								$error_format = 1;
		
							$atr = explode('---', $atr[1]);
			
							$count_options = 0;
							foreach($atr as $options)
							{
								$count_options++;
				
								if(strpos($options, '^^^') === FALSE)
									$error_format = 1;
		
								$option = explode('^^^', $options);
				
				
								// $option[0] - название опции
								// $option[1] - добавка к стоимости, грн
				
								// если в числе содержится не точка, а запятая, меняем запятую на точку
								if(strpos($option[1], ',') !== FALSE)
									$option[1] = str_replace(',', '.', $option[1]);
				
								// Стоимость первой опции в атрибуте должна быть нулевой, тогда цена будет правильно отображаться для пользователя
								// иначе отображаться будет по умолчанию нулевая цена при выбранной опции с ненулевой добавочной ценой
								if($count_options == 1 AND ($option[1] != 0 AND $option[1] != '0.0' AND $option[1] != '0.00' AND $option[1] != '00.00' AND $option[1] != '00.0' AND $option[1] != '' AND $option[1] != ' '))
								{
									$shop_item['Действие / результат'] = 'new error: Неверный формат строки с атрибутами ' . $zp_element['другие_атрибуты_товара'] . '. Стоимость первой опции -' . $option[0] . '- в атрибуте -' . $atr_name . '- должна быть нулевой!'; 
									return $shop_item;
								}
		
								$xxx[$option[0]] = $option[1];
							}
			
							$attributes[$count]['descr'] = $atr_descr;
							$attributes[$count]['type'] = $atr_type;
							$attributes[$count]['name'] = $atr_name;
							$attributes[$count]['options'] = $xxx;
	
							$count++;
						}

						if($error_format == 1)
						{
							$shop_item['Действие / результат'] = 'change error: Неверный формат строки с атрибутами ' . $zp_element['другие_атрибуты_товара']; 
							return $shop_item;
	   					}
	   	
	   					$zp_element['другие_атрибуты_товара'] = $attributes;
	   					
					}
					
	
		 		} // end of if($zp_element['type'] == 'товар' AND $value[0] . $value[1] . $value[2] == '###')
		 		 	// end of проверим нужно ли изменять поле Другие атрибуты товара
					// и зададим начальные данные по атрибутам (разберём строку в поле на переменные в массиве)
					// если строка атрибутов задана неправильно, выходим с ошибкой
	 			
	 			
	 			
	
				
					
					
					
					
						
						
						
					
				
				
			
					
					
				
	//-----------------------------------------------------------------------------------------------------------------------------------------				
	//---------------------------------------------------------------------------------------------------------------
	// -------------------------------------------------------------------------------------
	// теперь последовательно изменяем остальные поля, которые нужно изменить

	
				
	// отметим факт изменения элемента, изменив дату изменения и юзера для ноды и её ревизии	

	global $user;
	$node->uid = $user->uid;
						 
	if(
		!db_query("UPDATE {node} SET uid = %d, changed = %d WHERE nid = %d AND vid = %d", $node->uid, time(), $node->nid, $node->vid)
			OR
		!db_query("UPDATE {node_revisions} SET uid = %d, timestamp = %d WHERE nid = %d AND vid = %d", $node->uid, time(), $node->nid, $node->vid)
	  )
	  {
		$shop_item['Действие / результат'] = 'change error: ошибка при обновлении времени изменения элемента и идентификатора пользователя, производящего изменения' . $key . 'в базе на значение ' . $value; 
		return $shop_item;
	  }


	
	// последовательно изменяем в элементе все поля, которые требуют изменения, в зависимости от названия поля			
	foreach($shop_item_changed as $key => $value)
	{


		// исправим лишние кавычки, если есть
		$value = zp_correct_quotes($value);
			
		
		// для начала извлечём из значения поля ту часть, которая должна быть записана как новое значение
		// и сохраним всю историю изменений, удалив признак изменения для записи результирубщей таблицы
		$new_value_with_history = FALSE;
		if($value[0] . $value[1] . $value[2] == '###') // управляющие символы в начале строки
		{
			$value = explode('###', $value);
		  	
			foreach($value as $k => $val)
			{
				if($k == 0 OR $k == 1)
		 		  $new_value_with_history = $new_value_with_history . $val;
				else  
		 		  $new_value_with_history = $new_value_with_history . '###' . $val;  
			} 
			
			$value = $value[1];
		}
		 		
		

		// -------------------------------------------------------------------
		
	

		
		// перебираем значения полей, вернее, выбираем какое поле обрабатывается на очередной итерации	
		// в данном случае поля, которые касаются в основном разных элементов	
		switch($key) 
		{
			
			case 'Название': 
			
				// поле название используется для названий всех элементов, кроме подгруппы и подотдела
				// а для подотдела и подгруппы название расположено в поле 'Название сокращённое'
				if($zp_element['type'] == 'подотдел' OR $zp_element['type'] == 'подгруппа')
					break;
					
				// изменяем значение поля название в двух таблицах, содержащих название
				if(
					!db_query("UPDATE {node} SET title = '%s' WHERE nid = %d AND vid = %d", $value, $node->nid, $node->vid)
				       OR
				    !db_query("UPDATE {node_revisions} SET title = '%s' WHERE nid = %d AND vid = %d", $value, $node->nid, $node->vid)
				  )
				  {
				  	$shop_item['Действие / результат'] = 'change error: ошибка при изменении поля -' . $key . '- в базе на значение ' . $value; 
						return $shop_item;
				  }

				  
				break;
				
				
			case 'Название сокращённое':
				
				// поле название используется для названий всех элементов, кроме подгруппы и подотдела
				// а для подотдела и подгруппы название расположено в поле 'Название сокращённое'
				if($zp_element['type'] != 'подотдел' AND $zp_element['type'] != 'подгруппа')
					break;
					
				// изменяем значение поля название в двух таблицах, содержащих название
				if(
					!db_query("UPDATE {node} SET title = '%s' WHERE nid = %d AND vid = %d", $value, $node->nid, $node->vid)
				       OR
				    !db_query("UPDATE {node_revisions} SET title = '%s' WHERE nid = %d AND vid = %d", $value, $node->nid, $node->vid)
				  )
				  {
				  	$shop_item['Действие / результат'] = 'change error: ошибка при изменении поля -' . $key . '- в базе на значение ' . $value; 
						return $shop_item;
				  }

				
				break;	
				
				
				
			case 'Подгруппа / тип элемента': 
							
				switch($zp_element['type'])
				{
					// подгруппа может измениться только у товара и она изменяется путём изменения ссылок на термы
					// это было сделано ранее на этапе проверки изменения артикула
					// значит на данном этапе может только измениться тип элемента (вообще-то это описательное поле типа "магазинчик, супермаркет, городок, посёлок и т.д.")
					case 'страна':
					case 'населённый пункт': // обычно город
					case 'район':
					case 'магазин':
					case 'подотдел':

						// тип элемента размещается в одном поле с количеством картинок элемента и каталогом картинок типа продукта field_placetype_n_numofphotos
						// поэтому нужно считать это поле, заменить в нём тип элемента (а всё остальное оставить прежним пока) и обновить поле с новым значением
						
						if(
							!($field_to_change = db_result(db_query("SELECT field_placetype_n_numofphotos_value FROM {content_field_placetype_n_numofphotos} WHERE nid = %d", $node->nid)))
				  	   	  )
				  	      {
				  			$shop_item['Действие / результат'] = 'change error: ошибка при получении из базы поля с типом элемента и кол-вом картинок'; 
							return $shop_item;
				  	      }
				
				  	    $field_to_change = explode(';', $field_to_change); 
				  	    $field_to_change =  $value . ';' . $field_to_change[1] . ';' . $field_to_change[2];
						 
						if(
							!db_query("UPDATE {content_field_placetype_n_numofphotos} SET field_placetype_n_numofphotos_value = '%s' WHERE nid = %d", $field_to_change, $node->nid)
				  	   	  )
				  	      {
				  			$shop_item['Действие / результат'] = 'change error: ошибка при изменении поля -' . $key . '- в базе на значение ' . $value; 
							return $shop_item;
				  	      }
			
				  	    break;
				  	      
					default:
						break;
				  
				}
				  
				break;
			

				

				
				
				
				
			case 'Описание локальное (отдела, магазина, района и т.д.)': 

				$value_teaser = substr($value, 0, 100); // записываем тизер длиной 100 символов из основного текста. Кстати, по усолчанию друпал записывает около 323 символов, но нам столько слишком много для тизеров отделов и т.д.
					
				if(
					!db_query("UPDATE {node_revisions} SET body = '%s', teaser = '%s' WHERE nid = %d AND vid = %d", $value, $value_teaser, $node->nid, $node->vid)
				  )
				  {
					$shop_item['Действие / результат'] = 'change error: ошибка при изменении поля' . $key . 'в базе на значение ' . $value; 
					return $shop_item;
				  }

				break;
				
				
			
				
			case 'Ключевые слова': 
			
				// для всех элементов, кроме товара, ключевые слова без всяких условий записываются локально в текущий элемент
				if($zp_element['type'] == 'товар')
					break;
				
				

				if(
					!db_result(db_query("SELECT vid FROM {content_field_keywords} WHERE nid = %d", $node->nid))
				  )
				  {
					if(!db_query("INSERT INTO {content_field_keywords} (vid, nid, field_keywords_value) VALUES (%d, %d, '%s')", $node->vid, $node->nid, $value))
			  			{
							$shop_item['Действие / результат'] = 'change error: ошибка при локальном добавлении ключевых слов в тип -' . $zp_element['type'] . '-';
							return $shop_item;
			  			}
				  }
				else
				  { 
				    if( 
				 		!db_query("UPDATE {content_field_keywords} SET field_keywords_value = '%s' WHERE nid = %d AND vid = %d", $value, $node->nid, $node->vid)
				      )
				      {
				  		$shop_item['Действие / результат'] = 'change error: ошибка при изменении поля -' . $key . '- в базе на значение ' . $value; 
						return $shop_item;
				      }
				  }
				  
				break;	
				
				
				
						
			case 'Адрес': 
			

				switch($zp_element['type'])
				{
					case 'страна':
					case 'населённый пункт': // обычно город
					case 'район':
					case 'магазин':
					case 'подотдел':	

						if(
							!($address_nid = db_result(db_query("SELECT vid FROM {content_field_place_address} WHERE nid = %d", $node->nid)))
						  )
						  {
				  			if( // если адрес не был задан изначально, попытаться его внести
						  		!db_query("INSERT INTO {content_field_place_address} (field_place_address_value, nid, vid) VALUES ('%s', %d, %d)", $value, $node->nid, $node->vid)
						      )
						      {
						  		$shop_item['Действие / результат'] = 'change error: ошибка при добавлении поля -' . $key . '- в базе на значение ' . $value; 
								return $shop_item;
						      }
				  		  }
				  		else
				  		  { 
				  		    if( // если адрес был задан изначально, изменить его
						  		!db_query("UPDATE {content_field_place_address} SET field_place_address_value = '%s' WHERE nid = %d AND vid = %d", $value, $node->nid, $node->vid)
						      )
						      {
						  		$shop_item['Действие / результат'] = 'change error: ошибка при изменении поля -' . $key . '- в базе на значение ' . $value; 
								return $shop_item;
						      }
				  		  }
						break;						

						
						
					default:
						break;
				}
				
				break; // end of case 'Адрес': 
			
				
				
				
				
				
				
				
			case 'Кол-во картинок':
				
				switch($zp_element['type']) // получим данные о заданных в базе картинках
				{
					
					case 'страна':
					case 'населённый пункт': // обычно город
					case 'район':
					case 'магазин':
					case 'подотдел':						

						// количество картинок для этого типа записи размещается в одном поле с типом элемента  и каталогом картинок типа продукта field_placetype_n_numofphotos
						// поэтому нужно считать это поле, заменить в нём количество картинок (а всё остальное оставить прежним пока) и обновить поле с новым значением
						
						if(
							!($field_to_change = db_result(db_query("SELECT field_placetype_n_numofphotos_value FROM {content_field_placetype_n_numofphotos} WHERE nid = %d", $node->nid)))
				  	   	  )
				  	      {
				  			$shop_item['Действие / результат'] = 'change error: ошибка при получении из базы поля с типом элемента и кол-вом картинок для замены кол-ва картинок'; 
							return $shop_item;
				  	      }
				
				  	    $field_to_change = explode(';', $field_to_change); 
				  	    $field_to_change = $field_to_change[0] . ';' . $value . ';' . $field_to_change[2];
						 
						if(
							!db_query("UPDATE {content_field_placetype_n_numofphotos} SET field_placetype_n_numofphotos_value = '%s' WHERE nid = %d", $field_to_change, $node->nid)
				  	   	  )
				  	      {
				  			$shop_item['Действие / результат'] = 'change error: ошибка при изменении поля -' . $key . '- в базе на значение ' . $value; 
							return $shop_item;
				  	      }
			
				  	    break;
				  	      
				  	    
					    
					    
					case 'товар':
						
						// количество картинок для товара размещается в одном поле с названием каталога для картинок и источником названия картинок content_field_prodtype_pic_src_n_num
						// поэтому нужно считать это поле, заменить в нём количество картинок и обновить поле с новым значением
						
						
						if(
							!($field_to_change = db_result(db_query("SELECT field_prodtype_pic_src_n_num_value FROM {content_field_prodtype_pic_src_n_num} WHERE nid = %d", $node->nid)))
				  	   	  )
				  	      {
				  			$shop_item['Действие / результат'] = 'change error: ошибка при получении из базы поля с каталогом картинок, источником для названия картинок и кол-вом картинок для замены кол-ва картинок'; 
							return $shop_item;
				  	      }
				
				  	    $field_to_change = explode(';', $field_to_change); 
				  	    $field_to_change = $field_to_change[0] . ';' . $field_to_change[1] . ';' . $value . ';' . $field_to_change[3];
						 
						if(
							!db_query("UPDATE {content_field_prodtype_pic_src_n_num} SET field_prodtype_pic_src_n_num_value = '%s' WHERE nid = %d", $field_to_change, $node->nid)
				  	   	  )
				  	      {
				  			$shop_item['Действие / результат'] = 'change error: ошибка при изменении поля -' . $key . '- в базе на значение ' . $value; 
							return $shop_item;
				  	      }
						
						break;
						
						
						
						
					default: 
						break;
						
						
				}
				
				break;
				
				
				
				
			case 'На основе чего формируется название картинок':
				
				switch($zp_element['type']) // получим данные о заданных в базе картинках
				{
					
					    
					case 'товар':
						
						// поле 'На основе чего формируется название картинок' размещается в одном поле с названием каталога для картинок и количеством картинок для товара  content_field_prodtype_pic_src_n_num
						// поэтому нужно считать это поле, заменить в нём источник названия для картинок картинок и обновить поле с новым значением
						
						if(
							!($field_to_change = db_result(db_query("SELECT field_prodtype_pic_src_n_num_value FROM {content_field_prodtype_pic_src_n_num} WHERE nid = %d", $node->nid)))
				  	   	  )
				  	      {
				  			$shop_item['Действие / результат'] = 'change error: ошибка при получении из базы поля с каталогом картинок, источником для названия картинок и кол-вом картинок для замены источника названия картинок'; 
							return $shop_item;
				  	      }
				
				  	    $field_to_change = explode(';', $field_to_change); 
				  	    $field_to_change = $field_to_change[0] . ';' . $value . ';' . $field_to_change[2] . ';' . $field_to_change[3];
						 
						if(
							!db_query("UPDATE {content_field_prodtype_pic_src_n_num} SET field_prodtype_pic_src_n_num_value = '%s' WHERE nid = %d", $field_to_change, $node->nid)
				  	   	  )
				  	      {
				  			$shop_item['Действие / результат'] = 'change error: ошибка при изменении поля -' . $key . '- в базе на значение ' . $value; 
							return $shop_item;
				  	      }
						

						break;
						
						
					default: 
						break;
						
				}

				break;	// end of case 'На основе чего формируется название картинок':	
				
				
				
				
				
			
				
			case 'Каталог с картинками':
				
				switch($zp_element['type']) // получим данные о заданных в базе картинках
				{
					
					
					case 'страна':
					case 'населённый пункт': // обычно город
					case 'район':
					case 'магазин':
					case 'подотдел':						

						// каталогом картинок типа продукта для этого типа записи размещается в одном поле с  количество картинок  и типом элемента field_placetype_n_numofphotos
						// поэтому нужно считать это поле, заменить в нём каталог картинок (а всё остальное оставить прежним пока) и обновить поле с новым значением
						
						if(
							!($field_to_change = db_result(db_query("SELECT field_placetype_n_numofphotos_value FROM {content_field_placetype_n_numofphotos} WHERE nid = %d", $node->nid)))
				  	   	  )
				  	      {
				  			$shop_item['Действие / результат'] = 'change error: ошибка при получении из базы поля с типом элемента и кол-вом картинок для замены кол-ва картинок'; 
							return $shop_item;
				  	      }
				
				  	    $field_to_change = explode(';', $field_to_change); 
				  	    $field_to_change = $field_to_change[0] . ';' . $field_to_change[1] . ';' . $value;
						 
						if(
							!db_query("UPDATE {content_field_placetype_n_numofphotos} SET field_placetype_n_numofphotos_value = '%s' WHERE nid = %d", $field_to_change, $node->nid)
				  	   	  )
				  	      {
				  			$shop_item['Действие / результат'] = 'change error: ошибка при изменении поля -' . $key . '- в базе на значение ' . $value; 
							return $shop_item;
				  	      }
			
				  	    break;
					
					
					
					
					    
					case 'товар':
						
						//  поле с названием каталога для картинок размещается в одном поле с  'На основе чего формируется название картинок' и количеством картинок для товара  content_field_prodtype_pic_src_n_num
						// поэтому нужно считать это поле, заменить в нём названием каталога картинок и обновить поле с новым значением
						
						if(
							!($field_to_change = db_result(db_query("SELECT field_prodtype_pic_src_n_num_value FROM {content_field_prodtype_pic_src_n_num} WHERE nid = %d", $node->nid)))
				  	   	  )
				  	      {
				  			$shop_item['Действие / результат'] = 'change error: ошибка при получении из базы поля с каталогом картинок, источником для названия картинок и кол-вом картинок для замены источника названия картинок'; 
							return $shop_item;
				  	      }
				
				  	    $field_to_change = explode(';', $field_to_change); 
				  	    $field_to_change = $value . ';' . $field_to_change[1] . ';' . $field_to_change[2] . ';' . $field_to_change[3];
						 
						if(
							!db_query("UPDATE {content_field_prodtype_pic_src_n_num} SET field_prodtype_pic_src_n_num_value = '%s' WHERE nid = %d", $field_to_change, $node->nid)
				  	   	  )
				  	      {
				  			$shop_item['Действие / результат'] = 'change error: ошибка при изменении поля -' . $key . '- в базе на значение ' . $value; 
							return $shop_item;
				  	      }
						

						break;
						
						
					default: 
						break;
						
				}

				break;	// end of case 'Каталог с картинками':	
				
				
				
				
				
				
			case 'Ориентация картинок':
				
				switch($zp_element['type']) // получим данные о заданных в базе картинках
				{
					
					    
					case 'товар':
						
						//  поле с ориентацией картинок размещается в одном поле с  с названием каталога для картинок, с полем 'На основе чего формируется название картинок' и количеством картинок для товара  content_field_prodtype_pic_src_n_num
						// поэтому нужно считать это поле, заменить в нём названием каталога картинок и обновить поле с новым значением
						
						if(
							!($field_to_change = db_result(db_query("SELECT field_prodtype_pic_src_n_num_value FROM {content_field_prodtype_pic_src_n_num} WHERE nid = %d", $node->nid)))
				  	   	  )
				  	      {
				  			$shop_item['Действие / результат'] = 'change error: ошибка при получении из базы поля с каталогом картинок, источником для названия картинок и кол-вом картинок для замены источника названия картинок'; 
							return $shop_item;
				  	      }
				
				  	    $field_to_change = explode(';', $field_to_change); 
				  	    $field_to_change = $field_to_change[0] . ';' . $field_to_change[1] . ';' . $field_to_change[2] . ';' . $value;
						 
						if(
							!db_query("UPDATE {content_field_prodtype_pic_src_n_num} SET field_prodtype_pic_src_n_num_value = '%s' WHERE nid = %d", $field_to_change, $node->nid)
				  	   	  )
				  	      {
				  			$shop_item['Действие / результат'] = 'change error: ошибка при изменении поля -' . $key . '- в базе на значение ' . $value; 
							return $shop_item;
				  	      }
						

						break;
						
						
					default: 
						break;
						
				}

				break;	// end of case 'Каталог с картинками':	
				
				
				

				
				

			case 'Коэффициент доставки':
				
				// если в числе содержится не точка, а запятая, меняем запятую на точку
				if(strpos($value, ',') !== FALSE)
					$value = str_replace(',', '.', $value);

				
	    		if
	 			(
					!db_query("UPDATE {content_field_d_factor} SET field_d_factor_value = %f WHERE vid = %d AND nid = %d", $value, $node->vid, $node->nid)
				)
				{
					$shop_item['Действие / результат'] = 'change error: ошибка при изменении фактора доставки элемента'; 
					return $shop_item;
				}
				
				break;					
				
				
				
				
				
				
			case 'Коэффициент минимальной суммы покупки (корзины)':
				
				// для магазина
				
				// если в числе содержится не точка, а запятая, меняем запятую на точку
				if(strpos($value, ',') !== FALSE)
					$value = str_replace(',', '.', $value);
				
	    		if
	 			(
					!db_query("UPDATE {content_field_cart_min_sum_f} SET field_cart_min_sum_f_value = %f WHERE vid = %d AND nid = %d", $value, $node->vid, $node->nid)
				)
				{
					$shop_item['Действие / результат'] = 'change error: ошибка при изменении Коэффициента минимальной суммы покупки (корзины)'; 
					return $shop_item;
				}
				
				break;	 // end of case 'Коэффициент минимальной суммы покупки (корзины)'

			
			
				
				
							
						
			case 'Статус элемента':	
			
				if($zp_element['type'] == 'подгруппа') // подгруппа не может иметь статуса, поэтому пропускаем это поле
					break;

					
				if(
					!($old_status = db_result(db_query("SELECT field_status_value FROM {content_field_status} WHERE nid = %d", $node->nid)))
		  		  )
		  		  {
		  			if( // если значение не было задано изначально, попытаться его внести
						!db_query("INSERT INTO {content_field_status} (vid, nid, field_status_value) VALUES (%d, %d, '%s')", $node->vid, $node->nid, $value)
			  		  )
			  		  {
						$shop_item['Действие / результат'] = 'change error: ошибка при изменении в базе поля -' . $key . '- на значение ' . $value; 
						return $shop_item;
			  	  	  }
		  		  }
		  		else
		  		  { 
		    		if( 
						!db_query("UPDATE {content_field_status} SET field_status_value = '%s' WHERE nid = %d", $value, $node->nid)
			  		  )
			  		  {
						$shop_item['Действие / результат'] = 'change error: ошибка при изменении поля -' . $key . '- в базе на значение ' . $value; 
						return $shop_item;
			  		  }
		  		  }
				  		  
				
						
				  		  
		  		// теперь обновим связи элемента (не товара), если это нужно:
				  		
				// если элемент скрывается, то должнен быть скрыт и терм, связанный с этим элементом, 
				// иначе останется видимым пункт меню, который не будет никуда вести
				  		
				// но терм скрывается для любого элемента, кроме товара, так как товар имеет терм подгруппы,
				// к которой он принадлежит, и скрытие этого терма повлечёт скрытие всей группы товаров, вместо одного этого товара
				// сам товар и так скрывается, путём не показывания его (с учётом статуса) в вьюсах и шаблоне типа товара
				
				//  так что если этот элемент - товар, переходим к обработке следующих полей 
				if($zp_element['type'] == 'товар')
					break;
				
					
					
					
				// иначе (если этот элемент не товар) продолжаем изменения, касающиеся статуса текущего элемента
					
				$new_status = $value;
				
				if(!$old_status) // если в базе нет записи о статусе элемента, считаем, что предыдущий статус - нормальный (не скрытый)
					$old_status = 'normal';
					
				if($old_status == 'hidden' AND $new_status != 'hidden') // если статус меняется со скрытого на любой другой, нужно будет восстановить связи элемента (данные по термам), которые должны были быть изменены ранее при скрытии элемента
					$action = 'unhide';

				if($old_status != 'hidden' AND $new_status == 'hidden') // если статус меняется на скрытый с любого другого, нужно изменить связи элемента (данные по термам) для того, чтобы вместе с элементом был скрыт и соответствующий пункт меню
					$action = 'hide';

					
				if($action == 'hide')
				{
							
					// прячем пункт меню, связанный с этим элементом
							
					// вясним номер тида из каталога, связанный с этим элементом
					$element_tids = taxonomy_node_get_terms_by_vocabulary($node->nid, 1);
   					foreach($element_tids as $element_tid)
    				{
     					//$element_tid_name = $element_tid->name;
     					$element_tid = $element_tid->tid;
    				}
    						
    				// изменим тид на тид+0000.... когда впоследствии для элемента будет снят статус hidden, значение этого тида надо будет восстановить
					$new_tid = $element_tid . '0000';
					db_query("UPDATE {term_data} SET tid = %d WHERE tid = %d", $new_tid, $element_tid);
							
					// привяжем к этому новому тиду текущий нид (чтобы не потерять номер тида и потом его восстановить)
					db_query("UPDATE {term_node} SET tid = %d WHERE tid = %d AND nid = %d ", $new_tid, $element_tid, $node->nid);
						
				}	
				
				if($action == 'unhide')
				{
							
					// восстанавливаем пункт меню, связанный с этим элементом
							
					// вясним номер тида из каталога, связанный с этим элементом
					$element_tids = taxonomy_node_get_terms_by_vocabulary($node->nid, 1);
   					foreach($element_tids as $element_tid)
    				{
     					$element_tid_name = $element_tid->name;
     					$element_tid = $element_tid->tid;
    				}
    						
										
					// восстановим оригинальное значение тида, которое в изменённом виде сейчас должно иметь вид в базе "исходный тид+0000"

					// вычислим длину и уберём последние четыре символа
					$lenght = strlen($element_tid);
					for($count = 1; $count <= ($lenght - 4); $count++ )
					{
						$new_tid = $new_tid . $element_tid[$count-1]; // $count-1 потому, что нумерация в массиве идёт от нуля, а количество символов массива считаем от единицы
					}
						    
					// запишем в базу восстановленный тид
					db_query("UPDATE {term_data} SET tid = %d WHERE tid = %d", $new_tid, $element_tid);
							
					// привяжем к этому восстановленному тиду текущий нид
					db_query("UPDATE {term_node} SET tid = %d WHERE tid = %d AND nid = %d ", $new_tid, $element_tid, $node->nid);

				}
						
						
						  
				  		  
				break; // end of case 'Статус элемента':	
						
				
				
				
				
				
			
				
			case 'Вес элемента в группе':
				
				switch($zp_element['type']) 
				{
					
					
					case 'страна':
					case 'населённый пункт': // обычно город
					case 'район':
					case 'магазин':
					case 'подотдел':

						//echo 'zp_element[новое_название] = ' . $zp_element['новое_название'] . '<br>';
						//echo 'element_tid = ' . $element_tid . '<br>';
						//echo 'zp_element[вес_элемента_в_группе] = ' . $zp_element['вес_элемента_в_группе'] . '<br>';
						
						
						// зададим значение веса для элемента, если оно не было задано, и обновим, если было
						if(($old_weight = db_result(db_query("SELECT field_weight_ingroup_value FROM {content_field_weight_ingroup} WHERE nid = %d AND vid = %d", $node->nid, $node->vid))) !== FALSE)
				  		{
						 	if($old_weight != $value) // изменяем в базе, если только значение изменилось
						 	{
						 		
						 		if(!db_query("UPDATE {content_field_weight_ingroup} SET field_weight_ingroup_value = %d WHERE nid = %d AND vid = %d", $value, $node->nid, $node->vid))
						 		{
				  					$shop_item['Действие / результат'] = 'change error: ошибка при изменении поля -' . $key . '- в базе на значение ' . $value; 
									return $shop_item;
				      			}
						 	}		  
				      					  
				  		}
						else
				 		{ 
				    		if(!db_query("INSERT INTO {content_field_weight_ingroup} (vid, nid, field_weight_ingroup_value) VALUES (%d, %d, %d)", $node->vid, $node->nid, $value))
			  				{
								$shop_item['Действие / результат'] = 'change error: ошибка при добавлении веса элемента -' . $value . '-';
								return $shop_item;
			  				}	
				  		}
				  		
						
						
						
						// обновим порядок пунктов в меню
						
						if(
							!db_query("UPDATE {term_data} SET weight = %d WHERE tid = %d", $zp_element['вес_элемента_в_группе'], $element_tid)
						  )
						  {
							$shop_item['Действие / результат'] = 'change error: ошибка при изменении веса элемента на новый: ' . $zp_element['вес_элемента_в_группе'] . ' '; 
							return $shop_item;
	  					  }					


				  	    break;
					
				  	    
				  	    
					
					case 'товар': // для элемента меню не изменяем
						
						//echo 'zp_element[новое_название] = ' . $zp_element['новое_название'] . '<br>';
						//echo 'element_tid = ' . $element_tid . '<br>';
						//echo 'zp_element[вес_элемента_в_группе] = ' . $zp_element['вес_элемента_в_группе'] . '<br>';
						
						
						// зададим значение веса для элемента, если оно не было задано, и обновим, если было
						if(($old_weight = db_result(db_query("SELECT field_weight_ingroup_value FROM {content_field_weight_ingroup} WHERE nid = %d AND vid = %d", $node->nid, $node->vid))) !== FALSE)
				  		{
						 	if($old_weight != $value) // изменяем в базе, если только значение изменилось
						 	{
						 		
						 		if(!db_query("UPDATE {content_field_weight_ingroup} SET field_weight_ingroup_value = %d WHERE nid = %d AND vid = %d", $value, $node->nid, $node->vid))
						 		{
				  					$shop_item['Действие / результат'] = 'change error: ошибка при изменении поля -' . $key . '- в базе на значение ' . $value; 
									return $shop_item;
				      			}
						 	}		  
				      					  
				  		}
						else
				 		{ 
				    		if(!db_query("INSERT INTO {content_field_weight_ingroup} (vid, nid, field_weight_ingroup_value) VALUES (%d, %d, %d)", $node->vid, $node->nid, $value))
			  				{
								$shop_item['Действие / результат'] = 'change error: ошибка при добавлении веса элемента -' . $value . '-';
								return $shop_item;
			  				}	
				  		}
				  		
				  		break;
					
				  		
				  		
					    
					case 'подгруппа': // для подгруппы изменяем только меню
						
						
						// определим тид текущего (старого) родительского отдела
						
						//echo 'parent_nid = ' . $parent_nid . '<br>';
						//echo 'zp_element[новое_название] = ' . $zp_element['новое_название'] . '<br>';

						
						$parent_tids = taxonomy_node_get_terms_by_vocabulary($parent_nid, 1);
   						foreach($parent_tids as $parent_tid)
    					{
     						$parent_tid_name = $parent_tid->name;
     						$parent_tid = $parent_tid->tid;
    					}

    					// найдём всех потомков текущего (старого) родительского отдела, у которых нет своих детей, т.е., найдём все подгруппы родительского отдела, если он их имеет
    					// и среди них найдём потомка с названием текущей подгруппы и возьмём его тид
						$parent_tid_children = taxonomy_get_children($parent_tid, 1, 'name'); // taxonomy_get_children($tid, $vid = 0, $key = 'tid');
						$current_podgruppa_tid = FALSE;
						foreach($parent_tid_children as $child_name => $child_values)
						{
							if(taxonomy_get_children($child_values->tid, 1, 'name'))
						  		continue; // если потомок имеет своих потомков, значит это не подгруппа, а подотдел-потомок, а нам нужна группа!
								
							//if($child_name == $zp_element['старое_название'])
							if($child_name == $zp_element['новое_название']) // название к этому моменту уже изменено, если было задано изменение
							{
								$current_podgruppa_tid = $child_values->tid;
								$current_podgruppa_tid_name = $child_values->name;
								break;
							}
						}
										
						// если в текущем (старом) родительском отделе нет такой подгруппы (исходной, неизменённой), которой мы хотим изменить артикул
						if(!$current_podgruppa_tid)
						{
							$shop_item['Действие / результат'] = 'change error: ошибка при изменении веса элемента (подгруппы) в группе: в данном отделе в базе нет подгруппы с названием ' . $zp_element['новое_название'] . ', у которой вы пытаетесь изменить вес в группе'; 
							return $shop_item;
						}
						
						
						if(
							!db_query("UPDATE {term_data} SET weight = %d WHERE tid = %d", $zp_element['вес_элемента_в_группе'], $current_podgruppa_tid)
						  )
						  {
							$shop_item['Действие / результат'] = 'change error: ошибка при изменении веса элемента на новый: ' . $zp_element['вес_элемента_в_группе'] . ' '; 
							return $shop_item;
	  					  }		


						break;
						
						
					default: 
						break;
						
				}

				break;	// end of case 'Каталог с картинками':	
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
			default:    // или любое другое поле, указанное в таблице, но (пока) не определённое в программе
				break;	
											
		} // end of switch($key) // перебираем значения полей, вернее, выбираем какое поле обрабатывается на очередной итерации
		
		
		
		
		
		
		// изменяем данные, которые касаются только товара
		if($zp_element['type'] == 'товар')
		{
			
				switch($key)
				{
					
					
					case 'Ш-код международный (1)':
				
						if(
							!db_result(db_query("SELECT vid FROM {content_field_zp_bar_world} WHERE nid = %d", $node->nid))
				  		  )
				  		  {
				  			if( // если значение не было задано изначально, попытаться его внести
								!db_query("INSERT INTO {content_field_zp_bar_world} (field_zp_bar_world_value, nid, vid) VALUES ('%s', %d, %d)", $value, $node->nid, $node->vid)
					  		  )
					  		  {
								$shop_item['Действие / результат'] = 'change error: ошибка при изменении в базе поля -' . $key . '- на значение ' . $value; 
								return $shop_item;
					  	  	  }
				  		  }
				  		else
				  		  { 
				    		if( 
								!db_query("UPDATE {content_field_zp_bar_world} SET field_zp_bar_world_value = '%s' WHERE nid = %d AND vid = %d", $value, $node->nid, $node->vid)
					  		  )
					  		  {
								$shop_item['Действие / результат'] = 'change error: ошибка при изменении поля -' . $key . '- в базе на значение ' . $value; 
								return $shop_item;
					  		  }
				  		  }

				
						break;
						
						
						
						
						
					case 'Ш-код производителя (2)':
				
						if(
							!db_result(db_query("SELECT vid FROM {content_field_zp_bar_proizv} WHERE nid = %d", $node->nid))
				  		  )
				  		  {
				  			if( // если значение не было задано изначально, попытаться его внести
								!db_query("INSERT INTO {content_field_zp_bar_proizv} (field_zp_bar_proizv_value, nid, vid) VALUES ('%s', %d, %d)", $value, $node->nid, $node->vid)
					  		  )
					  		  {
								$shop_item['Действие / результат'] = 'change error: ошибка при изменении в базе поля -' . $key . '- на значение ' . $value; 
								return $shop_item;
					  	  	  }
				  		  }
				  		else
				  		  { 
				    		if( 
								!db_query("UPDATE {content_field_zp_bar_proizv} SET field_zp_bar_proizv_value = '%s' WHERE nid = %d AND vid = %d", $value, $node->nid, $node->vid)
					  		  )
					  		  {
								$shop_item['Действие / результат'] = 'change error: ошибка при изменении поля -' . $key . '- в базе на значение ' . $value; 
								return $shop_item;
					  		  }
				  		  }

				
						break;
					
				
						
						
						
					case 'Артикул производителя (3)':
						
						if(
							!db_result(db_query("SELECT vid FROM {content_field_zp_art_proizv} WHERE nid = %d", $node->nid))
				  		  )
				  		  {
				  			if( // если значение не было задано изначально, попытаться его внести
								!db_query("INSERT INTO {content_field_zp_art_proizv} (field_zp_art_proizv_value, nid, vid) VALUES ('%s', %d, %d)", $value, $node->nid, $node->vid)
					  		  )
					  		  {
								$shop_item['Действие / результат'] = 'change error: ошибка при изменении в базе поля -' . $key . '- на значение ' . $value; 
								return $shop_item;
					  	  	  }
				  		  }
				  		else
				  		  { 
				    		if( 
								!db_query("UPDATE {content_field_zp_art_proizv} SET field_zp_art_proizv_value = '%s' WHERE nid = %d AND vid = %d", $value, $node->nid, $node->vid)
					  		  )
					  		  {
								$shop_item['Действие / результат'] = 'change error: ошибка при изменении поля -' . $key . '- в базе на значение ' . $value; 
								return $shop_item;
					  		  }
				  		  }
						
				
						break;
			
						
				
					case 'Ш-код поставщика (4)':
						
						if(
							!db_result(db_query("SELECT vid FROM {content_field_zp_bar_postav} WHERE nid = %d", $node->nid))
				  		  )
				  		  {
				  			if( // если значение не было задано изначально, попытаться его внести
								!db_query("INSERT INTO {content_field_zp_bar_postav} (field_zp_bar_postav_value, nid, vid) VALUES ('%s', %d, %d)", $value, $node->nid, $node->vid)
					  		  )
					  		  {
								$shop_item['Действие / результат'] = 'change error: ошибка при изменении в базе поля -' . $key . '- на значение ' . $value; 
								return $shop_item;
					  	  	  }
				  		  }
				  		else
				  		  { 
				    		if( 
								!db_query("UPDATE {content_field_zp_bar_postav} SET field_zp_bar_postav_value = '%s' WHERE nid = %d AND vid = %d", $value, $node->nid, $node->vid)
					  		  )
					  		  {
								$shop_item['Действие / результат'] = 'change error: ошибка при изменении поля -' . $key . '- в базе на значение ' . $value; 
								return $shop_item;
					  		  }
				  		  }
						
						
						break;
						
						
						
						
				
					case 'Артикул поставщика (5)':
						
						if(
							!db_result(db_query("SELECT vid FROM {content_field_zp_art_postav} WHERE nid = %d", $node->nid))
				  		  )
				  		  {
				  			if( // если значение не было задано изначально, попытаться его внести
								!db_query("INSERT INTO {content_field_zp_art_postav} (field_zp_art_postav_value, nid, vid) VALUES ('%s', %d, %d)", $value, $node->nid, $node->vid)
					  		  )
					  		  {
								$shop_item['Действие / результат'] = 'change error: ошибка при изменении в базе поля -' . $key . '- на значение ' . $value; 
								return $shop_item;
					  	  	  }
				  		  }
				  		else
				  		  { 
				    		if( 
								!db_query("UPDATE {content_field_zp_art_postav} SET field_zp_art_postav_value = '%s' WHERE nid = %d AND vid = %d", $value, $node->nid, $node->vid)
					  		  )
					  		  {
								$shop_item['Действие / результат'] = 'change error: ошибка при изменении поля -' . $key . '- в базе на значение ' . $value; 
								return $shop_item;
					  		  }
				  		  }

				
						break;
						
						
						
				
					case 'Ш-код магазина (6)':

						if(
							!db_result(db_query("SELECT vid FROM {content_field_zp_bar_shop} WHERE nid = %d", $node->nid))
				  		  )
				  		  {
				  			if( // если значение не было задано изначально, попытаться его внести
								!db_query("INSERT INTO {content_field_zp_bar_shop} (field_zp_bar_shop_value, nid, vid) VALUES ('%s', %d, %d)", $value, $node->nid, $node->vid)
					  		  )
					  		  {
								$shop_item['Действие / результат'] = 'change error: ошибка при изменении в базе поля -' . $key . '- на значение ' . $value; 
								return $shop_item;
					  	  	  }
				  		  }
				  		else
				  		  { 
				    		if( 
								!db_query("UPDATE {content_field_zp_bar_shop} SET field_zp_bar_shop_value = '%s' WHERE nid = %d AND vid = %d", $value, $node->nid, $node->vid)
					  		  )
					  		  {
								$shop_item['Действие / результат'] = 'change error: ошибка при изменении поля -' . $key . '- в базе на значение ' . $value; 
								return $shop_item;
					  		  }
				  		  }

				
						break;

						
				
						
					case 'Артикул магазина (7)':
						
						if(
							!db_result(db_query("SELECT vid FROM {content_field_zp_art_shop} WHERE nid = %d", $node->nid))
				  		  )
				  		  {
				  			if( // если значение не было задано изначально, попытаться его внести
								!db_query("INSERT INTO {content_field_zp_art_shop} (field_zp_art_shop_value, nid, vid) VALUES ('%s', %d, %d)", $value, $node->nid, $node->vid)
					  		  )
					  		  {
								$shop_item['Действие / результат'] = 'change error: ошибка при изменении в базе поля -' . $key . '- на значение ' . $value; 
								return $shop_item;
					  	  	  }
				  		  }
				  		else
				  		  { 
				    		if( 
								!db_query("UPDATE {content_field_zp_art_shop} SET field_zp_art_shop_value = '%s' WHERE nid = %d AND vid = %d", $value, $node->nid, $node->vid)
					  		  )
					  		  {
								$shop_item['Действие / результат'] = 'change error: ошибка при изменении поля -' . $key . '- в базе на значение ' . $value; 
								return $shop_item;
					  		  }
				  		  }

				  		  
						break;
				
						
						
						

						
						
						
					case 'Продажная единица измерения':
								
						// мера расфасовки при продаже
  			
						// если продажная единица ещё не была установлена
						if(!db_result(db_query("SELECT nid FROM {content_field_sell_measure} WHERE nid = '%s'", $node->nid)))
						{
							if(!db_query("INSERT INTO {content_field_sell_measure} (vid, nid, field_sell_measure_value) VALUES (%d, %d, '%s')", $node->vid, $node->nid, $value))
							{
								$shop_item['Действие / результат'] = 'change error: ошибка при добавлении продажной единицы измерения'; 
								return $shop_item;
							}
							
						}
						else
						if(!db_query("UPDATE {content_field_sell_measure} SET field_sell_measure_value = '%s' WHERE vid = %d AND nid = %d", $value, $node->vid, $node->nid))
						{
							$shop_item['Действие / результат'] = 'change error: ошибка при изменении продажной единицы измерения'; 
							return $shop_item;
						}
				
						break;	
				
				
						
						
						
					case 'Цена':
						
						// если в числе содержится не точка, а запятая, меняем запятую на точку
						if(strpos($value, ',') !== FALSE)
							$value = str_replace(',', '.', $value);
				
						if
	 					(
							!db_query("UPDATE {uc_products} SET sell_price = %f WHERE vid = %d AND nid = %d", $value, $node->vid, $node->nid)
						)
						{
							$shop_item['Действие / результат'] = 'change error: ошибка при изменении цены товара'; 
							return $shop_item;
						}
				
						break;
						
						
						
				
				
					case 'Вес/объём, значение':
						
						// если в числе содержится не точка, а запятая, меняем запятую на точку
						if(strpos($value, ',') !== FALSE)
							$value = str_replace(',', '.', $value);
				
						if
	 					(
							!db_query("UPDATE {uc_products} SET weight = %f WHERE vid = %d AND nid = %d", $value, $node->vid, $node->nid)
						)
						{
							$shop_item['Действие / результат'] = 'change error: ошибка при изменении веса/объёма товара'; 
							return $shop_item;
						}
				
						break;		
									
						
						
						
						
				
					case 'Вес/объём, мера':
				
						if
	 					(
							!db_query("UPDATE {uc_products} SET weight_units = '%s' WHERE vid = %d AND nid = %d", $value, $node->vid, $node->nid)
						)
						{
							$shop_item['Действие / результат'] = 'change error: ошибка при изменении меры веса/объёма товара'; 
							return $shop_item;
						}
				
						break;
					

						
						
						
						
					// пока не контролируем количество товара, поэтому пока закомментируем касающиеся этого данные
					/*	
					case 'Кол-во': 
					

						if // при изменении внутреннего артикула, необходимо изменить артикул и в таблице с количеством
	 					(
							!db_query("UPDATE {uc_product_stock} SET sku = '%s', stock = %d WHERE nid = %d", $zp_element['zp_artikul'], $value, $node->nid)
						)
						{
							$shop_item['Действие / результат'] = 'change error: ошибка при изменении количества товара товара на значение ' . $value; 
							return $shop_item;
						}
				
						break;
						
						

					case 'Уменьшать кол-во при продаже': 
					
						if
	 					(
							!db_query("UPDATE {uc_product_stock} SET active = %d WHERE nid = %d AND sku = '%s'", $value, $node->nid, $zp_element['zp_artikul'])
						)
						{
							$shop_item['Действие / результат'] = 'change error: ошибка при изменении поля ' . $key . ' на значение ' . $value; 
							return $shop_item;
						}
				
						break;
						
						
						
					case 'Кол-во, ниже которого не продавать': 
					
						if
	 					(
							!db_query("UPDATE {uc_product_stock} SET threshold = %d WHERE nid = %d AND sku = '%s'", $value, $node->nid, $zp_element['zp_artikul'])
						)
						{
							$shop_item['Действие / результат'] = 'change error: ошибка при изменении поля ' . $key . ' на значение ' . $value; 
							return $shop_item;
						}
				
						break;
						
					*/
					
						
						
						
						
						
					case 'Другие атрибуты товара':
						
						// если для товара были заданы атрибуты, предварительно удаляем их
						// все, кроме атрибута -Ваши пожелания к товару (укажите)- и его опции -Нет-
						
						// Определим aid атрибута -Ваши пожелания к товару (укажите)- 
						// и oid опции -Нет- атрибута -Ваши пожелания к товару (укажите)-
						
						// выясним aid атрибута "Ваши пожелания к товару (укажите)"
						if( 
							!($whish_aid = db_result(db_query("SELECT aid from {uc_attributes} WHERE name = '%s'", 'Ваши пожелания к товару (укажите)')))
	  	  	  	  		  )
	  	  	  	  		  {
					
								// если такого атрибута в базе нет, вносим его в базу
  	 							if( 
									!db_query("INSERT INTO {uc_attributes} (name, ordering, required, display, description) VALUES ('%s', %d, %d, %d, '%s')", 'Ваши пожелания к товару (укажите)', 10, 0, 0, 'Например, "Дата изготовления не позднее вчерашнего дня".') // 10 - ставим этот атрибут последним, если будут другие атрибуты
		  		 	  		  	  )
		  		  	  		  	  {
									$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. Ошибка при добавлении в базу нового атрибута -Ваши пожелания к товару (укажите)-'; 
									return $shop_item;
		  		  	   		  	  }
	  	  		
	  	  	  					// выясняем aid только что внесенного атрибута
	  	  	  					if( 
									!($whish_aid = db_result(db_query("SELECT aid from {uc_attributes} WHERE name = '%s' AND display = %d", 'Ваши пожелания к товару (укажите)', 0))) // 0 - текстовое поле
		  		  	  		  	  )
		  		  	  		  	  {
									$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. Ошибка при считывании aid только что добавленного в базу нового атрибута -Ваши пожелания к товару (укажите)-'; 
									return $shop_item;
		  		  	  		  	  }
	   	  	      		   } // end of if( !($aid = db_result(db_query("SELECT aid from {uc_attributes} WHERE name = '%s'", 'Ваши пожелания к товару (укажите)')))
	   	  	      
	   	  	      
				
						// выясним номер oid для опции "Нет" атрибута "Ваши пожелания к товару (укажите)"
						if( 
							!($whish_oid = db_result(db_query("SELECT oid from {uc_attribute_options} WHERE aid = %d AND name = '%s'", $whish_aid, 'Нет')))
	  	  	  	  		  )
	  	  	  	  		  {
	  	  	  	  				/*
	  	  	  	  				// если такая опция не определёна в системе, пропускаем добавление атрибута в элемент
								//$shop_item['Предупреждения'] = 'new warning: в базе не определён атрибут -Ваши пожелания к товару (укажите)-'; 
	  	  	  	  				$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. В базе не определёна опция -Нет- для атрибута -Ваши пожелания к товару (укажите)-'; 
								return $shop_item;
								*/

								// если такой опции нет в этом атрибуте в базе, вносим её в базу
  	 							if( 
									!db_query("INSERT INTO {uc_attribute_options} (aid, name, cost, price, weight, ordering) VALUES (%d, '%s', %f, %f, %d, %d)", $whish_aid, 'Нет', 0, 0, 0, 0)
		  		  	  			  )
		  		  	  			  {
									$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. Ошибка при добавлении в базу новой опции -Нет- атрибута -Ваши пожелания к товару (укажите)-'; 
									return $shop_item;
		  		  	  			  }
	  	  		
	  	  	  					// выясняем oid только что внесенной опции текущего атрибута
	  	  	  					if( 
									!($whish_oid = db_result(db_query("SELECT oid from {uc_attribute_options} WHERE aid = %d AND name = '%s'", $whish_aid, 'Нет')))
		  		  	  			  )
		  		  	  			  {
									$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. Ошибка при считывании oid только что добавленной в базу новой опции -Нет- атрибута -Ваши пожелания к товару (укажите)-'; 
									return $shop_item;
		  		  	  			  }
		  		  	  
		  		  	  
	   	  	      		  } // end of if( !($oid = db_result(db_query("SELECT oid from {uc_attribute_options} WHERE aid = %d AND name = '%s'", $aid, 'Нет')))
	   	  	      
						
						

	   	  	      		  
	   	  	      		  
	   	  	      		  
						
						// выясним, есть ли в базе какие-то атрибуты у этого элемента.. и удаляем все, если есть
						// все, кроме атрибута -Ваши пожелания к товару (укажите)-
						if( 
							db_query("SELECT aid from {uc_product_attributes} WHERE nid = %d AND aid <> %d", $node->nid, $whish_aid)
	  	  	  	  		  )
	  	  	  	  		  {
	  	  	  	  		  	if( 
			 					!(db_query("DELETE FROM {uc_product_attributes} WHERE nid = %d AND aid <> %d", $node->nid, $whish_aid))
		  	 			  	  )
		  	 			  	  {
		  						$shop_item['Действие / результат'] = 'change error: Возможно, не все данные по этому элементу изменены. Ошибка при удалении старых атрибутов элемента'; 
								return $shop_item;
		      			  	  }
	   	  	      		  }
				
	   	  	      		// выясним, есть ли в базе какие-то опции атрибутов у этого элемента.. и удаляем все, если есть
	   	  	      		// все, кроме опции -Нет- атрибута -Ваши пожелания к товару (укажите)-
						if( 
							db_query("SELECT oid from {uc_product_options} WHERE nid = %d AND oid <> %d", $node->nid, $whish_oid)
	  	  	  	  		  )
	  	  	  	  		  {
	  	  	  	  		  	if( 
			 					!(db_query("DELETE FROM {uc_product_options} WHERE nid = %d AND oid <> %d", $node->nid, $whish_oid))
		  	 			  	  )
		  	 			  	  {
		  						$shop_item['Действие / результат'] = 'change error: Возможно, не все данные по этому элементу изменены. Ошибка при удалении старых опций атрибутов элемента'; 
								return $shop_item;
		      			  	  }
	   	  	      		  } 
	   	  	      		  
	   	  	      		  
	   	  	      		  
	   	  	      		// внесём новые атрибуты
	 					
	   	  	      		// ранее строка с атрибутами была разобрана в переменные:
	 
     					// $attributes[$count]['type'] - тип атрибута (text, select, check, radio)
	 					// $attributes[$count]['name'] - имя атрибута
	 					// $attributes[$count]['descr'] - описание атрибута
	 					// $attributes[$count]['options'] - опции со значением суммы прибавки к цене
	 
						// и затем присвоена в переменную  $zp_element['другие_атрибуты_товара'] = $attributes
	 
	 					// формат и пример строки: 'select***Цвет***Описание атрибута[Красный^^^0---Зелёный^^^3,40]text***Размер[24^^^1.20---43^^^5.21]'

					
	 					if($zp_element['другие_атрибуты_товара'] != 'нет')
	 					{
			
	 						foreach($zp_element['другие_атрибуты_товара'] as $attribute) // перебираем указанные в таблице атрибуты товара
							{
								// выясним тип очередного атрибута в таблице
								switch($attribute['type'])
								{
									case 'text': 
										$attribute['type'] = 0;
										break;
				
									case 'select': 
										$attribute['type'] = 1;
										break;
					
									case 'radio': 
										$attribute['type'] = 2;
										break;
				
								}
			
								// выясним, определён ли в базе такой атрибут и выясним его aid 
								if( 
									!($aid = db_result(db_query("SELECT aid from {uc_attributes} WHERE name = '%s' AND display = %d", $attribute['name'], $attribute['type'])))
	  	  	  					  )
	  	  	  					  {
	  	  	  	
	  	  	  						// если такого атрибута в базе нет, вносим его в базу
  	 								if( 
										!db_query("INSERT INTO {uc_attributes} (name, ordering, required, display, description) VALUES ('%s', %d, %d, %d, '%s')", $attribute['name'], 0, 0, $attribute['type'], $attribute['descr'])
		  		  					  )
		  		  					  {
										$shop_item['Действие / результат'] = 'change error: Не все данные изменены по этому элементу. Ошибка при добавлении в базу нового атрибута -' . $attribute['name'] . '-'; 
										return $shop_item;
		  		  					  }
	  	  		
	  	  	  						// выясняем aid только что внесенного атрибута
	  	  	  						if( 
										!($aid = db_result(db_query("SELECT aid from {uc_attributes} WHERE name = '%s' AND display = %d", $attribute['name'], $attribute['type'])))
		  		  					  )
		  		  					  {
										$shop_item['Действие / результат'] = 'change error: Не все данные изменены по этому элементу. Ошибка при считывании aid только что добавленного в базу нового атрибута -' . $attribute['name'] . '-'; 
										return $shop_item;
		  		  					  }

	   	  	  					   } // end of // выясним, определён ли в базе такой атрибут и выясним его aid 
	   	  	  
	   	  	
	   	  	  
	   	  						// перебирвем все опции
	   	  						// выясним, определены ли в базе опции для этого атрибута, указанные в таблице
	   	  						// и выясним их oid
	   	  						$option_count = 0;
								foreach($attribute['options'] as $option_name => $add_price)
								{
									$option_count++;
				
									// выясним, определёна ли в базе такая опция у такого атрибута и выясним его oid 
									if( 
										!($oid = db_result(db_query("SELECT oid from {uc_attribute_options} WHERE name = '%s' AND aid = %d", $option_name, $aid)))
	  	  	  	  					  )
	  	  	  	  					  {
	  	  	  	
	  	  	  							// если такой опции нет в этом атрибуте в базе, вносим её в базу
	  	  	  							// задаём нулевые цены, так как это общие данные по опциям, а для каждого товара они будут задаваться свои
  	 									if( 
											!db_query("INSERT INTO {uc_attribute_options} (aid, name, cost, price, weight, ordering) VALUES (%d, '%s', %f, %f, %d, %d)", $aid, $option_name, 0, 0, 0, 0)
		  		  	  					  )
		  		  	  					  {
											$shop_item['Действие / результат'] = 'change error: Не все данные изменены по этому элементу. Ошибка при добавлении в базу новой опции -' . $option_name . '- атрибута -' . $attribute['name'] . '-'; 
											return $shop_item;
		  		  	  					  }
	  	  		
	  	  	  							// выясняем oid только что внесенной опции текущего атрибута
	  	  	  							if( 
											!($oid = db_result(db_query("SELECT oid from {uc_attribute_options} WHERE aid = %d AND name = '%s'", $aid, $option_name)))
		  		  	  					  )
		  		  	  					  {
											$shop_item['Действие / результат'] = 'change error: Не все данные изменены по этому элементу. Ошибка при считывании oid только что добавленной в базу новой опции -' . $option_name . '- атрибута -' . $attribute['name'] . '-'; 
											return $shop_item;
		  		  	  					  }
		  		  	  

		  		   					   } // end of // выясним, определёна ли в базе такая опция у такого атрибута и выясним его oid 	  
		  		  	  
	   	  	
	   	  								// как только определили первую опцию текущего атрибута, вносим атрибут в базу по текущему товару
	   	  								// (единожды вносим этот атрибут)
	   	  								// вносим в базу данные об этом атрибуте для этого товара
  	 				
	   	  								if($option_count == 1)
	   	  			 					  if( 
											 	!db_query("INSERT INTO {uc_product_attributes} (nid, aid, ordering, default_option, required, display) VALUES (%d, %d, %d, %d, %d, %d)", $node->nid, $aid, 0, $oid, 0, $attribute['type'])
		  	 		   					    )
		  	 		   						{
						 						$shop_item['Действие / результат'] = 'change error: Не все данные изменены по этому элементу. Ошибка при добавлении атрибута -' . $attribute['name'] . '- к этому товару'; 
						 						return $shop_item;
		  	 		   						}
		  	 		   
		  	 							// вносим в базу данные о текущей опции для этого товара
  	 									if( 
											!db_query("INSERT INTO {uc_product_options} (nid, oid, cost, price, weight, ordering) VALUES (%d, %d, %f, %f, %d, %d)", $node->nid, $oid, 0, $add_price, 0, $option_count-1) // $option_count-1 - это порядок отображения опций, как в таблице, начиная с нуля (поэтому вычитаем единицу)
		  		 	  					  )
		  		 	  					  {
					 						$shop_item['Действие / результат'] = 'change error: Не все данные изменены по этому элементу. Ошибка при добавлении опции -' . $option_name . '- атрибута -' . $attribute['name'] . '- к этому товару'; 
											return $shop_item;
		  		  	  					  }

	
								} // end of foreach($attribute['options'] as $option => $add_price)
		
							} // end of foreach($zp_element['другие_атрибуты_товара'] as $attribute) // перебираем указанные в таблице атрибуты товара
							
	 					} // end of if($zp_element['другие_атрибуты_товара'] != 'нет')
						
						break;
						
						
						
						
						
					case 'Атрибут Ваши пожелания':
						
						

						// выясним aid атрибута "Ваши пожелания к товару (укажите)"
						if( 
							!($aid = db_result(db_query("SELECT aid from {uc_attributes} WHERE name = '%s'", 'Ваши пожелания к товару (укажите)')))
	  	  	  	  		  )
	  	  	  	  		  {
	  	  	  	  	
	  	  	  	  				/*
	  	  	  	  				// если такой атрибут не определён в системе, пропускаем добавление атрибута в элемент
								//$shop_item['Предупреждения'] = 'new warning: в базе не определён атрибут -Ваши пожелания к товару (укажите)-'; 
	  	  	  	  				$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. В базе не определён атрибут -Ваши пожелания к товару (укажите)-'; 
								return $shop_item;
								*/
					

					
								// если такого атрибута в базе нет, вносим его в базу
  	 							if( 
									!db_query("INSERT INTO {uc_attributes} (name, ordering, required, display, description) VALUES ('%s', %d, %d, %d, '%s')", 'Ваши пожелания к товару (укажите)', 10, 0, 0, 'Например, "Дата изготовления не позднее вчерашнего дня".') // 10 - ставим этот атрибут последним, если будут другие атрибуты
		  		 	  		  	  )
		  		  	  		  	  {
									$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. Ошибка при добавлении в базу нового атрибута -Ваши пожелания к товару (укажите)-'; 
									return $shop_item;
		  		  	   		  	  }
	  	  		
	  	  	  					// выясняем aid только что внесенного атрибута
	  	  	  					if( 
									!($aid = db_result(db_query("SELECT aid from {uc_attributes} WHERE name = '%s' AND display = %d", 'Ваши пожелания к товару (укажите)', 0))) // 0 - текстовое поле
		  		  	  		  	  )
		  		  	  		  	  {
									$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. Ошибка при считывании aid только что добавленного в базу нового атрибута -Ваши пожелания к товару (укажите)-'; 
									return $shop_item;
		  		  	  		  	  }
	   	  	      		   } // end of if( !($aid = db_result(db_query("SELECT aid from {uc_attributes} WHERE name = '%s'", 'Ваши пожелания к товару (укажите)')))
	   	  	      
	   	  	      
				
						// выясним номер oid для опции "Нет" атрибута "Ваши пожелания к товару (укажите)"
						if( 
							!($oid = db_result(db_query("SELECT oid from {uc_attribute_options} WHERE aid = %d AND name = '%s'", $aid, 'Нет')))
	  	  	  	  		  )
	  	  	  	  		  {
	  	  	  	  				/*
	  	  	  	  				// если такая опция не определёна в системе, пропускаем добавление атрибута в элемент
								//$shop_item['Предупреждения'] = 'new warning: в базе не определён атрибут -Ваши пожелания к товару (укажите)-'; 
	  	  	  	  				$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. В базе не определёна опция -Нет- для атрибута -Ваши пожелания к товару (укажите)-'; 
								return $shop_item;
								*/

								// если такой опции нет в этом атрибуте в базе, вносим её в базу
  	 							if( 
									!db_query("INSERT INTO {uc_attribute_options} (aid, name, cost, price, weight, ordering) VALUES (%d, '%s', %f, %f, %d, %d)", $aid, 'Нет', 0, 0, 0, 0)
		  		  	  			  )
		  		  	  			  {
									$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. Ошибка при добавлении в базу новой опции -Нет- атрибута -Ваши пожелания к товару (укажите)-'; 
									return $shop_item;
		  		  	  			  }
	  	  		
	  	  	  					// выясняем oid только что внесенной опции текущего атрибута
	  	  	  					if( 
									!($oid = db_result(db_query("SELECT oid from {uc_attribute_options} WHERE aid = %d AND name = '%s'", $aid, 'Нет')))
		  		  	  			  )
		  		  	  			  {
									$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. Ошибка при считывании oid только что добавленной в базу новой опции -Нет- атрибута -Ваши пожелания к товару (укажите)-'; 
									return $shop_item;
		  		  	  			  }
		  		  	  
		  		  	  
	   	  	      		  } // end of if( !($oid = db_result(db_query("SELECT oid from {uc_attribute_options} WHERE aid = %d AND name = '%s'", $aid, 'Нет')))
	   	  	      
	   	  	      
	   	  	      			  
						// если нужно добавить атрибут
						if($value == 'есть' OR $value == 1 OR $value == ' ' OR $value == '')
						{
							 
	   	  	      			// определим, не задан ли уже этот атрибут для этого элемента
	   	  	      			// и если нет, внесём его
	   	  	      			
	   	  	      			if( 
								!db_result(db_query("SELECT nid from {uc_product_attributes} WHERE aid = %d AND nid = %d", $aid, $node->nid))
	  	  	  	  			  )
	  	  	  	  			  {
	   	  	      
	   	  	    				// вносим в базу данные об этом атрибуте для этого элемента
  	 							if( 
									!db_query("INSERT INTO {uc_product_attributes} (nid, aid, ordering, default_option, required, display) VALUES (%d, %d, %d, %d, %d, %d)", $node->nid, $aid, 10, $oid, 0, 0) // ordering ставим 10, чтобы Поле с пожеланиями стояло последним после любых других атрибутов
		  		  			  	  )
		  		  			  	  {
									$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. Ошибка при добавлении атрибутв -Ваши пожелания к товару (укажите)-'; 
									return $shop_item;
		  		  			  	  }
		  		  			  
	  	  	  	  			  }
		  					
		  		  			  
		  		  			  
		  		  			// определим, не задана ли уже эта опция для этого атрибута для этого элемента
	   	  	      			// и если нет, внесём его  
		  		  			if( 
								!(db_result(db_query("SELECT nid from {uc_product_options} WHERE oid = %d AND nid = %d", $oid, $node->nid)))
	  	  	  	  			  )
	  	  	  	  			  {  
	   	  	      			
		  		  				// вносим в базу данные об опции (Нет) этого атрибуте для этого элемента
  	 							if( 
									!db_query("INSERT INTO {uc_product_options} (nid, oid, cost, price, weight, ordering) VALUES (%d, %d, %f, %f, %d, %d)", $node->nid, $oid, 0, 0, 0, 0)
		  		  			  	  )
		  		  			  	  {
									$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. Ошибка при добавлении атрибутв -Ваши пожелания к товару (укажите)-'; 
									return $shop_item;
		  		  			  	  }
	  	  	  	  			  }
		

						} // end of if($value == 'есть' OR $value == '1' OR $value == ' ' OR $value == '')
					
						else if($value == 'нет' OR $value == 0) 
						{
							
							
							// если нужно убрать атрибут
							// определим, не задан ли уже этот атрибут для этого элемента
	   	  	      			// и если задан, удалим его

	   	  	      			// если у элемента есть этот атрибут, удаляем его
	   	  	      			if( 
								db_result(db_query("SELECT nid from {uc_product_attributes} WHERE aid = %d AND nid = %d", $aid, $node->nid))
	  	  	  	  			  )
	  	  	  	  			  {
	  	  	  	  			  		if( 
			 							!(db_query('DELETE FROM {uc_product_attributes} WHERE nid = %d AND aid = %d', $node->nid, $aid))
		  	 			  	  		  )
		  	 			  	  		  {
		  								$shop_item['Действие / результат'] = 'change error: Возможно, не все данные по этому элементу изменены. Ошибка при удалении старых атрибутов элемента -Ваши пожелания к товару (укажите)-'; 
										return $shop_item;
		      			  	  		  }
		  		  			  
	  	  	  	  			  }
		  					
		  		  			  
		  		  			// если у элемента есть эта опция этого атрибута, удаляем её 
		  		  			if( 
								db_result(db_query("SELECT nid from {uc_product_options} WHERE oid = %d AND nid = %d", $oid, $node->nid))
	  	  	  	  			  )
	  	  	  	  			  {  
	  	  	  	  			  	
	  	  	  	  			  		if( 
			 							!(db_query('DELETE FROM {uc_product_options} WHERE nid = %d AND oid = %d', $node->nid, $oid))
		  	 			  	  		  )
		  	 			  	  		  {
		  								$shop_item['Действие / результат'] = 'change error: Возможно, не все данные по этому элементу изменены. Ошибка при удалении старой опции -Нет- атрибута -Ваши пожелания к товару (укажите)- этого элемента'; 
										return $shop_item;
		      			  	  	  	  }

	  	  	  	  			  }

						} // end of else if($value == 'нет' OR $value == '0')  // если нужно убрать атрибут

						
						break; // end of case 'Атрибут Ваши пожелания':

	   	  	      		  
	   	  	      		  
					
						
						
						
					case 'Производитель':
						
						if($proizv = db_result(db_query("SELECT field_proizv_value FROM {content_field_proizv} WHERE nid = %d", $node->nid)))
				  			{
				  				// если данные по производителю уже были заданы попытаемся их изменить, причём только вторую часть - название
				  				$proizv = explode(';', $proizv);
				  				$proizv = $proizv[0] . ';' . $value;
				  				
				  				if(!db_query("UPDATE {content_field_proizv} SET field_proizv_value = '%s' WHERE nid = %d", $proizv, $node->nid))
					  			{
									$shop_item['Действие / результат'] = 'change error: ошибка при изменении названия производителя на -' . $value . '-'; 
									return $shop_item;
					  			}
					  			
				  				
				  			}
						else
				  			{ 
								// иначе вносим данные по производителю, причём только вторую часть - название, первая часть - пустота перед точкой с запятой
				  				$proizv = ';' . $value;
				  				if(!db_query("INSERT INTO {content_field_proizv} (vid, nid, field_proizv_value) VALUES (%d, %d, '%s')", $node->vid, $node->nid, $proizv))
					  			{
									$shop_item['Действие / результат'] = 'change error: ошибка при добавлении в базу названия производителя для товара'; 
									return $shop_item;
				  	  			}
				  			}
				  				
				  		break;	// end of case 'Производитель':
				  		
				  		
				  		
				  	
				  	case 'Поставщик':
						
						if($postav = db_result(db_query("SELECT field_postav_value FROM {content_field_postav} WHERE nid = %d", $node->nid)))
				  			{
				  				// если данные по поставщику уже были заданы попытаемся их изменить, причём только вторую часть - название
				  				$postav = explode(';', $postav);
				  				$postav = $postav[0] . ';' . $value;
				  				
				  				if(!db_query("UPDATE {content_field_postav} SET field_postav_value = '%s' WHERE nid = %d", $postav, $node->nid))
					  			{
									$shop_item['Действие / результат'] = 'change error: ошибка при изменении названия поставщика на -' . $value . '-'; 
									return $shop_item;
					  			}
					  			
				  			}
						else
				  			{ 
								// иначе вносим данные по поставщику, причём только вторую часть - название, первая часть - пустота перед точкой с запятой
				  				$postav = ';' . $value;
				  				if(!db_query("INSERT INTO {content_field_postav} (vid, nid, field_postav_value) VALUES (%d, %d, '%s')", $node->vid, $node->nid, $postav))
					  			{
									$shop_item['Действие / результат'] = 'change error: ошибка при добавлении в базу названия поставщика для товара'; 
									return $shop_item;
				  	  			}
				  			}
				  		
				  		break;	// end of case 'Поставщик':
				  		
						
						
				  		
				  	case 'ZP MC ID производителя':
						
						if($proizv = db_result(db_query("SELECT field_proizv_value FROM {content_field_proizv} WHERE nid = %d", $node->nid)))
				  			{
				  				// если данные по производителю уже были заданы попытаемся их изменить, причём только первую часть - mc id
				  				$proizv = explode(';', $proizv);
				  				$proizv =  $value . ';' . $proizv[1];
				  				
				  				if(!db_query("UPDATE {content_field_proizv} SET field_proizv_value = '%s' WHERE nid = %d", $proizv, $node->nid))
					  			{
									$shop_item['Действие / результат'] = 'change error: ошибка при изменении MC ID производителя на -' . $value . '-'; 
									return $shop_item;
					  			}
					  			
				  				
				  			}
						else
				  			{ 
								// иначе вносим данные по производителю, причём только первую часть - mc id, вторая часть - пустота через точку с запятой
				  				$proizv =  $value . ';';
				  				if(!db_query("INSERT INTO {content_field_proizv} (vid, nid, field_proizv_value) VALUES (%d, %d, '%s')", $node->vid, $node->nid, $proizv))
					  			{
									$shop_item['Действие / результат'] = 'change error: ошибка при добавлении в базу MC ID производителя для товара'; 
									return $shop_item;
				  	  			}
				  			}
				  				
				  		break;	// end of case 'ZP MC ID производителя':
				  		
				  		
				  	
				  		
				  	case 'ZP MC ID поставщика':
						
						if($postav = db_result(db_query("SELECT field_postav_value FROM {content_field_postav} WHERE nid = %d", $node->nid)))
				  			{
				  				// если данные по поставщику уже были заданы попытаемся их изменить, причём только первую часть - mc id
				  				$postav = explode(';', $postav);
				  				$postav = $value . ';' . $postav[1];
				  				
				  				if(!db_query("UPDATE {content_field_postav} SET field_postav_value = '%s' WHERE nid = %d", $postav, $node->nid))
					  			{
									$shop_item['Действие / результат'] = 'change error: ошибка при изменении MC ID поставщика на -' . $value . '-'; 
									return $shop_item;
					  			}
					  			
				  				
				  			}
						else
				  			{ 
								// иначе вносим данные по поставщику, причём только первую часть - mc id, вторая часть - пустота через точку с запятой
				  				$postav = $value . ';';
				  				if(!db_query("INSERT INTO {content_field_postav} (vid, nid, field_postav_value) VALUES (%d, %d, '%s')", $node->vid, $node->nid, $postav))
					  			{
									$shop_item['Действие / результат'] = 'change error: ошибка при добавлении в базу MC ID поставщика для товара'; 
									return $shop_item;
				  	  			}
				  			}
				  		
				  		break;	// end of case 'ZP MC ID поставщика':	
				  	
						
						
				
					default:
						break;
				}

						
		} // end of if($zp_element['type'] == 'товар') // изменяем данные, которые касаются только товара
		

		
		
		

		
		
		// -------------------------------------------------------------------		
		// после внесения в базу изменённого значения сохраняем в поле с названием полную историю изменения названия, лишь убрав из ней первые три символа ### (если они там были)
		
		// перед этим восстанвливаем первоначальный вид кавычек, если они были
		$value = zp_restore_quotes($value); 
		$new_value_with_history = zp_restore_quotes($new_value_with_history);
		
		if($new_value_with_history)
			$shop_item[$key] = $new_value_with_history; // восстанавливаем полное значение поля, если оно имело историю (убирая признак изменения элемента, если он стоял вначале строки.... остальные разделители версий и сами версии названия остаются)
		else 
			$shop_item[$key] = $value;
			
				
	
	} // end of foreach($shop_item_changed as $key => $value) // последовательно перебираем и изменяем в элементе все поля, которые требуют изменения, в зависимости от названия поля			
	

	
	
	
	
	
	
	
	
	// повторим прогон по изменённым элементам для товара
	// теперь выберем поля с внешним описанием продукта и ключевыми словами по международному штрихкоду или ID производителя-поставщика
	// а также статус элемента
	
  if($zp_element['type'] == 'товар')
	foreach($shop_item_changed as $key => $value)
	{


		// исправим лишние кавычки, если есть
		$value = zp_correct_quotes($value);
			
		
		// для начала извлечём из значения поля ту часть, которая должна быть записана как новое значение
		// и сохраним всю историю изменений, удалив признак изменения для записи результирубщей таблицы
		$new_value_with_history = FALSE;
		if($value[0] . $value[1] . $value[2] == '###') // управляющие символы в начале строки
		{
			$value = explode('###', $value);
		  	
			foreach($value as $k => $val)
			{
				if($k == 0 OR $k == 1)
		 		  $new_value_with_history = $new_value_with_history . $val;
				else  
		 		  $new_value_with_history = $new_value_with_history . '###' . $val;  
			} 
			
			$value = $value[1];
		}

		

		switch($key) 
		{
			
			
			
/*			
$zp_element['ш_код_международный']
$zp_element['ш_код_производителя']
$zp_element['артикул_производителя']
$zp_element['ш_код_поставщика']
$zp_element['артикул_поставщика']
$zp_element['ш_код_магазина']
$zp_element['артикул_магазина']
*/



			
			case 'Описание внешнее': 
				
			
				if($shop_item['Ш-код международный (1)'] AND trim($shop_item['Ш-код международный (1)']) != '')
				{
					// если в таблице определён международный штрих-код, 
					//то внешнее описание записываем по международному штрих-коду

					$bw = get_value_from_field_with_history($shop_item['Ш-код международный (1)']);
				
					if(!db_result(db_query("SELECT p_bw FROM {p_descr_bw} WHERE p_bw = '%s'", $bw)))
				  	{
				  			// если значение не было задано изначально, попытаться его внести
				  			if(!db_query("INSERT INTO {p_descr_bw} (p_bw, p_name, descr, keywords) VALUES ('%s', '%s', '%s', '%s')", $bw, $node->title, $value, ''))
					  		{
								$shop_item['Действие / результат'] = 'change error: ошибка при добавлении в базу описания по международному штрих-коду'; 
								return $shop_item;
				  	  		}
				  	}
					else
				  	{ 
						if(!db_query("UPDATE {p_descr_bw} SET descr = '%s' WHERE p_bw = '%s'", $value, $bw))
					  	{
							$shop_item['Действие / результат'] = 'change error: ошибка при изменении описания товара по международному штрих-коду'; 
							return $shop_item;
					  	}
				  	}

				  
				}
				else if(
							($shop_item['ZP MC ID производителя'] AND trim($shop_item['ZP MC ID производителя']) != '')
							AND
							(
								($shop_item['Ш-код производителя (2)'] AND trim($shop_item['Ш-код производителя (2)']) != '')
								or 
								($shop_item['Артикул производителя (3)'] AND trim($shop_item['Артикул производителя (3)']) != '')
							)
						)
						{
							// иначе если в таблице определён ID производителя, внешнее описание записываем в таблицу описаний с производителями-поставщиками
					
							$mc_id = get_value_from_field_with_history($shop_item['ZP MC ID производителя']);
							$mc_name = get_value_from_field_with_history($shop_item['Производитель']);
							
							if($shop_item['Ш-код производителя (2)'] AND trim($shop_item['Ш-код производителя (2)']) != '')
								$product_id = get_value_from_field_with_history($shop_item['Ш-код производителя (2)']);
							else 
								$product_id = get_value_from_field_with_history($shop_item['Артикул производителя (3)']);
								
								
								
							if(!db_result(db_query("SELECT p_id FROM {p_descr_mc} WHERE p_id = '%s' AND seller_id = '%s'", $product_id, $mc_id)))
				  			{
				  				// если значение не было задано изначально, попытаться его внести
				  				if(!db_query("INSERT INTO {p_descr_mc} (p_id, p_name, seller_id, seller_name, descr, keywords) VALUES ('%s', '%s', '%s', '%s', '%s', '%s')", $product_id, $node->title, $mc_id, $mc_name, $value, ''))
					  			{
									$shop_item['Действие / результат'] = 'change error: ошибка при добавлении в базу описания по ID производителя'; 
									return $shop_item;
				  	  			}
				  			}
							else
				  			{ 
								if(!db_query("UPDATE {p_descr_mc} SET descr = '%s' WHERE p_id = '%s' AND seller_id = '%s'", $value, $product_id, $mc_id))
					  			{
									$shop_item['Действие / результат'] = 'change error: ошибка при изменении описания товара по ID производителя'; 
									return $shop_item;
					  			}
				  			}	
				  			
				  			
							
						}
				else if(
							($shop_item['ZP MC ID поставщика'] AND trim($shop_item['ZP MC ID поставщика']) != '')
							AND
							(
								($shop_item['Ш-код поставщика (4)'] AND trim($shop_item['Ш-код поставщика (4)']) != '')
								or 
								($shop_item['Артикул поставщика (5)'] AND trim($shop_item['Артикул поставщика (5)']) != '')
							)
						)
						{
							// иначе если в таблице определён ID поставщика, внешнее описание записываем в таблицу описаний с производителями-поставщиками
					
							$mc_id = get_value_from_field_with_history($shop_item['ZP MC ID поставщика']);
							$mc_name = get_value_from_field_with_history($shop_item['Поставщик']);
							
							if($shop_item['Ш-код поставщика (4)'] AND trim($shop_item['Ш-код поставщика (4)']) != '')
								$product_id = get_value_from_field_with_history($shop_item['Ш-код поставщика (4)']);
							else 
								$product_id = get_value_from_field_with_history($shop_item['Артикул поставщика (5)']);
								
								
								
							if(!db_result(db_query("SELECT p_id FROM {p_descr_mc} WHERE p_id = '%s' AND seller_id = '%s'", $product_id, $mc_id)))
				  			{
				  				// если значение не было задано изначально, попытаться его внести
				  				if(!db_query("INSERT INTO {p_descr_mc} (p_id, p_name, seller_id, seller_name, descr, keywords) VALUES ('%s', '%s', '%s', '%s', '%s', '%s')", $product_id, $node->title, $mc_id, $mc_name, $value, ''))
					  			{
									$shop_item['Действие / результат'] = 'change error: ошибка при добавлении в базу описания по ID поставщика'; 
									return $shop_item;
				  	  			}
				  			}
							else
				  			{ 
								if(!db_query("UPDATE {p_descr_mc} SET descr = '%s' WHERE p_id = '%s' AND seller_id = '%s'", $value, $product_id, $mc_id))
					  			{
									$shop_item['Действие / результат'] = 'change error: ошибка при изменении описания товара по ID поставщика'; 
									return $shop_item;
					  			}
				  			}	
				  			
	
						}
		
								
				  break;  // end of case 'Описание внешнее': 
				  
				

				  
				  
				  
				  
				  
				  
			case 'Ключевые слова': 
				
				
				// тут почти точно повторяется предыдущий код с внешним описанием, только на этот раз записываются ключевые слова
				
				if($shop_item['Ш-код международный (1)'] AND trim($shop_item['Ш-код международный (1)']) != '')
				{
					// если в таблице определён международный штрих-код, 
					//то ключевые слова записываем по международному штрих-коду

					$bw = get_value_from_field_with_history($shop_item['Ш-код международный (1)']);
				
					if(!db_result(db_query("SELECT p_bw FROM {p_descr_bw} WHERE p_bw = '%s'", $bw)))
				  	{
				  			// если значение не было задано изначально, попытаться его внести
				  			if(!db_query("INSERT INTO {p_descr_bw} (p_bw, p_name, descr, keywords) VALUES ('%s', '%s', '%s', '%s')", $bw, $node->title, '', $value))
					  		{
								$shop_item['Действие / результат'] = 'change error: ошибка при добавлении в базу ключевых слов по международному штрих-коду'; 
								return $shop_item;
				  	  		}
				  	}
					else
				  	{ 
						if(!db_query("UPDATE {p_descr_bw} SET keywords = '%s' WHERE p_bw = '%s'", $value, $bw))
					  	{
							$shop_item['Действие / результат'] = 'change error: ошибка при изменении описания товара по международному штрих-коду'; 
							return $shop_item;
					  	}
				  	}

				  
				} // end of если задан международный штрих-код
				else if(
							($shop_item['ZP MC ID производителя'] AND trim($shop_item['ZP MC ID производителя']) != '')
							AND
							(
								($shop_item['Ш-код производителя (2)'] AND trim($shop_item['Ш-код производителя (2)']) != '')
								or 
								($shop_item['Артикул производителя (3)'] AND trim($shop_item['Артикул производителя (3)']) != '')
							)
						)
						{
							// иначе если в таблице определён ID производителя, ключевые слова записываем в таблицу описаний с производителями-поставщиками
					
							$mc_id = get_value_from_field_with_history($shop_item['ZP MC ID производителя']);
							$mc_name = get_value_from_field_with_history($shop_item['Производитель']);
							
							if($shop_item['Ш-код производителя (2)'] AND trim($shop_item['Ш-код производителя (2)']) != '')
								$product_id = get_value_from_field_with_history($shop_item['Ш-код производителя (2)']);
							else 
								$product_id = get_value_from_field_with_history($shop_item['Артикул производителя (3)']);
								
								
								
							if(!db_result(db_query("SELECT p_id FROM {p_descr_mc} WHERE p_id = '%s' AND seller_id = '%s'", $product_id, $mc_id)))
				  			{
				  				// если значение не было задано изначально, попытаться его внести
				  				if(!db_query("INSERT INTO {p_descr_mc} (p_id, p_name, seller_id, seller_name, descr, keywords) VALUES ('%s', '%s', '%s', '%s', '%s', '%s')", $product_id, $node->title, $mc_id, $mc_name, '', $value))
					  			{
									$shop_item['Действие / результат'] = 'change error: ошибка при добавлении в базу ключевых слов по ID производителя'; 
									return $shop_item;
				  	  			}
				  			}
							else
				  			{ 
								if(!db_query("UPDATE {p_descr_mc} SET keywords = '%s' WHERE p_id = '%s' AND seller_id = '%s'", $value, $product_id, $mc_id))
					  			{
									$shop_item['Действие / результат'] = 'change error: ошибка при изменении ключевых слов товара по ID производителя'; 
									return $shop_item;
					  			}
				  			}	
				  			
				  			
							
						} // end of если задан производитель
				else if(
							($shop_item['ZP MC ID поставщика'] AND trim($shop_item['ZP MC ID поставщика']) != '')
							AND
							(
								($shop_item['Ш-код поставщика (4)'] AND trim($shop_item['Ш-код поставщика (4)']) != '')
								or 
								($shop_item['Артикул поставщика (5)'] AND trim($shop_item['Артикул поставщика (5)']) != '')
							)
						)
						{
							// иначе если в таблице определён ID поставщика, ключевые слова записываем в таблицу описаний с производителями-поставщиками
					
							$mc_id = get_value_from_field_with_history($shop_item['ZP MC ID поставщика']);
							$mc_name = get_value_from_field_with_history($shop_item['Поставщик']);
							
							if($shop_item['Ш-код поставщика (4)'] AND trim($shop_item['Ш-код поставщика (4)']) != '')
								$product_id = get_value_from_field_with_history($shop_item['Ш-код поставщика (4)']);
							else 
								$product_id = get_value_from_field_with_history($shop_item['Артикул поставщика (5)']);
								
								
								
							if(!db_result(db_query("SELECT p_id FROM {p_descr_mc} WHERE p_id = '%s' AND seller_id = '%s'", $product_id, $mc_id)))
				  			{
				  				// если значение не было задано изначально, попытаться его внести
				  				if(!db_query("INSERT INTO {p_descr_mc} (p_id, p_name, seller_id, seller_name, descr, keywords) VALUES ('%s', '%s', '%s', '%s', '%s', '%s')", $product_id, $node->title, $mc_id, $mc_name, '', $value))
					  			{
									$shop_item['Действие / результат'] = 'change error: ошибка при добавлении в базу ключевых слов по ID поставщика'; 
									return $shop_item;
				  	  			}
				  			}
							else
				  			{ 
								if(!db_query("UPDATE {p_descr_mc} SET keywords = '%s' WHERE p_id = '%s' AND seller_id = '%s'", $value, $product_id, $mc_id))
					  			{
									$shop_item['Действие / результат'] = 'change error: ошибка при изменении ключевых слов товара по ID поставщика'; 
									return $shop_item;
					  			}
				  			}	
				  
				  	
						  } // end of если задан поставщик
						  else 
						  {
						  		// иначе ключевые слова записываются (или изменяются) локально в товар конкретного магазина
						  		if(
									!db_result(db_query("SELECT vid FROM {content_field_keywords} WHERE nid = %d", $node->nid))
				  				  )
				  				  {
									 	if(!db_query("INSERT INTO {content_field_keywords} (vid, nid, field_keywords_value) VALUES (%d, %d, '%s')", $node->vid, $node->nid, $value))
			  							{
											$shop_item['Действие / результат'] = 'change error: ошибка при локальном добавлении ключевых слов в тип -' . $zp_element['type'] . '-';
											return $shop_item;
			  							}
				  					}
								else
				 					{ 
				    					if( 
				 							!db_query("UPDATE {content_field_keywords} SET field_keywords_value = '%s' WHERE nid = %d AND vid = %d", $value, $node->nid, $node->vid)
				     					  )
				      					  {
				  							$shop_item['Действие / результат'] = 'change error: ошибка при изменении поля -' . $key . '- в базе на значение ' . $value; 
											return $shop_item;
				      					  }
				  					}
						  	
						  		
						  }
				
						
				break;	// end of case 'Ключевые слова': 
					
					
					
					
					
		} // end of switch($key)
		
		
		
		
		
		
		// -------------------------------------------------------------------		
		// после внесения в базу изменённого значения сохраняем в поле с названием полную историю изменения названия, лишь убрав из ней первые три символа ### (если они там были)
		
		// перед этим восстанвливаем первоначальный вид кавчек, если они были
		$value = zp_restore_quotes($value); 
		$new_value_with_history = zp_restore_quotes($new_value_with_history);
		
		if($new_value_with_history)
			$shop_item[$key] = $new_value_with_history; // восстанавливаем полное значение поля, если оно имело историю (убирая признак изменения элемента, если он стоял вначале строки.... остальные разделители версий и сами версии названия остаются)
		else 
			$shop_item[$key] = $value;
			
		
		
	} // end of foreach($shop_item_changed as $key => $value) // повторим прогон по изменённым элементам // теперь выберем поля с внешним описанием продукта ключевыми словами по международному штрихкоду или ID производителя-поставщика
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
				// если для элемента был задан алиас pathauto, удаляем его
				// для того, чтобы заново его затем пересчитать (пересчитывается в функции, которая вызывающет эту функцию сразу для всех обработанных элементов)
				switch($zp_element['type'])
				{

					case 'страна':
					case 'населённый пункт': // обычно город
					case 'район':
					case 'магазин':
					case 'подотдел':
					case 'товар':
						
						//db_query("DELETE FROM {url_alias}  WHERE src = '%s'", 'node/'.$nid);
						//db_query("DELETE FROM {url_alias}  WHERE src = '%s'", 'node/'.$nid.'/feed');
				
						if( 
			 				db_result(db_query("SELECT pid from {url_alias} WHERE src = '%s'", 'node/' . $node->nid))
		  			  	  )
		  			  	  {
							if( 
			 					!(db_query("DELETE FROM {url_alias} WHERE src = '%s'", 'node/' . $node->nid))
			 					  OR
			 					!(db_query("DELETE FROM {url_alias} WHERE src = '%s'", 'node/' . $node->nid . '/feed'))
		  	  			  	  )
		  	  			  	  {
		  						$shop_item['Действие / результат'] = 'Change error: Возможно, не все данные изменены. Ошибка при удалении алиасов pathauto'; 
								return $shop_item;
		      			  	  }

		  			  	  } 
						
						break;
						
						
	  		  
					default: 
						break;
				}
	
	
	
	
	
	
	
	
	
	// временно, чтобы задача постоянно оставалась одной и той же		
	$shop_item['Действие / результат'] = ''; 
	
	return $shop_item;

}  // конец функции изменения элемента












// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// функция изменения данных по контрагенту (производителю или поставщику)

function zp_item_change_mc($shop_item)
{
			

				
				// проверим, есть ли какие-либо изменения в элементе
				$changes_exists = 0;
				$shop_item_changed = array();
				foreach ($shop_item as $key => $value)
				{
					
					// исправим лишние кавычки, если есть
					$value = zp_correct_quotes($value);
					
					
					if($value[0] . $value[1] . $value[2] == '###')
					{	
						$shop_item_changed[$key] = $value;
		  				$changes_exists = 1;
		  				
		  				// пометим, были ли изменения в артикуле и связях
					}
				}
					

				// если изменений нет, выходим
				if(!$changes_exists)
				{
					$shop_item['Действие / результат'] = 'change error: элемент не содержит изменений или неправильно указан признак изменения'; // сбрасываем флаг необходимости добавления элемента в базу	
						return $shop_item;
				}
				

				
				// создатим новый объект типа нода, в который будем заносить некоторые необходимые данные по элементу
				$node = new stdClass();
				// и вспомогательный объект $zp_element для прочих данных по элементу
				$zp_element = array();
				
				$new_value_with_history = array();

				
				
				
				// выясним название элемента

				$value = zp_correct_quotes($shop_item['Название']);
					
				$name_changed = FALSE;
				if($value[0] . $value[1] . $value[2] == '###') // управляющие символы в начале строки
		 		{
					$value = explode('###', $value);
		   	
					foreach($value as $k => $val)
					{
						if($k == 0 OR $k == 1)
		      		  		$new_value_with_history['Название'] = $new_value_with_history['Название'] . $val;
		    			else  
		      		  		$new_value_with_history['Название'] = $new_value_with_history['Название'] . '###' . $val;  
					} 
			
					
					$value_old = $value[2];
					$value = $value[1];
						
					$name_changed = 1;  // название изменилось
		 		}
		 		else if(strpos($value, '###') !== FALSE) // управляющие символы в середине строки
		 		{
		 			$value = explode('###', $value);
		   	
					foreach($value as $k => $val)
		 			{
						if($k == 0)
		      		 	 	$new_value_with_history['Название'] = $new_value_with_history['Название'] . $val;
		    			else  
		      		 	 	$new_value_with_history['Название'] = $new_value_with_history['Название'] . '###' . $val;  
					} 
			
					//$value_old = $value[1];
					$value = $value[0];
					$value_old = $value;
					
		 		}
		 		else 
		 		{
		 			$value_old = $value;
		 		}
		 			
		 		//echo '_zp_element[type] = ' . $zp_element['type'] . '<br>';
		 		
				$zp_element['старое_название'] = $value_old;
				$zp_element['название'] = $value;
					
				if($name_changed AND (!$zp_element['название'] OR trim($zp_element['название']) == ''))
				{
					$shop_item['Действие / результат'] = 'change error: не задано новое название'; 
						return $shop_item;
				}
				
				
				
				
				
				// выясним внутренний артикул zp mc элемента

				$value = zp_correct_quotes($shop_item['Внутренний артикул ZP MC']);
					
				$zp_mc_changed = FALSE;
				if($value[0] . $value[1] . $value[2] == '###') // управляющие символы в начале строки
		 		{
					$value = explode('###', $value);
		   	
					foreach($value as $k => $val)
					{
						if($k == 0 OR $k == 1)
		      		  		$new_value_with_history['Внутренний артикул ZP MC'] = $new_value_with_history['Внутренний артикул ZP MC'] . $val;
		    			else  
		      		  		$new_value_with_history['Внутренний артикул ZP MC'] = $new_value_with_history['Внутренний артикул ZP MC'] . '###' . $val;  
					} 
			
					
					$value_old = $value[2];
					$value = $value[1];
						
					$zp_mc_changed = 1;  // название изменилось
		 		}
		 		else if(strpos($value, '###') !== FALSE) // управляющие символы в середине строки
		 		{
		 			$value = explode('###', $value);
		   	
					foreach($value as $k => $val)
		 			{
						if($k == 0)
		      		 	 	$new_value_with_history['Внутренний артикул ZP MC'] = $new_value_with_history['Внутренний артикул ZP MC'] . $val;
		    			else  
		      		 	 	$new_value_with_history['Внутренний артикул ZP MC'] = $new_value_with_history['Внутренний артикул ZP MC'] . '###' . $val;  
					} 
			
					$value = $value[0];
					$value_old = $value;
					
		 		}
		 		else 
		 		{
		 			$value_old = $value;
		 		}
		 			

		 		
				$zp_element['старый_артикул_zp_mc'] = $value_old;
				$zp_element['артикул_zp_mc'] = $value;
				
				if($zp_mc_changed AND (!$zp_element['артикул_zp_mc'] OR trim($zp_element['артикул_zp_mc']) == ''))
				{
					$shop_item['Действие / результат'] = 'change error: не задан новый zp mc артикул'; // 
						return $shop_item;
				}
				
				
				
				
				
				
				
				
				
				
				
				// выясним тип контрагента

				$value = zp_correct_quotes($shop_item['Тип записи']);
					
				$type_changed = FALSE;
				if($value[0] . $value[1] . $value[2] == '###') // управляющие символы в начале строки
		 		{
					$value = explode('###', $value);
		   	
					foreach($value as $k => $val)
					{
						if($k == 0 OR $k == 1)
		      		  		$new_value_with_history['Тип записи'] = $new_value_with_history['Тип записи'] . $val;
		    			else  
		      		  		$new_value_with_history['Тип записи'] = $new_value_with_history['Тип записи'] . '###' . $val;  
					} 
			
					
					$value_old = $value[2];
					$value = $value[1];
						
					$type_changed = 1;  // название изменилось
		 		}
		 		else if(strpos($value, '###') !== FALSE) // управляющие символы в середине строки
		 		{
		 			$value = explode('###', $value);
		   	
					foreach($value as $k => $val)
		 			{
						if($k == 0)
		      		 	 	$new_value_with_history['Тип записи'] = $new_value_with_history['Тип записи'] . $val;
		    			else  
		      		 	 	$new_value_with_history['Тип записи'] = $new_value_with_history['Тип записи'] . '###' . $val;  
					} 
			
					$value = $value[0];
					$value_old = $value;
					
		 		}
		 		else 
		 		{
		 			$value_old = $value;
		 		}
		 			

		 		
				$zp_element['старый_тип_контрагента'] = $value_old;
				$zp_element['тип_контрагента'] = $value;
				
				
				if($type_changed AND (!$zp_element['тип_контрагента'] OR trim($zp_element['тип_контрагента']) == ''))
				{
					$shop_item['Действие / результат'] = 'change error: не задан новый тип контрагента'; // 
						return $shop_item;
				}
				
				
				

				
				
				// правильно ли указан тип элемента?
				switch($zp_element['тип_контрагента'])
				{
					case 'производитель':
					case 'поставщик':
						break; 
						
					default:
						$shop_item['Действие / результат'] = 'change error: указан неизвестный или неправильный тип контрагента'; 
						return $shop_item;
				}
				
				
				
				// получим из базы исходный элемент
				
				if($zp_mc_changed)
				{
					$db_element = db_fetch_object(db_query("SELECT nid, vid, field_zp_mc_artikul_value, field_kontragent_type_value, field_brand_names_value, field_mc_addresses_value, field_types_of_products_value, field_add_info_value, field_contacts_value, field_mc_country_value, field_mc_place_value, field_pics_info_value, field_mc_status_value FROM {content_type_mc_descr} WHERE field_zp_mc_artikul_value = '%s'", $zp_element['старый_артикул_zp_mc']));
					if(!$db_element->nid)
					{
						$shop_item['Действие / результат'] = 'change error: ошибка при чтении базы данных или нет элемента с таким (исходным, подлежащим замене) артикулом ' . $zp_element['старый_артикул_zp_mc'] . ' в базе'; 
						return $shop_item;
					}
					
					// проверим, нет ли в базе элемента с таким артикулом zp mc, на который требуется поменять
					if($existing_element_nid = db_result(db_query("SELECT nid from {content_type_mc_descr} WHERE field_zp_mc_artikul_value = '%s'", $zp_element['артикул_zp_mc'])))
    				{
    					$shop_item['Действие / результат'] = 'change error: в базе уже есть элемент с таким артикулом ' . $zp_element['артикул_zp_mc']; 
						return $shop_item;
    				}
				}
				else 
				{
					$db_element = db_fetch_object(db_query("SELECT nid, vid, field_zp_mc_artikul_value, field_kontragent_type_value, field_brand_names_value, field_mc_addresses_value, field_types_of_products_value, field_add_info_value, field_contacts_value, field_mc_country_value, field_mc_place_value, field_pics_info_value, field_mc_status_value FROM {content_type_mc_descr} WHERE field_zp_mc_artikul_value = '%s'", $zp_element['артикул_zp_mc']));
					if(!$db_element->nid)
					{
						$shop_item['Действие / результат'] = 'change error: ошибка при чтении базы данных или нет элемента с таким артикулом ' . $zp_element['артикул_zp_mc'] . ' в базе'; 
						return $shop_item;
					}
				}
	
				// присвоим исходные данные из базы рабочим переменным
				$node->vid = $db_element->vid; 
				$node->nid = $db_element->nid;
				
				$element_nid = $db_element->nid; // вспомогательная переменная
				
		
				
				//field_zp_mc_artikul_value, - используются данные из таблицы
				//field_kontragent_type_value,  - используются данные из таблицы
				
				//field_brand_names_value, - раскладываем на два поля
				$brands = explode(';', $db_element->field_brand_names_value);
				foreach ($brands as $key => $value)
				{
					if($key == 0)
						$main_brand = $value;
					else 
					if($key == 1)
						$other_brands = $value;
					else 
						$other_brands = $other_brands . ';' . $value;
				}
				
				
				//field_mc_addresses_value, 
				//field_types_of_products_value, 
				//field_add_info_value, 
				//field_contacts_value, 
				//field_mc_country_value, 
				//field_mc_place_value, 
				
				//field_pics_info_value,  - раскладываем на два поля
				$pics_info = explode(';', $db_element->field_pics_info_value);
				foreach ($pics_info as $key => $value)
				{
					if($key == 0)
						$pics_amount = $value;
					else 
					if($key == 1)
						$pics_orientation = $value;
					else 
						$pics_orientation = $pics_orientation . ';' . $value;
				}
				
				//field_mc_status_value
				
				//$zp_element['название'] - задано выше
				//$zp_element['тип_контрагента'] - задано выше
				//$zp_element['артикул_zp_mc'] - задано выше
				$zp_element['основной_бренд'] = $main_brand; // получено из составного поля выше
				$zp_element['бренды_контрагента'] = $other_brands; // получено из составного поля выше
				$zp_element['типы_товара'] = $db_element->field_types_of_products_value;
				$zp_element['доп_информация'] = $db_element->field_add_info_value;
				$zp_element['страна'] = $db_element->field_mc_country_value;
				$zp_element['город_местоположение'] = $db_element->field_mc_place_value;
				$zp_element['адрес'] = $db_element->field_mc_addresses_value;
				$zp_element['контакты'] = $db_element->field_contacts_value;
				$zp_element['кол_во_картинок'] = $pics_amount; // получено из составного поля выше
				$zp_element['ориентация_картинок'] = $pics_orientation; // получено из составного поля выше
				$zp_element['статус_элемента'] = $db_element->field_mc_status_value;


				
				
				
				
				
				
    			
    			
    			
				// после обработки данных помещаем в поля сохранённые строки с историей, 
				// убирая маркер изменения ### с начала строки (что значит, что при следующей итерации это поле изменяться не будет)
				foreach ($new_value_with_history as $key => $value)
				{
					// после внесения в базу, сохраняем в поле с названием полную историю изменения названия, лишь убрав из ней первые три символа ### (если они там были)
	 				// перед этим восстанвливаем первоначальный вид кавчек, если они были
					$shop_item[$key] = zp_restore_quotes($new_value_with_history[$key]); // восстанавливаем полное значение поля, если оно имело историю (убирая признак изменения элемента, если он стоял вначале строки.... остальные разделители версий и сами версии названия остаются)
				}	   
					   	
					
					
					
					
					
					
						 			
		 			
		 			
// ---------- начинаем внесение изменений в базу		 			
// ----------------------------------------------------------------------------------				
// ----------------------------------------------------------------------------------
// ----------------------------------------------------------------------------------
// ----------------------------------------------------------------------------------
// ----------------------------------------------------------------------------------
				
				
	// отметим факт изменения элемента, изменив дату изменения и юзера для ноды и её ревизии	

	global $user;
	$node->uid = $user->uid;
						 
	if(
		!db_query("UPDATE {node} SET uid = %d, changed = %d WHERE nid = %d AND vid = %d", $node->uid, time(), $node->nid, $node->vid)
			OR
		!db_query("UPDATE {node_revisions} SET uid = %d, timestamp = %d WHERE nid = %d AND vid = %d", $node->uid, time(), $node->nid, $node->vid)
	  )
	  {
		$shop_item['Действие / результат'] = 'change error: ошибка при обновлении времени изменения элемента и идентификатора пользователя, производящего изменения' . $key . 'в базе на значение ' . $value; 
		return $shop_item;
	  }
		
	  
	  
	  	
	

	// последовательно изменяем в элементе все поля, которые требуют изменения, в зависимости от названия поля			
	foreach($shop_item_changed as $key => $value)
	{

		// исправим лишние кавычки, если есть
		$value = zp_correct_quotes($value);
			
		
		// для начала извлечём из значения поля ту часть, которая должна быть записана как новое значение
		// и сохраним всю историю изменений, удалив признак изменения для записи результирубщей таблицы
		$new_value_with_history = FALSE;
		if($value[0] . $value[1] . $value[2] == '###') // управляющие символы в начале строки
		{
			$value = explode('###', $value);
		  	
			foreach($value as $k => $val)
			{
				if($k == 0 OR $k == 1)
		 		  $new_value_with_history = $new_value_with_history . $val;
				else  
		 		  $new_value_with_history = $new_value_with_history . '###' . $val;  
			} 
			
			$value = $value[1];
		}
		 		
		
		
		// перебираем значения полей, вернее, выбираем какое поле обрабатывается на очередной итерации	
		// в данном случае поля, которые касаются в основном разных элементов	
		// и обновляем поля, некоторые из которых уже были получены из исходного элемента в базе
		// те поля, которые не обновляются, соответственно, затем записываются в базу обратно без изменений
		switch($key) 
		{
			
		
			case 'Описание':
				if($value AND trim($value) != '') // менять только в том случае, если в поле что-то задано
				{
					$zp_element['описание'] = $value;
					$node->body = $value;
					$description_changed = 1;
				}
				break;
				
				

			case 'Фирменное название (основной бренд)':
				if($value AND trim($value) != '') // менять только в том случае, если в поле что-то задано
					$zp_element['основной_бренд'] = $value;
				break;	
						
	
			case 'Бренды (производимые, поставляемые)':
				if($value AND trim($value) != '') // менять только в том случае, если в поле что-то задано
					$zp_element['бренды_контрагента'] = $value;
				break;	

			case 'Тип(ы) товара':
				if($value AND trim($value) != '') // менять только в том случае, если в поле что-то задано
					$zp_element['типы_товара'] = $value;
				break;	

			case 'Дополнительная информация':
				if($value AND trim($value) != '') // менять только в том случае, если в поле что-то задано
					$zp_element['доп_информация'] = $value;
				break;
				
		
			case 'Страна':
				if($value AND trim($value) != '') // если в этом поле не пусто, то используем значение поля, иначе остаётся знаение по умолчанию "нет"
					$zp_element['страна'] = $value;
				break;			

			case 'Город, местоположение':
				if($value AND trim($value) != '') // если в этом поле не пусто, то используем значение поля, иначе остаётся знаение по умолчанию "нет"
					$zp_element['город_местоположение'] = $value;
				break;					
							
					
			case 'Адрес':
				if($value AND trim($value) != '') // если в этом поле не пусто, то используем значение поля, иначе остаётся знаение по умолчанию "нет"
					$zp_element['адрес'] = $value;
				break;	

				
			case 'Ответственные лица, контакты':
				if($value AND trim($value) != '') // если в этом поле не пусто, то используем значение поля, иначе остаётся знаение по умолчанию "нет"
					$zp_element['контакты'] = $value;
				break;	

			case 'Кол-во картинок':
				if($value AND trim($value) != '') // менять только в том случае, если в поле что-то задано
					$zp_element['кол_во_картинок'] = $value;
				break;	

				
			case 'Ориентация картинок':
				if($value AND trim($value) != '') // менять только в том случае, если в поле что-то задано
					$zp_element['ориентация_картинок'] = $value;
				break;	
									
				
			case 'Статус элемента':
				if($value AND trim($value) != '') 
					$zp_element['статус_элемента'] = $value;
					
				break;


				
				
				
			default:    // или любое другое поле, указанное в таблице, но (пока) не определённое в программе
				break;	
											
		} // end of switch($key) // перебираем значения полей, вернее, выбираем какое поле обрабатывается на очередной итерации
		
		
		
	
		
		// -------------------------------------------------------------------		
		// после внесения в базу изменённого значения сохраняем в поле с названием полную историю изменения названия, лишь убрав из ней первые три символа ### (если они там были)
		
		// перед этим восстанвливаем первоначальный вид кавчек, если они были
		$value = zp_restore_quotes($value); 
		$new_value_with_history = zp_restore_quotes($new_value_with_history);
		
		if($new_value_with_history)
			$shop_item[$key] = $new_value_with_history; // восстанавливаем полное значение поля, если оно имело историю (убирая признак изменения элемента, если он стоял вначале строки.... остальные разделители версий и сами версии названия остаются)
		else 
			$shop_item[$key] = $value;
			
				
	
	} // end of foreach($shop_item_changed as $key => $value) // последовательно перебираем и изменяем в элементе все поля, которые требуют изменения, в зависимости от названия поля			
	


	
	// теперь объект $zp_element содержит все данные для обновления контрагента в базе
	// произведём первый этап обновления - обновление типа данных mc_descr, 
	// а также может потребуется ещё обновить название и описание в других таблицах
						 
	if(
		!db_query("UPDATE {content_type_mc_descr} SET field_zp_mc_artikul_value = '%s', field_kontragent_type_value = '%s', field_brand_names_value = '%s', field_mc_addresses_value = '%s', field_types_of_products_value = '%s', field_add_info_value = '%s', field_contacts_value = '%s', field_mc_country_value = '%s', field_mc_place_value = '%s', field_pics_info_value = '%s', field_mc_status_value = %d WHERE nid = %d AND vid = %d", $zp_element['артикул_zp_mc'], $zp_element['тип_контрагента'], $zp_element['основной_бренд'] . ';' . $zp_element['бренды_контрагента'], $zp_element['адрес'], $zp_element['типы_товара'], $zp_element['доп_информация'], $zp_element['контакты'], $zp_element['страна'], $zp_element['город_местоположение'], $zp_element['кол_во_картинок'] . ';' . $zp_element['ориентация_картинок'], $zp_element['статус_элемента'], $node->nid, $node->vid)
	  )
	  {
		$shop_item['Действие / результат'] = 'change error: ошибка при обновлении данных по контрагенту в базе'; 
		return $shop_item;
	  }
	
	
	// если изменилось название и/или описание
	if($name_changed AND ($node->body AND trim($node->body) != ''))
	{
		// изменилось название и описание
		if(
			!db_query("UPDATE {node} SET title = '%s' WHERE nid = %d AND vid = %d", $zp_element['название'], $node->nid, $node->vid)
				OR
			!db_query("UPDATE {node_revisions} SET title = '%s', body = '%s', teaser = '%s' WHERE nid = %d AND vid = %d", $zp_element['название'], $node->body, $node->body, $node->nid, $node->vid)
	  	  )
	  	  {
			$shop_item['Действие / результат'] = 'change error: ошибка при обновлении названия и описания контрагента в базе'; 
			return $shop_item;
	  	  }
		
	}
	else 
	if($name_changed AND !($node->body AND trim($node->body) != ''))
	{
		// изменилось только название
		if(
			!db_query("UPDATE {node} SET title = '%s' WHERE nid = %d AND vid = %d", $zp_element['название'], $node->nid, $node->vid)
				OR
			!db_query("UPDATE {node_revisions} SET title = '%s' WHERE nid = %d AND vid = %d", $zp_element['название'], $node->nid, $node->vid)
	  	  )
	  	  {
			$shop_item['Действие / результат'] = 'change error: ошибка при обновлении названия контрагента в базе'; 
			return $shop_item;
	  	  }
	}
	else 
	if(!$name_changed AND ($node->body AND trim($node->body) != ''))
	{
		// изменилось только описание
		if(
			!db_query("UPDATE {node_revisions} SET body = '%s', teaser = '%s' WHERE nid = %d AND vid = %d", $node->body, $node->body, $node->nid, $node->vid)
	  	  )
	  	  {
			$shop_item['Действие / результат'] = 'change error: ошибка при обновлении описания контрагента в базе'; 
			return $shop_item;
	  	  }
	}

	
	
	
	
	
	
	
	
	// если для элемента был задан алиас pathauto, удаляем его
	// для того, чтобы заново его затем пересчитать (пересчитывается в функции, которая вызывающет эту функцию сразу для всех обработанных элементов)
	
			
	if( 
		db_result(db_query("SELECT pid from {url_alias} WHERE src = '%s'", 'node/' . $node->nid))
	  )
	  {
		if( 
			!(db_query("DELETE FROM {url_alias} WHERE src = '%s'", 'node/' . $node->nid))
			  OR
			!(db_query("DELETE FROM {url_alias} WHERE src = '%s'", 'node/' . $node->nid . '/feed'))
		  )
		  {
		  	$shop_item['Действие / результат'] = 'Change error: Возможно, не все данные изменены. Ошибка при удалении алиасов pathauto'; 
			return $shop_item;
		  }

		} 

	
	
	
	
	
	
	
	
	// временно, чтобы задача постоянно оставалась одной и той же		
	$shop_item['Действие / результат'] = ''; 
	
	return $shop_item;

}  // конец функции изменения элемента












function get_value_from_field_with_history($value){
	
	if($value[0] . $value[1] . $value[2] == '###') // управляющие символы в начале строки
		{
			$value = explode('###', $value);
			$value = $value[1];
		}
	else if(strpos($value, '###') !== FALSE) // управляющие символы в середине строки
		{
			$value = explode('###', $value);
			$value = $value[0];
		}
	
	return $value;
}







// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// функция добавления нового элемента в магазин (отдела, подгруппы, товара и т.д.)-------

function zp_item_new($shop_item)
{
	global $user;
	
	// сбрасываем флаг необходимости добавления элемента в базу	
	// в дальнейшем сюда могут добавляться какие-то комментарии
	$shop_item['Действие / результат'] = '';
	
	
	
				
//echo 'sxxx';
//return;

					
					
			    // Проверим, задано ли название элемента
			    
			    // в таблице названия отделов и групп указано в колонке с сокращённым названием товаров (как сохранено в базе)
			    if($shop_item['Подгруппа / тип элемента'] == 'подотдел' OR $shop_item['Подгруппа / тип элемента'] == 'подгруппа')
			    	$value = zp_correct_quotes($shop_item['Название сокращённое']);
				else						    
			    	$value = zp_correct_quotes($shop_item['Название']);
			    	
				if(!$value OR $value == '' OR $value == ' ')	    
				{
					$shop_item['Действие / результат'] = 'new error: не задано название элемента' ; // сбрасываем флаг необходимости добавления элемента в базу	
						return $shop_item;
				}
				
				
				// теперь можно создатиь новый объект типа нода, в который будем заносить некоторые необходимые данные по элементу
				$node = new stdClass();
				// и вспомогательный объект $zp_element для прочих данных по элементу
				$zp_element = array();
				
			    // если в значении этого поля (позже таким образом будут проверяться и остальные поля) первые три символа в поле равны '###', 
			    // значит поле может содержать несколько версий и историю изменений... 
			    // уберём эти символы и используем только первое за этими символами значение (остальные отбрасываем)
			    
			    // также эти три сомвола могут содержаться внутри строки - это несколько версий (история изменения) значения этого поля
			    // тогда берём только первую (от начала строки) версию и считаем её текущей
			    
			    // после внесения в базу, сохраняем в поле с названием полную историю изменения значения этого поля, лишь убрав из ней первые три символа ### (если они там были)
			    
		 		
			    $new_value_with_history = FALSE;
				if($value[0] . $value[1] . $value[2] == '###') // управляющие символы в начале строки
		 		{
					$value = explode('###', $value);
		   	
					foreach($value as $key => $val)
					{
						if($key == 0 OR $key == 1)
		      	 		  $new_value_with_history = $new_value_with_history . $val;
		    			else  
		      	 		  $new_value_with_history = $new_value_with_history . '###' . $val;  
					} 
			
					$value = $value[1];
		 		}
		 		else if(strpos($value, '###') !== FALSE) // управляющие символы в середине строки
		 		{
		 			$value = explode('###', $value);
		   	
					foreach($value as $key => $val)
					{
						if($key == 0)
		      	 		  $new_value_with_history = $new_value_with_history . $val;
		    			else  
		      	 		  $new_value_with_history = $new_value_with_history . '###' . $val;  
					} 
			
					$value = $value[0];
		 		}
				
		 		$node->title = $value; // присваиваем значение поля (или последнюю версию из этого поля) рабочей переменной
				$zp_element['новое_название'] = $node->title;
				
				
				// после внесения в базу, сохраняем в поле с названием полную историю изменения названия, лишь убрав из ней первые три символа ### (если они там были)
				if($new_value_with_history)
		 			$shop_item['Название'] = $new_value_with_history; // восстанавливаем полное значение поля, если оно имело историю (убирая признак изменения элемента, если он стоял вначале строки.... остальные разделители версий и сами версии названия остаются)
					
					

		 			
		 			
		 			
		 	    // Также проверим, задан ли тип или подгруппа элемента

			    $value = $shop_item['Подгруппа / тип элемента'];
				
			    // если создаваемый элемент - товар, но для него не задана подгруппа, не создаём элемент в базе
			    // и сообщаем об ошибке
			    if(strpos($shop_item['Тип записи'], 'товар***') !== FALSE AND (!$value OR $value == '' OR $value == ' '))
				{
					$shop_item['Действие / результат'] = 'new error: не задана родительская подгруппа для товара' ; 
						return $shop_item;
				}

			    // если в значении этого поля (позже таким образом будут проверяться и остальные поля) первые три символа в поле равны '###', 
			    // значит поле может содержать несколько версий и историю изменений... 
			    // уберём эти символы и используем только первое за этими символами значение (остальные отбрасываем)
			    
			    // также эти три сомвола могут содержаться внутри строки - это несколько версий (история изменения) значения этого поля
			    // тогда берём только первую (от начала строки) версию и считаем её текущей
			    
			    // после внесения в базу, сохраняем в поле с названием полную историю изменения значения этого поля, лишь убрав из ней первые три символа ### (если они там были)
		 
		 		
			    $new_value_with_history = FALSE;
				if($value[0] . $value[1] . $value[2] == '###') // управляющие символы в начале строки
		 		{
					$value = explode('###', $value);
		   	
					foreach($value as $key => $val)
					{
						if($key == 0 OR $key == 1)
		      	 		  $new_value_with_history = $new_value_with_history . $val;
		    			else  
		      	 		  $new_value_with_history = $new_value_with_history . '###' . $val;  
					} 
			
					$value = $value[1];
		 		}
		 		else if(strpos($value, '###') !== FALSE) // управляющие символы в середине строки
		 		{
		 			$value = explode('###', $value);
		   	
					foreach($value as $key => $val)
					{
						if($key == 0)
		      	 		  $new_value_with_history = $new_value_with_history . $val;
		    			else  
		      	 		  $new_value_with_history = $new_value_with_history . '###' . $val;  
					} 
			
					$value = $value[0];
		 		}
		 		
		 		// уберём в полученной строке дубликаты кавычек и кавычки по краям
		 		$value = zp_correct_quotes($value);

				$zp_element['подгруппа_или_тип_элемента'] = $value; // присваиваем значение поля (или последнюю версию из этого поля) рабочей переменной
				
				// после внесения в базу, сохраняем в поле с названием полную историю изменения типа или подгруппы, лишь убрав из ней первые три символа ### (если они там были)
				if($new_value_with_history)
		 			$shop_item['Подгруппа / тип элемента'] = $new_value_with_history; // восстанавливаем полное значение поля, если оно имело историю (убирая признак изменения элемента, если он стоял вначале строки.... остальные разделители версий и сами версии названия остаются)
					
					
					
		 			
		 			
		 			
		 			
		 			
		 			
					
				// проверим, задан ли артикул элемента
				// и затем определим первую часть данных 
			    
				
				//$value = $shop_item['Тип записи'];
				
				//echo 'shop_item[Тип записи] = ' . $shop_item['Тип записи'] . '<br>';
				
				// уберём в полученной строке дубликаты кавычек и кавычки по краям
				$zp_element['type'] = zp_correct_quotes($shop_item['Тип записи']);
				
				
				//echo  '000000000000000 zp_element[type] = ' . $zp_element['type'] . ', zp_element[type_of_type] = ' . $zp_element['type_of_type'] . '<br>';
				
				// если значение поля содержит тип (в формате "значение***тип"), т.е. это товар и его тип, тогда выясняем этот тип
				$zp_element['type_of_type'] = strpos($zp_element['type'], '***');
  				if($zp_element['type_of_type'] !== false) 
  				{
  				  $zp_element['type_of_type'] = explode('***', $zp_element['type']);
				  $zp_element['type'] = $zp_element['type_of_type'][0];
				  $zp_element['type_of_type'] = $zp_element['type_of_type'][1];
				  
				  
				  
				} 
				
				
				//echo  '000000000000000 zp_element[type] = ' . $zp_element['type'] . ', zp_element[type_of_type] = ' . $zp_element['type_of_type'] . '<br>';
				
				
				
//--------------------------------------------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------------------------------------------				
				
				
				
				
				
				
				// определяем артикулы и, соответственно, связи для разных типов элементов
				$artikul_changes_exists = 0;
				$new_value_with_history = array();
				
				// перебираем все поля из артикула и выясним новые и старые значения номеров артикула
				foreach ($shop_item as $key => $value)
				{
					// работаем только с полями артикула
					if($key != 'Страна' AND
					   $key != 'Город' AND
					   $key != 'Район' AND
					   $key != 'Магазин' AND
					   $key != 'Подотдел' AND
					   $key != 'Подгруппа / тип элемента' AND
					   $key != 'Товар / родительский подотдел'
					  )
					continue;
					
					
					// исправим лишние кавычки, если есть
					$value = zp_correct_quotes($value);

		
					if($value[0] . $value[1] . $value[2] == '###') // управляющие символы в начале строки
		 			{
						$value = explode('###', $value);
		   	
						foreach($value as $k => $val)
						{
							if($k == 0 OR $k == 1)
		      	 		  		$new_value_with_history[$key] = $new_value_with_history[$key] . $val;
		    				else  
		      	 		  		$new_value_with_history[$key] = $new_value_with_history[$key] . '###' . $val;  
						} 
			
						$value_old = $value[2];
						$value = $value[1];
						
						$artikul_changes_exists = 1;  // значит какой-то из номеров артикула изменился
		 			}
		 			else if(strpos($value, '###') !== FALSE) // управляющие символы в середине строки
		 			{
		 				$value = explode('###', $value);
		   	
						foreach($value as $k => $val)
						{
							if($k == 0)
		      	 		 	 	$new_value_with_history[$key] = $new_value_with_history[$key] . $val;
		    				else  
		      	 		 	 	$new_value_with_history[$key] = $new_value_with_history[$key] . '###' . $val;  
						} 
			
						//$value_old = $value[1];
						$value = $value[0];
						$value_old = $value;
						
						//echo ' hist --- key = ' . $key . ', new value = ' . $value . ', old value = ' . $value_old . '<br>';
						
		 			}
		 			else 
		 			{
		 				$value_old = $value;
		 			}
		 		

		 			// уберём в полученной строке дубликаты кавычек и кавычки по краям
		 			// и сохраним в массив 
		 			$zp_new_artikuls[$key] = $value;
		 			$zp_old_artikuls[$key] = $value_old;
	 			
				} // end of foreach ($shop_item as $key => $value) // перебираем все поля из артикула  и выясним новые и старые значения номеров артикула
				
				
				
// ---------------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------
				
				
				
				
				

				// в зависимости от типа записи зададим артикулы, тип ноды и прочие данные
				switch($zp_element['type'])
				{
					case 'страна':
				
						// если заданы не все составляющие артикула места (и, соответственно, местоположения места)
						// выходим из подпрограммы с указанием ошибки в поле "действие / результат"
						if(!$zp_new_artikuls['Страна'])
						 {
						 	$shop_item['Действие / результат'] = 'new error: не указан номер страны' ; 
							return $shop_item;
						 }

						// задаём внутренний zp артикул страны
						$zp_element['zp_artikul'] = 'z' . $zp_new_artikuls['Страна']; 
					 	
						// задаём zp номер страны
						$zp_element['zp_number'] = $zp_new_artikuls['Страна'];
						
						$node->type = 'c_country';						
						//$zp_element['каталог_с_картинками'] = 'country_img';
						break;
						
					case 'населённый пункт': // обычно город
					
						// если заданы не все составляющие артикула места (и, соответственно, местоположения места/города)
						// выходим из подпрограммы с указанием ошибки в поле "действие / результат"
						if(!$zp_new_artikuls['Страна'] OR !$zp_new_artikuls['Город'])
						 {
						 	$shop_item['Действие / результат'] = 'new error: не указаны какие-то из номеров местоположения для населённого пункта' ; 
							return $shop_item;
						 }
						 
						// задаём внутренний zp артикул населённого пункта (города)
						$zp_element['zp_artikul'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город']; 
						
						// определим артикул родителя
						$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна']; 
					 	
						// задаём номер населённого пункта (внутри его страны)
						$zp_element['zp_number'] = $zp_new_artikuls['Город'];
						
						$node->type = 'c_city';
						//$zp_element['каталог_с_картинками'] = 'city_img';
						break;
						
					case 'район':
	
						// если заданы не все составляющие артикула места (и, соответственно, местоположения места)
						// выходим из подпрограммы с указанием ошибки в поле "действие / результат"
						if(!$zp_new_artikuls['Страна'] OR !$zp_new_artikuls['Город'] OR !$zp_new_artikuls['Район'])
						 {
						 	$shop_item['Действие / результат'] = 'new error: не указаны какие-то из номеров местоположения для района' ; 
							return $shop_item;
						 }
						 
						// задаём внутренний zp артикул района
						$zp_element['zp_artikul'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район']; 
						
						// определим артикул родителя
						$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город']; 
						
						// задаём номер района (внутри населённого пункта, города)
						$zp_element['zp_number'] = $zp_new_artikuls['Район'];

						$node->type = 'c_rajon';
						//$zp_element['каталог_с_картинками'] = 'rajon_img';
						break;
						
					case 'магазин':
						
						// если заданы не все составляющие артикула места (и, соответственно, местоположения места)
						// выходим из подпрограммы с указанием ошибки в поле "действие / результат"
						if(!$zp_new_artikuls['Страна'] OR !$zp_new_artikuls['Город'] OR !$zp_new_artikuls['Район'] OR !$zp_new_artikuls['Магазин'])
						 {
						 	$shop_item['Действие / результат'] = 'new error: не указаны какие-то из номеров местоположения для магазина' ; // сбрасываем флаг необходимости добавления элемента в базу	
							return $shop_item;
						 }
						 
						// задаём внутренний zp артикул магазина
						$zp_element['zp_artikul'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин']; 
						
						// определим артикул родителя
						$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район']; 
						
						// задаём номер магазина (внутри внутри района)
						$zp_element['zp_number'] = $zp_new_artikuls['Магазин'];

						$node->type = 'c_shop';
						//$zp_element['каталог_с_картинками'] = 'shop_img';
						break;
						
					case 'подотдел':
						
						// если заданы не все составляющие артикула места (и, соответственно, местоположения места)
						// выходим из подпрограммы с указанием ошибки в поле "действие / результат"
						if(!$zp_new_artikuls['Страна'] OR !$zp_new_artikuls['Город'] OR !$zp_new_artikuls['Район'] OR !$zp_new_artikuls['Магазин'] OR !$zp_new_artikuls['Подотдел'] OR !$zp_new_artikuls['Товар / родительский подотдел'])
						 {
						 	$shop_item['Действие / результат'] = 'new error: не указаны какие-то из номеров местоположения для подотдела' ; // сбрасываем флаг необходимости добавления элемента в базу	
							return $shop_item;
						 }
						 
						// задаём внутренний zp артикул подотдела
						$zp_element['zp_artikul'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин'] . $zp_new_artikuls['Подотдел']; 
						
						// определим артикул родителя
						if($zp_new_artikuls['Товар / родительский подотдел'] == '000')
							$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин']; 
						else
							$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин'] . $zp_new_artikuls['Товар / родительский подотдел']; 
							
							
						// задаём номер подотдела (внутри магазина)
						$zp_element['zp_number'] = $zp_new_artikuls['Подотдел'];
						
						$zp_element['родительский подотдел'] = $zp_new_artikuls['Товар / родительский подотдел']; // проверить, где используется эта переменная и нужна ли она вообще
						
						$node->type = 'c_department';
						//$zp_element['каталог_с_картинками'] = 'dept_img';
						break;
						
					case 'подгруппа':

						// Хотя артикул группы и не сохраняется в ноде, он необходим для организации связей и указания его местоположения
						// Поэтому если заданы не все составляющие артикула (и, соответственно, местоположения группы)
						// выходим из подпрограммы с указанием ошибки в поле "действие / результат"
						if(!$zp_new_artikuls['Страна'] OR !$zp_new_artikuls['Город'] OR !$zp_new_artikuls['Район'] OR !$zp_new_artikuls['Магазин'] OR !$zp_new_artikuls['Подотдел'])
						 {
						 	$shop_item['Действие / результат'] = 'new error: не заданы какие-то из номеров местоположения и товара для формирования внутреннего артикула zp'; // сбрасываем флаг необходимости добавления элемента в базу	
							return $shop_item;
						 }
						
						// определим артикул родителя
						$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин'] . $zp_new_artikuls['Подотдел']; 
						
						//$zp_element['type'] = 'подгруппа'; // этот элемент - продукт
						break;
						
					case 'товар':

						// если заданы не все составляющие артикула (и, соответственно, местоположения товара)
						// выходим из подпрограммы с указанием ошибки в поле "действие / результат"
						if(!$zp_new_artikuls['Страна'] OR !$zp_new_artikuls['Город'] OR !$zp_new_artikuls['Район'] OR !$zp_new_artikuls['Магазин'] OR !$zp_new_artikuls['Подотдел'] OR !$zp_new_artikuls['Подгруппа / тип элемента'] OR !$zp_new_artikuls['Товар / родительский подотдел'])
						 {
						 	$shop_item['Действие / результат'] = 'new error: не заданы какие-то из номеров местоположения и товара для формирования внутреннего артикула zp'; // сбрасываем флаг необходимости добавления элемента в базу	
							return $shop_item;
						 }
						// задаём внутренний zp артикул товара, он же - главный идентификатор товара SKU (model в базе uc)
						$zp_element['zp_artikul'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин'] . $zp_new_artikuls['Подотдел'] . $zp_new_artikuls['Товар / родительский подотдел']; 
						$node->model = $zp_element['zp_artikul'];
						// определим артикул родителя
						$zp_element['parent_otdel_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин'] . $zp_new_artikuls['Подотдел'];
						// в зависимости от типа товара (который указан через *** от слова "товар") зададим типа ноды для товара
						
						/*
						if(!$zp_element['type_of_type'] OR trim($zp_element['type_of_type']) == '')
						{
							$shop_item['Действие / результат'] = 'new error: не указан тип товара' ; 
							return $shop_item;
						}
						*/
						
						switch($zp_element['type_of_type'])
						{
							case 'set_1':
							case 'set_2':
								
								// тут нужно будет добавить остальные типы данных, при их появлении в системе
								break;
									
							default:
								// иначе тип товара не определён в системе
								$shop_item['Действие / результат'] = 'new error: тип продукта не указан или не определён в системе' . $zp_element['type_of_type'] . ' не определён в системе'; // сбрасываем флаг необходимости добавления элемента в базу	
								return $shop_item;
								//break;
								
						} // end of в зависимости от типа товара (который указан через *** от слова "товар") зададим типа ноды для товара
						
						$node->type = 'product_' . $zp_element['type_of_type'];
						
						
						// установим каталог с картинками для товара
						// для остальных элементов используются каталоги с картинками по умолчанию
					
						if(!$shop_item['Каталог с картинками'] OR trim($shop_item['Каталог с картинками']) == '')
						{
							$shop_item['Действие / результат'] = 'new error: не определён каталог с картинками для товара';
								return $shop_item;
						}
						
						$zp_element['каталог_с_картинками'] = $shop_item['Каталог с картинками'];
								
						break;
						
						
					default:
						// иначе тип элемента не определён в системе
						$shop_item['Действие / результат'] = 'new error: тип элемента ' . $value . ' не определён в системе'; // сбрасываем флаг необходимости добавления элемента в базу	
						return $shop_item;
						//break;
						
				} // end of switch($zp_element['type']) // в зависимости от типа записи зададим артикулы, тип ноды и прочие данные

				
				
				
	
				
				
				
				
	// Проверим, не присутствует ли уже в базе элемента с внутренним артикулом таким же, как у этого (создаваемого) элемента	
	
	if($shop_item['Тип записи'] != 'подгруппа')
	{
	
  	  //$new_zp_artikul = 'z' . $shop_item['Страна'] . $shop_item['Город'] . $shop_item['Район'] . $shop_item['Магазин'] . $shop_item['Подотдел'] . $shop_item['Товар / родительский подотдел'];
	  
	  if(strpos($shop_item['Тип записи'], 'товар') !== false)
	    $existing_nid_with_such_zp_zrtikul = db_result(db_query("SELECT nid from {uc_products} WHERE model = '%s'", $zp_element['zp_artikul']));
	  else   
	    $existing_nid_with_such_zp_zrtikul = db_result(db_query("SELECT nid from {content_field_zp_art_place} WHERE field_zp_art_place_value = '%s'", $zp_element['zp_artikul']));
	  
	  if($existing_nid_with_such_zp_zrtikul)
	  {
	    $exisiting_name = db_result(db_query("SELECT title  from {node} WHERE nid = %d", $existing_nid_with_such_zp_zrtikul));
	  	$shop_item['Действие / результат'] = 'new error: в базе уже присутствует элемента с артикулом ' . $zp_element['zp_artikul'] . ' и называется ' . $exisiting_name; 
	    
	  	echo 'new error: в базе уже присутствует элемента с артикулом ' . $zp_element['zp_artikul'] . ' и называется ' . $exisiting_name; 
	  	
	  	return $shop_item;
	  }
	}
	
				
				
				
	
	
	
	
	
	// Проверим, всё ли в порядке с заданными связями - присутствуют ли родители, 
	// не существует ли уже у заданного родителя элементов с таким же названием, как у вводимого элемента и т.д.
	switch($zp_element['type'])
	 {
		case 'страна':
			// проверим, не введен ли уже терм страны с таким названием
			$check_countries = taxonomy_get_term_by_name($node->title);
        	$zp_element['term_is_dublicate'] = 0;
        	foreach ($check_countries as $check_country) 
        	  {
          		if ($check_country->vid == 1) 
          		 {
            		$parent_tid = db_result(db_query("SELECT parent from {term_hierarchy} WHERE tid = %d", $check_country->tid));
          		 	if($parent_tid == 0) // если найден терм с таким же именем, с таким же номером словаря, да ещё у него и тид родителя = 0 (корень)
          		 	 $zp_element['term_is_dublicate'] = 1; // значит найдено совпадение - в базе уже имеется страна с таким названием, которое мы хотим внести
          		 }
        	  }
        	  
        	if($zp_element['term_is_dublicate'])
        	{
        	 $shop_item['Действие / результат'] = 'new error: терм с названием страна ' . $node->title . ' уже присутствует в базе (и именно в категории страна)'; 
						 return $shop_item;
        	}
        	
			break;
	 		 
	 	case 'населённый пункт':	
	 	case 'район':
	 	case 'магазин':
	 	case 'подотдел':
	 	case 'подгруппа':
	 		$parent_nid = db_result(db_query("SELECT nid from {content_field_zp_art_place} WHERE field_zp_art_place_value = '%s'", $zp_element['parent_zp_art']));
 			
	 		//echo 'parent_nid = ' . $parent_nid;
	 		
	 		if(!$parent_nid) // если в базе нет ноды с таким артикулом, который указан как родительский
    		{
    			$shop_item['Действие / результат'] = 'new error: в базе нет элемента (с артикулом ' . $zp_element['parent_zp_art'] . '), заданного как родитель для этого элемента'; 
				  return $shop_item;
    		}
	 		
	 		$parent_tids = taxonomy_node_get_terms_by_vocabulary($parent_nid, 1); // вообще предполагается, что для каждой ноды может быть задан только один терм из словаря с каталогом. Поэтому дальнейший перебор - просто техническое ухищрение, чтобы вытащить данные из объекта, возвращаемого этой функцией
   			foreach($parent_tids as $parent_tid)
    		{
      			$zp_element['parent_tid_name'] = $parent_tid->name;
		      	$zp_element['parent_tid'] = $parent_tid->tid;
    		}
    		
    		//echo 'parent_tid =' . $zp_element['parent_tid'];
    		
    		if(!$zp_element['parent_tid']) // если в базе не задан терм для ноды с таким артикулом, который указан как родительский
    		{
    			$shop_item['Действие / результат'] = 'new error: в базе не задан терм для элемента (с артикулом ' . $zp_element['parent_zp_art'] . '), заданного как родитель для этого элемента'; 
				  return $shop_item;
    		}
    		
    		// проверим, нет ли уже у данного родителя терма с таким же именем, который мы хотим создать
    		$test_children_of_parent_tids = taxonomy_get_children($zp_element['parent_tid']);
    		
    		$zp_element['term_is_dublicate'] = 0;
   			foreach($test_children_of_parent_tids as $test_children_of_parent_tid)
    		{
      			if($test_children_of_parent_tid->name == $node->title)
      			{
		      	  $zp_element['term_is_dublicate'] = 1;
		      	  $zp_element['existing_term_tid'] = $test_children_of_parent_tid->tid;
		      	  break; // среди детей данном родителя найден терм с таким же именем, которое мы хотим создать как новый потомок данного родителя
      			}  
    		}
    		
    		if($zp_element['term_is_dublicate']) // если в базе уже есть терм с таким названием у указанного родителя
    		{
    			// вообще-то можно использовать уже существующий терм для вновь создаваемого элемента
    			// или создавать терм с добавлением частицы "_new" к названию терма
    			
  				// чтобы использовать эту возможность, необходимо не вызходить из функции тут, а продолжить её
  				// а похже в блоке внесения данных по связям раскомментировать часть кода, которая позволяет осуществить указанные возможности
  				
  				// пока же, по умолчанию, элемент не вносится, функция по этому элементу прерывается в этом месте с указанием ошибки
  				
    			
    			$shop_item['Действие / результат'] = 'new error: терм с названием ' . $node->title . ' для типа ' . $zp_element['type'] . ' уже присутствует в базе у указанного родителя'; 
				  return $shop_item;

    		} // end of if($flag_is_dublicat) // если в базе уже есть у терм с таким названием у указанного родителя

    		break;
    		
    		
    		
    	case 'товар':
	 		
    		// если в базе нет ноды с таким артикулом, который указан как родительский
	 		if(!($parent_otdel_nid = db_result(db_query("SELECT nid from {content_field_zp_art_place} WHERE field_zp_art_place_value = '%s'", $zp_element['parent_otdel_zp_art'])))) 
    		{
    			$shop_item['Действие / результат'] = 'new error: в базе нет подотдела (с артикулом ' . $zp_element['parent_otdel_zp_art'] . '), заданного как родитель для этого элемента'; 
				  return $shop_item;
    		}
	 		
	 		//echo 'parent_otdel_zp_art = ' . $zp_element['parent_otdel_zp_art'] . '<br>';  
	 		//echo 'parent_otdel_nid = ' . $parent_otdel_nid . '<br>';
	 		
	 		$parent_otdel_tids = taxonomy_node_get_terms_by_vocabulary($parent_otdel_nid, 1);
   			foreach($parent_otdel_tids as $parent_otdel_tid)
    		{
      			$zp_element['parent_otdel_tid_name'] = $parent_otdel_tid->name;
		      	$zp_element['parent_otdel_tid'] = $parent_otdel_tid->tid;
    		}
    		
    		//echo 'parent_otdel_tid_name =' . $zp_element['parent_otdel_tid_name'] . '<br>';
    		//echo 'parent_otdel_tid =' . $zp_element['parent_otdel_tid'] . '<br>';
    		
			// проверим, есть ли в базе указанная в таблице подгруппа (в указанном подотделе), к которой должен принаджежать данный товар
    		$parent_podgruppa_tids = taxonomy_get_children($zp_element['parent_otdel_tid']);
    		
    		//echo 'zp_element["подгруппа_или_тип_элемента"] = ' . $zp_element['подгруппа_или_тип_элемента'] . '<br>';
    		
    		$zp_element['term_parent_exists'] = 0;
    		foreach($parent_podgruppa_tids as $parent_podgruppa_tid)
    		{
    			
    			//echo '--parent_podgruppa_tid->name = ' . $parent_podgruppa_tid->name . '<br>';
    			
      			if($parent_podgruppa_tid->name == $zp_element['подгруппа_или_тип_элемента'])
      			{
		      	  $zp_element['parent_podgruppa_tid'] = $parent_podgruppa_tid->tid;
		      	  $zp_element['term_parent_exists'] = 1;
		      	  
		      	  //echo '---parent_podgruppa_tid = ' . $zp_element['parent_podgruppa_tid'] . '<br>';
		      	  
		      	  break; // найдена подгруппа с указанным именем в заданном подотделе, это и будет родительским термом для товара
      			}  
    		}
    		
    		//echo '---flag_is_podruppa =' . $zp_element['term_parent_exists'] . '<br>';
    		
    		// если терм подгруппы не найден в базе в указанном отделе
    		if(!$zp_element['term_parent_exists'])
    		{
    			$shop_item['Действие / результат'] = 'new error: терм подгруппы с названием ' . $zp_element['подгруппа_или_тип_элемента'] . ' не определён в базе у указанного родителя'; 
				  return $shop_item;
    		}
    		
    		break; // end of case 'товар':
	 
	 } // end of switch($zp_element['type']) // следующий шаг создания и связывания категорий элемента
	
// конец проверки данных о связывании категорий ---------------------------------------------------------
	 

	
	
					
				

	
	

	
	

				
				
				
	
	
	
	
	
	
	
	
	
	
	// установим все поля по умолчанию, касающиеся стандартного элемента

    
	$zp_element['вес_элемента_в_группе'] = 0;
	
	if($shop_item['Тип записи'] != 'подгруппа')
    {
  	
		// задём эти значения позже, после всех предварительных проверок
    	//$node->nid = db_next_id('{node}_nid');
    	//$node->vid = db_next_id('{node_revisions}_vid');
    
    	$node->uid = $user->uid;
    	
    	$node->created = time();
    	$node->changed = time();
    	
    	$node->status = 1;
    	$node->comment = 0;
    	$node->promote = 0;
    	$node->moderate = 0;
    	$node->sticky = 0;
    	$node->log = ''; // комментарий к созданной ноде, его тоже можно через таблицу внести
    	$node->body = ''; // по умолчанию, это поле используется для внутреннего описания товара в магазине или для описания отдела, магазина, района, города, страны...
    	$node->teaser = ''; // по умолчанию, эти стандартные поля мы не используем, а вместо них используем специально заданные поля
    	$node->format = 1; // надо выяснить, что это за параметр (указывается в таблице node_revisions)
    	
    	
	 	
    	
    	$zp_element['source_of_pics'] = 1; 	//  zp-артикул (0), международный штрих-код (1), Ш-код производителя (2), Артикул производителя (3), Ш-код поставщика (4), Артикул поставщика (5), Ш-код магазина (6), Артикул магазина (7)
											// по умолчанию считаем, что картинка формируется на основе международного штрих-кода
    	
		
    	$zp_element['logo'] = 'нет';
    	//$zp_element['address'] = '';

    	$zp_element['коэффициент_доставки'] = 1; // по умолчанию, коэффициент доставки равен 1 (не изменяется стоимость доставки)
    	$zp_element['коэффициент_минимальной_суммы_покупки_(корзины)'] = 1; // по умолчанию, коэффициент минимальной суммы корзины равен 1 (не изменяется минимальная сумма относительно стандартного значения)
    	
    	//$zp_element['описание_элемента_локальное'] = '';
    	//$zp_element['описание_элемента'] = ' ';
    	
    	$zp_element['кол_во_картинок'] = 2;
    	$pic_amount = 2; // по умолчанию, количество картинок равно двум
    	$zp_element['ориентация_картинок'] = ''; // ориентация может быть вертикальная ("" или "v") или горизонтальная ("h"). При горизонтальной картинка тизера должна быть развёрнута на 90 градусов
    }
    
    // есои это товар
    if(strpos($shop_item['Тип записи'], 'товар') !== false)
    {
    	//$node->model = ''; 
    	$node->list_price = 0;
    	$node->cost = 0; 
    	$node->sell_price = 0; 
    	$node->weight = 0; 
    	$node->weight_units = 'кг';
    	$node->length = 0; 
    	$node->width = 0; 
    	$node->height = 0; 
    	$node->length_units = 'мм'; 
    	$node->pkg_qty = 1; // количество в наборе 
    	$node->default_qty = 1; // кол-во для добавления в корзину по учолчанию 
    	$node->unique_hash = ''; 
    	$node->ordering = 0;
    	$node->shippable = 1;
    	
    	

    	//$zp_element['штрих_код_произв'] = '';
    	//$zp_element['артикул_произв'] = '';
    	//$zp_element['штрих_код_поставщ'] = '';
    	//$zp_element['артикул_поставщ'] = '';
    	//$zp_element['штрих_код_магазина'] = '';
    	//$zp_element['артикул_магазина'] = '';
    	
    	//$zp_element['название_бренда'] = '';
    	
    	
    	
    	$zp_element['количество'] = 1;
    	$zp_element['уменьшать_количество_при_продаже'] = 0; // по умолчанию контроль количества выключен
    	$zp_element['количество_ниже_которого_не_продавать'] = 0; // по умолчанию порог минимального количества равен нулю
    	
    	$zp_element['атрибут_ваши_пожелания'] = 'есть';
    	
    	
    	$zp_element['продажная_единица_измерения'] = 'шт';


    }
    
    
    
    
     				
		
	
    
    
    
    
	
    // перебираем все поля элемента и задаём некоторые исходные данные
	foreach ($shop_item as $field => $value)
	{
		//echo '1`````````````field = ' . $field . ', value = ' . $value . '<br>';
		
		// уберём в полученной строке дубликаты кавычек и кавычки по краям
		$value = zp_correct_quotes($value);

		// если первые три символа в поле '###', значит поле может содержать несколько версий и историю изменений... уберём эти символы и используем только первое за этими символами значение (остальные отбрасываем)
		$new_value_with_history = FALSE;
		if($value[0] . $value[1] . $value[2] == '###')
		 {
			$value = explode('###', $value);
		   	
			foreach($value as $key => $val)
			{
				if($key == 0 OR $key == 1)
		      	 $new_value_with_history[$field] = $new_value_with_history[$field] . $val;
		    	else  
		      	 $new_value_with_history[$field] = $new_value_with_history[$field] . '###' . $val;  
			} 
			
			$value = $value[1];
		 }
		 else if(strpos($value, '###') !== FALSE)
		 {
		 	$value = explode('###', $value);
		   	
			foreach($value as $key => $val)
			{
				if($key == 0)
		      	 $new_value_with_history[$field] = $new_value_with_history[$field] . $val;
		    	else  
		      	 $new_value_with_history[$field] = $new_value_with_history[$field] . '###' . $val;  
			} 
			
			$value = $value[0];
		 	
		 }
	

		 		
		// зададим необходимые значения для элемента в зависимости от значения его конкретных (ещё не внесённых ранее в этой функции) полей
		switch ($field)
		{

			case 'Описание локальное (отдела, магазина, района и т.д.)':
				if($value AND trim($value) != '') // менять только в том случае, если в поле что-то задано
				{
					$zp_element['описание_элемента_локальное'] = $value;
					$node->body = $value;
					
					$node->teaser = substr($value, 0, 100); // записываем тизер длиной 100 символов из основного текста. Кстати, по усолчанию друпал записывает около 323 символов, но нам столько слишком много для тизеров отделов и т.д.
				}
				break;
				
			case 'Описание внешнее':
				if($value AND trim($value) != '') // менять только в том случае, если в поле что-то задано
					$zp_element['описание_внешнее'] = $value;
				break;

			
			case 'Кол-во': 
				if($value AND trim($value) != '') // менять только в том случае, если в поле что-то задано
					$zp_element['количество'] = $value;
				break;

			case 'Уменьшать кол-во при продаже': 
				if($value AND trim($value) != '') // менять только в том случае, если в поле что-то задано
					$zp_element['уменьшать_количество_при_продаже'] = $value;
				break;
						
			case 'Кол-во, ниже которого не продавать': 
				if($value AND trim($value) != '') // менять только в том случае, если в поле что-то задано
					$zp_element['количество_ниже_которого_не_продавать'] = $value;
				break;

			case 'Цена':
				// если в числе содержится не точка, а запятая, меняем запятую на точку
				if(strpos($value, ',') !== FALSE)
					$value = str_replace(',', '.', $value);
					
				$node->sell_price = $value;
				break;
				
			case 'Вес/объём, значение':
				if($value AND trim($value) != '') // менять только в том случае, если в поле что-то задано
				{
					// если в числе содержится не точка, а запятая, меняем запятую на точку
					if(strpos($value, ',') !== FALSE)
						$value = str_replace(',', '.', $value);
					
					$node->weight = $value;
				}
				break;					
				
				
			case 'Вес/объём, мера':
				if($value AND trim($value) != '') // менять только в том случае, если в поле что-то задано
					$node->weight_units = $value;
				break;
			
				
			case 'Продажная единица измерения':
				if($value AND trim($value) != '') // менять только в том случае, если в поле что-то задано, по умолчанию задано (выше) - шт
					$zp_element['продажная_единица_измерения'] = $value;
				break;	

				
			case 'Ш-код международный (1)':
				if($value AND trim($value) != '') // менять только в том случае, если в поле что-то задано
					$zp_element['ш_код_международный'] = $value;
				break;
				
				
			case 'Ш-код производителя (2)':
				if($value AND trim($value) != '') // менять только в том случае, если в поле что-то задано
					$zp_element['ш_код_производителя'] = $value;
				break;
				
					
			case 'Артикул производителя (3)':
				if($value AND trim($value) != '') // менять только в том случае, если в поле что-то задано
					$zp_element['артикул_производителя'] = $value;
				break;
			
				
			case 'Ш-код поставщика (4)':
				if($value AND trim($value) != '') // менять только в том случае, если в поле что-то задано
					$zp_element['ш_код_поставщика'] = $value;
				break;
				
				
			case 'Артикул поставщика (5)':
				if($value AND trim($value) != '') // менять только в том случае, если в поле что-то задано
					$zp_element['артикул_поставщика'] = $value;
				break;
				
				
			case 'Ш-код магазина (6)':
				if($value AND trim($value) != '') // менять только в том случае, если в поле что-то задано
					$zp_element['ш_код_магазина'] = $value;
				break;
				
				
			case 'Артикул магазина (7)':
				if($value AND trim($value) != '') // менять только в том случае, если в поле что-то задано
					$zp_element['артикул_магазина'] = $value;
				break;
				
			
				
				
				
			case 'Производитель':
				if($value AND trim($value) != '') // менять только в том случае, если в поле что-то задано
					$zp_element['производитель'] = $value;
				break;
				
			case 'ZP MC ID производителя':
				if($value AND trim($value) != '') // менять только в том случае, если в поле что-то задано
					$zp_element['zp_mc_id_производителя'] = $value;
				break;				
			
			case 'Поставщик':
				if($value AND trim($value) != '') // менять только в том случае, если в поле что-то задано
					$zp_element['поставщик'] = $value;
				break;
				
			case 'ZP MC ID поставщика':
				if($value AND trim($value) != '') // менять только в том случае, если в поле что-то задано
					$zp_element['zp_mc_id_поставщика'] = $value;
				break;				
			
				
				
				
			case 'Ключевые слова':
				if($value AND trim($value) != '') // менять только в том случае, если в поле что-то задано
					$zp_element['ключевые_слова'] = $value;
				break;
			
			
				
			case 'Бренд':
				if($value AND trim($value) != '') // менять только в том случае, если в поле что-то задано
					$zp_element['бренд'] = $value;
				break;	
				

				

			
			case 'Каталог с картинками':
				if($value AND trim($value) != '') // менять только в том случае, если в поле что-то задано
					$zp_element['каталог_с_картинками'] = $value;
				break;
			
			case 'На основе чего формируется название картинок':
				if($value AND trim($value) != '') // менять только в том случае, если в поле что-то задано
					$zp_element['source_of_pics'] = $value;
				break;
			
			case 'Кол-во картинок':
				if($value AND trim($value) != '') // менять только в том случае, если в поле что-то задано
					$zp_element['кол_во_картинок'] = $value;
				break;	
								
				
				
			case 'Ориентация картинок':
				if($value AND trim($value) != '') // менять только в том случае, если в поле что-то задано
					$zp_element['ориентация_картинок'] = $value;
				break;			
				
				
			case 'Адрес':
				if($value AND trim($value) != '') // если в этом поле не пусто, то используем значение поля, иначе остаётся знаение по умолчанию "нет"
					$zp_element['адрес'] = $value;
				break;	
				

			case 'Логотип':
				if($value AND trim($value) != '') // если в этом поле не пусто, то используем значение поля, иначе остаётся знаение по умолчанию "нет"
				  $zp_element['logo'] = $value;
				break;	

				
			case 'Коэффициент доставки':
				if($value AND trim($value) != '') 
				{
					// если в числе содержится не точка, а запятая, меняем запятую на точку
					if(strpos($value, ',') !== FALSE)
						$value = str_replace(',', '.', $value);

					$zp_element['коэффициент_доставки'] = $value;
				}	
				break;					

				
			case 'Коэффициент минимальной суммы покупки (корзины)':
				if($value AND trim($value) != '') 
				{
					// если в числе содержится не точка, а запятая, меняем запятую на точку
					if(strpos($value, ',') !== FALSE)
						$value = str_replace(',', '.', $value);
					
					$zp_element['коэффициент_минимальной_суммы_покупки_(корзины)'] = $value;
				}	
				break;
			
			
			case 'Атрибут Ваши пожелания':
				if($value AND trim($value) != '') 
					$zp_element['атрибут_ваши_пожелания'] = $value;
					
				break;
				
				
			case 'Другие атрибуты товара':
				if($value AND trim($value) != '') 
					$zp_element['другие_атрибуты_товара'] = $value;
					
				break;
				
			case 'Статус элемента':
				if($value AND trim($value) != '') 
					$zp_element['статус_элемента'] = $value;
					
				break;
				
			case 'Вес элемента в группе':
				if($value AND trim($value) != '') 
					$zp_element['вес_элемента_в_группе'] = $value;
					
				break;
						

			default:
				break;
			
		} // end of // зададим необходимые значения для элемента в зависимости от значения его конкретных полей

		// если поле содержало признако необходимости изменения ### в начале, то убираем этот признак в возвращаемом значении, так как изменение уже произведено
		
		// эта операция производится позже, где обрабатывается массив $new_value_with_history, а не простая переменная, как тут, что неправильно
		//if($new_value_with_history)
		 //$shop_item[$field] = $new_value_with_history;
	    
	} // end of foreach ($shop_item as $field => $value) // перебираем все поля элемента
	


     
     
     
     // если заданы "другие" атрибуты товара, проверим, правильно ли задана строка с атрибутами
     
     if($zp_element['type'] == 'товар' AND $zp_element['другие_атрибуты_товара'])
     {
     	 
     	//$string = 'text***Цвет***Описание атрибута[Красный^^^0---Зелёный^^^3,40]select***Размер[24^^^1.20---43^^^5.21]';
		
     	
		//if($zp_element['другие_атрибуты_товара'] != 'Нет' AND $zp_element['другие_атрибуты_товара'] != 'нет' AND $zp_element['другие_атрибуты_товара'] != '0' AND $zp_element['другие_атрибуты_товара'] != 0 AND $zp_element['другие_атрибуты_товара'] != ' ')
		if(!$zp_element['другие_атрибуты_товара'] OR $zp_element['другие_атрибуты_товара'] == 'Нет' OR $zp_element['другие_атрибуты_товара'] == 'нет' OR $zp_element['другие_атрибуты_товара'] == '0' OR $zp_element['другие_атрибуты_товара'] == ' ')
		{
     		$zp_element['другие_атрибуты_товара'] = 'нет';
		}
		else 
		{
			if(strpos($zp_element['другие_атрибуты_товара'], ']') === FALSE)
 				$error_format = 1;
 
			$str = explode(']', $zp_element['другие_атрибуты_товара']);
		

			$count = 0;
			foreach($str as $atr)
			{
				if(!$atr)
	 				continue;
	 
				$xxx = array();
	
				if(strpos($atr, '[') === FALSE)
					$error_format = 1;
 
				$atr = explode('[', $atr);
				//$atr_name_type = $atr[0];
	
				if(strpos($atr[0], '***') === FALSE)
					$error_format = 1;
	
				$atr_name_type = explode('***', $atr[0]);
			
				$atr_type = $atr_name_type[0];
			
				if($atr_type != 'text' AND $atr_type != 'select' AND $atr_type != 'radio')
				{
					$shop_item['Действие / результат'] = 'new error: Неверный формат строки с атрибутами ' . $zp_element['другие_атрибуты_товара'] . '. Тип атрибута может быть только text, select, radio, а задан -' . $atr_type . '-'; 
					return $shop_item;
				}     
			
				$atr_name = $atr_name_type[1];
				$atr_descr = $atr_name_type[2];
	
			
				if(strpos($atr[1], '---') === FALSE)
					$error_format = 1;
		
				$atr = explode('---', $atr[1]);
			
				$count_options = 0;
				foreach($atr as $options)
				{
					$count_options++;
					
					if(strpos($options, '^^^') === FALSE)
						$error_format = 1;
		
					$option = explode('^^^', $options);
				
				
					// $option[0] - название опции
					// $option[1] - добавка к стоимости, грн
				
					// если в числе содержится не точка, а запятая, меняем запятую на точку
					if(strpos($option[1], ',') !== FALSE)
						$option[1] = str_replace(',', '.', $option[1]);
				
					// Стоимость первой опции в атрибуте должна быть нулевой, тогда цена будет правильно отображаться для пользователя
					// иначе отображаться будет по умолчанию нулевая цена при выбранной опции с ненулевой добавочной ценой
					if($count_options == 1 AND ($option[1] != 0 AND $option[1] != '0.0' AND $option[1] != '0.00' AND $option[1] != '00.00' AND $option[1] != '00.0' AND $option[1] != '' AND $option[1] != ' '))
					{
						$shop_item['Действие / результат'] = 'new error: Неверный формат строки с атрибутами ' . $zp_element['другие_атрибуты_товара'] . '. Стоимость первой опции -' . $option[0] . '- в атрибуте -' . $atr_name . '- должна быть нулевой!'; 
						return $shop_item;
					}
		
					$xxx[$option[0]] = $option[1];
				}
			
				$attributes[$count]['descr'] = $atr_descr;
				$attributes[$count]['type'] = $atr_type;
				$attributes[$count]['name'] = $atr_name;
				$attributes[$count]['options'] = $xxx;
	
				$count++;
			}

			if($error_format == 1)
			{
				$shop_item['Действие / результат'] = 'new error: Неверный формат строки с атрибутами ' . $zp_element['другие_атрибуты_товара']; 
				return $shop_item;
	   		}
	   		
	   		$zp_element['другие_атрибуты_товара'] = $attributes;
	   		
		} // end of if($zp_element['другие_атрибуты_товара'] != 'Нет' AND $zp_element['другие_атрибуты_товара'] != 'нет' AND $zp_element['другие_атрибуты_товара'] != '0' AND $zp_element['другие_атрибуты_товара'] != 0 AND $zp_element['другие_атрибуты_товара'] != ' ')
		
   	
     } // end of if($zp_element['type'] == 'товар' AND $zp_element['другие_атрибуты_товара']) // если заданы "другие" атрибуты товара, проверим, правильно ли задана строка с атрибутами
     
     
    
  	 
     

     
     
     
     
     
     
     
     
     
     
     
     

     
     // если задано внешнее описание, проверим, заданы ли внешние идентификаторы, на которые можно записать внешнее описание (международный ш-код, штрих-коды или артикулы поставщика или производителя и сами идентификаторы производителя или поставщика)
	 // ниже, при внесении в базу, структура кода примерно похожа, но там больше действий
       
			// внесём внешнее описание товаров и/или ключевые слова, если они заданы для товара и заданы необходимые дополнительные данные
			
			if($zp_element['описание_внешнее']) //OR $zp_element['ключевые_слова'])
			{
				// если для товара определен междуеародный штрих-код
				if($zp_element['ш_код_международный'])
				{
					// внести внешнее описание и/или ключевые слова в таблицу с описанием по международному штрих-коду
					//if(!db_query("INSERT INTO {p_descr_bw} (p_bw, p_name, descr, keywords) VALUES ('%s', '%s', '%s', '%s')", $zp_element['ш_код_международный'], $node->title, $zp_element['описание_внешнее'], $zp_element['ключевые_слова']))
			  	//	{
					//	$shop_item['Действие / результат'] = 'change error: ошибка при добавлении описания (и, возможно, ключевых слов товара по международному ш-коду';
					//	return $shop_item;
			  	//	}
			
				}
				else 
				if($zp_element['zp_mc_id_производителя'] AND ($zp_element['ш_код_производителя'] OR $zp_element['артикул_производителя']) )
				{
					// значит записываем описание и-или ключевые слова под ид производителя
					//if($zp_element['ш_код_производителя'])
					//	$p_id = $zp_element['ш_код_производителя']; 
					//else 
				//		$p_id = $zp_element['артикул_производителя'];
						
					//$seller_id = $zp_element['zp_mc_id_производителя'];
					//$seller_name = $zp_element['производитель'];
					
					
					//if(!db_query("INSERT INTO {p_descr_mc} (p_id, p_name, seller_id, seller_name, descr, keywords) VALUES ('%s', '%s', '%s', '%s')", $p_id, $node->title, $seller_id, $seller_name, $zp_element['описание_внешнее'], $zp_element['ключевые_слова']))
			  	//	{
					//	$shop_item['Действие / результат'] = 'change error: ошибка при добавлении описания (и, возможно, ключевых слов) товара по id производителя';
				//		return $shop_item;
			  		//}
					
				}
				else 
				if($zp_element['zp_mc_id_поставщика'] AND ($zp_element['ш_код_поставщика'] OR $zp_element['артикул_поставщика']) )
				{
					// значит записываем описание и-или ключевые слова под ид поставщика
					//if($zp_element['ш_код_поставщика'])
					//	$p_id = $zp_element['ш_код_поставщика']; 
					//else 
					//	$p_id = $zp_element['артикул_поставщика'];
						
					//$seller_id = $zp_element['zp_mc_id_поставщика'];
					//$seller_name = $zp_element['поставщик'];
					
					
					//if(!db_query("INSERT INTO {p_descr_mc} (p_id, p_name, seller_id, seller_name, descr, keywords) VALUES ('%s', '%s', '%s', '%s')", $p_id, $node->title, $seller_id, $seller_name, $zp_element['описание_внешнее'], $zp_element['ключевые_слова']))
			  	//	{
						//$shop_item['Действие / результат'] = 'change error: ошибка при добавлении описания (и, возможно, ключевых слов) товара по id поставщика';
					//	return $shop_item;
			  	//	}
				}
				//else 
				//if(!$zp_element['описание_внешнее'])// AND $zp_element['ключевые_слова'])
			//	{
					// если заданы только ключевые слова и не заданы внешние идентификаторы,
					// то записываем ключевые слова локально, в текущий объект а текущем магазине
					
					//if(!db_query("INSERT INTO {content_field_keywords} (nid, field_keywords_value) VALUES (%d, '%s')", $node->nid, $zp_element['ключевые_слова']))
			  	//	{
					//	$shop_item['Действие / результат'] = 'change error: ошибка при локальном добавлении ключевых слов в товар';
					//	return $shop_item;
			  		//}
					 
				//}
				else 
				{
					// иначе задано внешнее описание (и, возможно, ключевые слова), для которого нет внешнего идентификатора 
					// (международного ш-кода или id производителя или поставщика)
					// поэтому выдаём ошибку и выходим из программы
					$shop_item['Действие / результат'] = 'new error: ошибка при добавлении внешнего описания товара - не задан внешний идентификатор (международный ш-код или ID производителя или поставщика и их ID товара)';
					return $shop_item;
				}
	
			} // end of if($zp_element['описание_внешнее']) // OR $zp_element['ключевые_слова'])
			
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
    
    
    
    
    
    

    
    
//-------------------------------------------------------------------------------------------    
// теперь, после всех проверок, задаём новый нид и вид

	$node->nid = db_next_id('{node}_nid');
    $node->vid = db_next_id('{node_revisions}_vid');
    
    
    
    
    
    
    
    
    
    
    
    
// начинаем внесение данных в базу    
//-------------------------------------------------------------------------------------------------------------------------	

	
	// если это не подгруппа (для неё не создаётся ноды, а только категория)
	// подготовим остальные данные для создания простой ноды и все данные внесём в базу 
	if($zp_element['type'] != 'подгруппа')
	{
		// копируем некоторые строки из стандартной функции друпала по добавлению новой ноды
  		
		// Split off revisions data to another structure
  		$revisions_table_values = array('nid' => $node->nid, 'vid' => $node->vid,
                		    	 'title' => $node->title, 'body' => $node->body,
        		        	     'teaser' => $node->teaser, 'timestamp' => $node->changed,
                     			 'uid' => $node->uid, 'format' => $node->format);
  		$revisions_table_types = array('nid' => '%d', 'vid' => '%d',
                     			'title' => "'%s'", 'body' => "'%s'",
                     			'teaser' => "'%s'", 'timestamp' => '%d',
                     			'uid' => '%d', 'format' => '%d');

  		$revisions_table_values['log'] = $node->log;
  		$revisions_table_types['log'] = "'%s'";

  		$node_table_values = array('nid' => $node->nid, 'vid' => $node->vid,
        		            'title' => $node->title, 'type' => $node->type, 'uid' => $node->uid,
                		    'status' => $node->status, 'created' => $node->created,
                    		'changed' => $node->changed, 'comment' => $node->comment,
                    		'promote' => $node->promote, 'sticky' => $node->sticky);
  		$node_table_types = array('nid' => '%d', 'vid' => '%d',
                    		'title' => "'%s'", 'type' => "'%s'", 'uid' => '%d',
                    		'status' => '%d', 'created' => '%d',
                    		'changed' => '%d', 'comment' => '%d',
                    		'promote' => '%d', 'sticky' => '%d');

  		//Generate the node table query and the
  		//the node_revisions table query
  		$node_query = 'INSERT INTO {node} ('. implode(', ', array_keys($node_table_types)) .') VALUES ('. implode(', ', $node_table_types) .')';
  		$revisions_query = 'INSERT INTO {node_revisions} ('. implode(', ', array_keys($revisions_table_types)) .') VALUES ('. implode(', ', $revisions_table_types) .')';
  
  		
		/* *///пока закомментируем реальные действия с базой
  		
  		// Insert the node into the database:
  		db_query($node_query, $node_table_values);
  		db_query($revisions_query, $revisions_table_values);

  		// Call the node specific callback (if any):
    	//node_invoke($node, 'insert');
    	//node_invoke_nodeapi($node, 'insert');
  		// Update the node access table for this node.
		node_access_acquire_grants($node);
  		// Clear the cache so an anonymous poster can see the node being added or updated.
  		//cache_clear_all();		
  		
  		
  		
  		
  		
  		
  		
  		// внесём данные о статусе элемента для любого элемента, проме подргуппы
  		if($zp_element['статус_элемента'])
		{
			
			if(!db_query("INSERT INTO {content_field_status} (vid, nid, field_status_value) VALUES (%d, %d, '%s')", $node->vid, $node->nid, $zp_element['статус_элемента']))
			{
				$shop_item['Действие / результат'] = 'new error: ошибка при добавлении данных о статусе элемента';
				return $shop_item;
			}
		} 
  		
  		
		
	}
	

	
	
	// теперь внесём в базу следующую часть данных по элементу, в зависимости от типа элемента
	switch($zp_element['type'])
	 {
	 	case 'страна':
	 	case 'населённый пункт':
	 	case 'район':
	 	case 'магазин':
	 	case 'подотдел':
	 		
			  
	 		// zp номер местоположения, возможно, что его и не нужно сохранять - артикула достаточно
	 		// db_query("INSERT INTO {content_field_zp_localn_place} (vid, nid, field_zp_localn_place_value) VALUES (%d, %d, '%s')", $node->vid, $node->nid, $zp_element['zp_number']);	 		  
	 		// zp артикул местоположения
	 		
	 		db_query("INSERT INTO {content_field_zp_art_place} (vid, nid, field_zp_art_place_value) VALUES (%d, %d, '%s')", $node->vid, $node->nid, $zp_element['zp_artikul']);
	 		
	 		
	 		// внесём данные о типе элемента и количестве фото (а пути к фото, в отличие от товара, формируются на основе стандартных путей: countries, cities, shops...)
	 		//if($zp_element['подгруппа_или_тип_элемента'])
			  //db_query("INSERT INTO {content_field_place_type} (vid, nid, field_place_type_value) VALUES (%d, %d, '%s')", $node->vid, $node->nid, $zp_element['подгруппа_или_тип_элемента']);	 		  
			
			// вносим  подгруппа_или_тип_элемента, кол_во_картинок 
			// а также название каталога с картинками (это нужно для того, чтобы можно было использовать картинку по умолчанию из каталога с определёнными товарами для картинки отдела по умолчанию)
			
			db_query("INSERT INTO {content_field_placetype_n_numofphotos} (vid, nid, field_placetype_n_numofphotos_value) VALUES (%d, %d, '%s')", $node->vid, $node->nid, $zp_element['подгруппа_или_тип_элемента'] . ';' . $zp_element['кол_во_картинок'] . ';' . $zp_element['каталог_с_картинками']);	 		  
			  
			  
	 		// это не нужно, так как описание этих элементов содержится в node->body
			//if($zp_element['описание_элемента'])
	 		  //db_query("INSERT INTO {content_field_description} (vid, nid, field_description_value) VALUES (%d, %d, '%s')", $node->vid, $node->nid, $zp_element['описание_элемента']);
			 
	 		 if($zp_element['ключевые_слова'])
				{
					if(!db_query("INSERT INTO {content_field_keywords} (vid, nid, field_keywords_value) VALUES (%d, %d, '%s')", $node->vid, $node->nid, $zp_element['ключевые_слова']))
			  			{
							$shop_item['Действие / результат'] = 'new error: ошибка при локальном добавлении ключевых слов в тип -' . $zp_element['type'] . '-';
							return $shop_item;
			  			}
				} 
	 		   
			
	 		break;
	 		
	 		
	 		
	 	case 'товар':	 		
			$node->unique_hash = md5($node->vid . $node->nid . $node->model . $node->list_price . $node->cost . $node->sell_price . $node->weight . $node->weight_units . $node->length . $node->width . $node->height . $node->length_units . $node->pkg_qty . $node->default_qty . $node->shippable . time());
  			
			db_query("INSERT INTO {uc_products} (vid, nid, model, list_price, cost, sell_price, weight, weight_units, length, width, height, length_units, pkg_qty, default_qty, unique_hash, ordering, shippable) VALUES (%d, %d, '%s', %f, %f, %f, %f, '%s', %f, %f, %f, '%s', %d, %d, '%s', %d, %d)",
   	 				$node->vid, $node->nid, $node->model, $node->list_price, $node->cost, $node->sell_price, $node->weight, $node->weight_units, $node->length, $node->width, $node->height, $node->length_units, $node->pkg_qty, $node->default_qty, $node->unique_hash, $node->ordering, $node->shippable
 	 				);	
 	 		

 	 		
 	 		
  			// мера расфасовки при продаже
  			db_query("INSERT INTO {content_field_sell_measure} (vid, nid, field_sell_measure_value) VALUES (%d, %d, '%s')", $node->vid, $node->nid, $zp_element['продажная_единица_измерения']);	 		  
  			
  			
  			
  			
  			//show($zp_element);		
	//	show($node);
		
	//return;	
     
     //$zp_element['продажная_единица_измерения'];
  			
  			
  			
  			// пока не используем контроль количества... соответственно и не вносим эти данные
  			/*
			// внесём данные по количеству и данным по контролю количества
  			//db_query("INSERT INTO {uc_product_stock} (sku, nid, active, stock, threshold) VALUES ('%s', %d, %d, %d, %d)", $zp_element['zp_artikul'], $node->nid, $zp_element['уменьшать_количество_при_продаже'], $zp_element['количество'], $zp_element['количество_ниже_которого_не_продавать']);	 		    			
  			*/

  			
  			
  			/*
  			
  			// закоментированные данные заменены внесением данных по разным таблицам для любых типов продуктов (в других местах функции), вместо описанного здесь внесения всех данных в одну таблицу, но для отдельных типов данных
  			
  			// сформируем название поля с описанием в базе из названия типа товара
			//$type_of_product = explode('product_', $node->type); 
			//$type_of_product = $type_of_product[1];

			//db_query("INSERT INTO {content_type_product_clothes} (vid, nid, field_p_clothes_descr_value, field_zp_art_proizv_value,  field_zp_art_postav_value, field_zp_bar_postav_value, field_zp_art_shop_value, field_zp_brand_link_nid, field_zp_brand_nolink_value, field_zp_bar_shop_value, field_source_of_pics_value) VALUES (%d, %d, '%s', '%s', '%s', '%s', '%s', %d, '%s', '%s', '%s')", $node->vid, $node->nid, $zp_element['описание_элемента'], $zp_element['артикул_произв'], $zp_element['артикул_поставщ'], $zp_element['штрих_код_поставщ'], $zp_element['артикул_магазина'], '', $zp_element['название_бренда'], $zp_element['штрих_код_магазина'], $zp_element['source_of_pics']); 
			//db_query("INSERT INTO {content_type_product_" . $type_of_product . "} (vid, nid, field_p_" . $type_of_product . "_descr_value, field_zp_art_proizv_value,  field_zp_art_postav_value, field_zp_bar_postav_value, field_zp_art_shop_value, field_zp_brand_link_nid, field_zp_brand_nolink_value, field_zp_bar_shop_value, field_source_of_pics_value) VALUES (%d, %d, '%s', '%s', '%s', '%s', '%s', %d, '%s', '%s', '%s')", $node->vid, $node->nid, $zp_element['описание_элемента'], $zp_element['артикул_произв'], $zp_element['артикул_поставщ'], $zp_element['штрих_код_поставщ'], $zp_element['артикул_магазина'], '', $zp_element['название_бренда'], $zp_element['штрих_код_магазина'], $zp_element['source_of_pics']); 
			
			*/


  			// укажем название каталога с картинками; поля, на основе которого формируется название картинок (zp-артикул, штрих-коды, артикулы, название); кол-во картинок
  			// также это поле содержит ориентацию картинок (последний элемент строки через ";"). "h" говорит о горизонтальной ориентации, и при отображении картинку тизера нужно повернуть на 90 градусов
  			
  			$prodtype_pic_src_n_num_value = $zp_element['каталог_с_картинками'] . ';' . $zp_element['source_of_pics'] . ';' . $zp_element['кол_во_картинок'] . ';' . $zp_element['ориентация_картинок'];
  			 
  			
  			if(!db_query("INSERT INTO {content_field_prodtype_pic_src_n_num} (field_prodtype_pic_src_n_num_value, nid, vid) VALUES ('%s', %d, %d)", $prodtype_pic_src_n_num_value, $node->nid, $node->vid))
			  {
				$shop_item['Действие / результат'] = 'change error: ошибка при добавлении поля с данными по картинкам товара'; 
				return $shop_item;
			  }
  			
			  
			  
			  
			  
			  
			// внесём внешнее описание товаров и/или ключевые слова, если они заданы для товара и заданы необходимые дополнительные данные
			
			if($zp_element['описание_внешнее'] OR $zp_element['ключевые_слова'])
			{
				// если для товара определен междуеародный штрих-код
				if($zp_element['ш_код_международный'])
				{
					// внести внешнее описание и/или ключевые слова в таблицу с описанием по международному штрих-коду
					
					if(!db_result(db_query("SELECT p_bw from {p_descr_bw} WHERE p_bw = '%s'", $zp_element['ш_код_международный'])))
		  			{
					
						if(!db_query("INSERT INTO {p_descr_bw} (p_bw, p_name, descr, keywords) VALUES ('%s', '%s', '%s', '%s')", $zp_element['ш_код_международный'], $node->title, $zp_element['описание_внешнее'], $zp_element['ключевые_слова']))
			  			{
							$shop_item['Действие / результат'] = 'change error: ошибка при добавлении описания (и, возможно, ключевых слов товара по международному ш-коду';
							return $shop_item;
			  			}
		  			}
		  			else 
		  			{
		  				// если в базе уже содержатся данные по элементу с таким международным штрих-кодом, то новые данные не вносятся. Они должны быть внесены отдельно путём изменения элемента
		  				$shop_item['Предупреждения'] = 'new warning: в базе уже содержится описание и/или ключевые слова по международному штрих-коду. Поэтому новое внешнее описание и/или ключевые слова не были записаны. Внесите эти данные отдельно путём изменения элемента.';
		  			}
				}
				else 
				if($zp_element['zp_mc_id_производителя'] AND ($zp_element['ш_код_производителя'] OR $zp_element['артикул_производителя']) )
				{
					// значит записываем описание и-или ключевые слова под ид производителя
					if($zp_element['ш_код_производителя'])
						$p_id = $zp_element['ш_код_производителя']; 
					else 
						$p_id = $zp_element['артикул_производителя'];
						
					$seller_id = $zp_element['zp_mc_id_производителя'];
					$seller_name = $zp_element['производитель'];
					
					
					if(!db_result(db_query("SELECT num from {p_descr_mc} WHERE p_id = '%s' AND seller_id = '%s'", $p_id, $seller_id)))
		  			{
					
						if(!db_query("INSERT INTO {p_descr_mc} (p_id, p_name, seller_id, seller_name, descr, keywords) VALUES ('%s', '%s', '%s', '%s', '%s', '%s')", $p_id, $node->title, $seller_id, $seller_name, $zp_element['описание_внешнее'], $zp_element['ключевые_слова']))
			  			{
							$shop_item['Действие / результат'] = 'change error: ошибка при добавлении описания (и, возможно, ключевых слов) товара по id производителя';
							return $shop_item;
			  			}
		  			}
		  			else 
		  			{
		  				// если в базе уже содержатся данные по элементу с таким ИД у такого производителя, то новые данные не вносятся. Они должны быть внесены отдельно путём изменения элемента.
		  				// устанваливаем поле Предупреждение, но процесс внесения данных не останавливаем
		  				$shop_item['Предупреждения'] = 'new warning: в базе уже содержится описание и/или ключевые слова с таким ИД по такому ИД производителя. Поэтому новое внешнее описание и/или ключевые слова не были записаны. Внесите эти данные отдельно путём изменения элемента.';
		  			}
		  			
				}
				else 
				if($zp_element['zp_mc_id_поставщика'] AND ($zp_element['ш_код_поставщика'] OR $zp_element['артикул_поставщика']) )
				{
					// значит записываем описание и-или ключевые слова под ид поставщика
					if($zp_element['ш_код_поставщика'])
						$p_id = $zp_element['ш_код_поставщика']; 
					else 
						$p_id = $zp_element['артикул_поставщика'];
						
					$seller_id = $zp_element['zp_mc_id_поставщика'];
					$seller_name = $zp_element['поставщик'];
					
					
					if(!db_result(db_query("SELECT num from {p_descr_mc} WHERE p_id = '%s' AND seller_id = '%s'", $p_id, $seller_id)))
		  			{
						
						if(!db_query("INSERT INTO {p_descr_mc} (p_id, p_name, seller_id, seller_name, descr, keywords) VALUES ('%s', '%s', '%s', '%s', '%s', '%s')", $p_id, $node->title, $seller_id, $seller_name, $zp_element['описание_внешнее'], $zp_element['ключевые_слова']))
				  		{
							$shop_item['Действие / результат'] = 'change error: ошибка при добавлении описания (и, возможно, ключевых слов) товара по id поставщика';
							return $shop_item;
			  			}
					}
					else 
		  			{
		  				// если в базе уже содержатся данные по элементу с таким ИД у такого поставщика, то новые данные не вносятся. Они должны быть внесены отдельно путём изменения элемента.
		  				// устанваливаем поле Предупреждение, но процесс внесения данных не останавливаем
		  				$shop_item['Предупреждения'] = 'new warning: в базе уже содержится описание и/или ключевые слова с таким ИД по такому ИД поставщика. Поэтому новое внешнее описание и/или ключевые слова не были записаны. Внесите эти данные отдельно путём изменения элемента.';
		  			}
		  			
				}
				else 
				if(!$zp_element['описание_внешнее'] AND $zp_element['ключевые_слова'])
				{
					// если заданы только ключевые слова и не заданы внешние идентификаторы,
					// то записываем ключевые слова локально, в текущий объект а текущем магазине
					
					if(!db_query("INSERT INTO {content_field_keywords} (vid, nid, field_keywords_value) VALUES (%d, %d, '%s')", $node->vid, $node->nid, $zp_element['ключевые_слова']))
			  		{
						$shop_item['Действие / результат'] = 'new error: ошибка при локальном добавлении ключевых слов в товар';
						return $shop_item;
			  		}
					 
				}
				else 
				{
					// иначе задано внешнее описание (и, возможно, ключевые слова), для которого нет внешнего идентификатора 
					// (международного ш-кода или id производителя или поставщика)
					// поэтому выдаём ошибку и выходим из программы
					$shop_item['Действие / результат'] = 'new error: ошибка при добавлении внешнего описания товара - не задан внешний идентификатор (международный ш-код или ID производителя или поставщика и их ID товара)';
					return $shop_item;
				}
	
			} // end of if($zp_element['описание_внешнее'] OR $zp_element['ключевые_слова'])
			

	
 	 		break; // end of case: 'товар'

 	 		
 	 		
	 } // end of switch($zp_element['type']) // теперь внесём в базу первую часть данных по элементу, в зависимости от типа элемента
	


	 
	 
	 
	// внесём очередную порцию данных по товару: штрих-коды, артикулы, название бренда и др.
	if($zp_element['type'] == 'товар')
	{	
	  foreach ($zp_element as $key => $value)
	  {
		 switch($key)
		 {
		 	
		 	case 'ш_код_международный':
				
					if( // если артикул/код не был задан изначально, попытаться его внести
						!db_query("INSERT INTO {content_field_zp_bar_world} (field_zp_bar_world_value, nid, vid) VALUES ('%s', %d, %d)", $value, $node->nid, $node->vid)
					  )
					  {
						$shop_item['Действие / результат'] = 'change error: ошибка при добавлении поля -' . $key . '- в базе со значением ' . $value; 
						return $shop_item;
					  }
					
					 break;
					 
		 	
		 	case 'ш_код_производителя':
				
					if( // если артикул/код не был задан изначально, попытаться его внести
						!db_query("INSERT INTO {content_field_zp_bar_proizv} (field_zp_bar_proizv_value, nid, vid) VALUES ('%s', %d, %d)", $value, $node->nid, $node->vid)
					  )
					  {
						$shop_item['Действие / результат'] = 'change error: ошибка при добавлении поля -' . $key . '- в базе со значением ' . $value; 
						return $shop_item;
					  }
					
					 break;
					 
		 	
			case 'артикул_производителя':
				
					if( // если артикул/код не был задан изначально, попытаться его внести
						!db_query("INSERT INTO {content_field_zp_art_proizv} (field_zp_art_proizv_value, nid, vid) VALUES ('%s', %d, %d)", $value, $node->nid, $node->vid)
					  )
					  {
						$shop_item['Действие / результат'] = 'change error: ошибка при добавлении поля -' . $key . '- в базе со значением ' . $value; 
						return $shop_item;
					  }
				
					 break; 
				
				
	 
			case 'ш_код_поставщика':
				
					if( // если артикул/код не был задан изначально, попытаться его внести
						!db_query("INSERT INTO {content_field_zp_bar_postav} (field_zp_bar_postav_value, nid, vid) VALUES ('%s', %d, %d)", $value, $node->nid, $node->vid)
					  )
					  {
						$shop_item['Действие / результат'] = 'change error: ошибка при добавлении поля -' . $key . '- в базе со значением ' . $value; 
						return $shop_item;
					  }
				
					 break; 	
					 
					 
			case 'артикул_поставщика':
				
					if( // если артикул/код не был задан изначально, попытаться его внести
						!db_query("INSERT INTO {content_field_zp_art_postav} (field_zp_art_postav_value, nid, vid) VALUES ('%s', %d, %d)", $value, $node->nid, $node->vid)
					  )
					  {
						$shop_item['Действие / результат'] = 'change error: ошибка при добавлении поля -' . $key . '- в базе со значением ' . $value; 
						return $shop_item;
					  }
				
					 break; 		 
					 
									
			case 'ш_код_магазина':
				
					if( // если артикул/код не был задан изначально, попытаться его внести
						!db_query("INSERT INTO {content_field_zp_bar_shop} (field_zp_bar_shop_value, nid, vid) VALUES ('%s', %d, %d)", $value, $node->nid, $node->vid)
					  )
					  {
						$shop_item['Действие / результат'] = 'change error: ошибка при добавлении поля -' . $key . '- в базе со значением ' . $value; 
						return $shop_item;
					  }
				
					 break; 		
					
					 
			case 'артикул_магазина':
				
					if( // если артикул/код не был задан изначально, попытаться его внести
						!db_query("INSERT INTO {content_field_zp_art_shop} (field_zp_art_shop_value, nid, vid) VALUES ('%s', %d, %d)", $value, $node->nid, $node->vid)
					  )
					  {
						$shop_item['Действие / результат'] = 'change error: ошибка при добавлении поля -' . $key . '- в базе со значением ' . $value; 
						return $shop_item;
					  }
				
					 break;	
					
			
			case 'бренд':
				
					// пока непонятно, куда вносить данные по бренду и нужно ли это вообще
					/*
					if( // если артикул/код не был задан изначально, попытаться его внести
						!db_query("INSERT INTO {content_field_zp_brand_nolink} (field_zp_brand_nolink_value, nid, vid) VALUES ('%s', %d, %d)", $value, $node->nid, $node->vid)
					  )
					  {
						$shop_item['Действие / результат'] = 'change error: ошибка при добавлении поля -' . $key . '- в базе со значением ' . $value; 
						return $shop_item;
					  }
					  
					  */
				
					 break;
					 


				
			default:
				
					break;
			
				
		 }	// end of switch($key) 
		 
	  } // end of foreach ($zp_element as $key => $value) // // внесём данные по артикулам и брендам в товар
	 
	  
	  
	  		 	 
		if($zp_element['производитель'] OR $zp_element['zp_mc_id_производителя'])
		{
				
			// название производителя (это поле) содержится в одном поле с его ID
			// поэтому эти два поля нужно объединить и записать в базу, если хоть одно из них определено
	
			$proizv = $zp_element['zp_mc_id_производителя'] . ';' . $zp_element['производитель'];
			
			if( 
				!db_query("INSERT INTO {content_field_proizv} (field_proizv_value, nid, vid) VALUES ('%s', %d, %d)", $proizv, $node->nid, $node->vid)
			  )
			  {
				$shop_item['Действие / результат'] = 'change error: ошибка при добавлении поля c названием и ID производителя'; 
				return $shop_item;
			  }
			  
		} // end of if($zp_element['производитель'] OR $zp_element['zp_mc_id_производителя'])
		
		
		if($zp_element['поставщик'] OR $zp_element['zp_mc_id_поставщика'])
		{
				
			// название производителя (это поле) содержится в одном поле с его ID
			// поэтому эти два поля нужно объединить и записать в базу, если хоть одно из них определено
	
			$postav = $zp_element['zp_mc_id_поставщика'] . ';' . $zp_element['поставщик'];
			
			if( 
				!db_query("INSERT INTO {content_field_postav} (field_postav_value, nid, vid) VALUES ('%s', %d, %d)", $postav, $node->nid, $node->vid)
			  )
			  {
				$shop_item['Действие / результат'] = 'change error: ошибка при добавлении поля c названием и ID поставщика'; 
				return $shop_item;
			  }
			  
		} // end of if($zp_element['поставщик'] OR $zp_element['zp_mc_id_поставщика'])

	} // end of if($zp_element['type'] == 'товар') // внесём очередную порцию данных по товару: штрих-коды, артикулы, название бренда и др.
	
	 
	
	
	
	
	
	
	 
	 // внесём в базу адреса, в зависимости от типа элемента
	switch($zp_element['type'])
	 {
		case 'страна':
	 	case 'населённый пункт':
	 	case 'район':
	 	case 'магазин':
	 	case 'подотдел':
	 		
	 		// записываем адрес в общую таблицу
	    	if($zp_element['address']) 
	    		db_query("INSERT INTO {content_field_place_address} (vid, nid, field_place_address_value)"
	    											   . " VALUES (%d, %d, '%s')", 
	    											   $node->vid, $node->nid, $zp_element['адрес']);	  
	    											   
	 		break;

	 		
	 	default:
	 		break;
	  	
	 } // end of switch($zp_element['type']) // внесём в базу вторую часть данных по элементу, в зависимости от типа элемента // теперь более индивидуальные данные

	 
	 
	 /*
	 // нужно ли заполнять таблицы с типами данных?
	 switch($zp_element['type'])
	 {
	 	
	 	
	 	case 'страна':
	 		// заполняем в таблицу с данными по типу страна
	 		
	 		// не уверен, что нужно вносить данные, если из данных есть только нода и ревизия...
	    	db_query("INSERT INTO {content_type_c_country} (vid, nid) VALUES (%d, %d)", $node->vid, $node->nid);
	 		break;
	 		
	 		
	 		
	 		
	 	case 'населённый пункт':
	 		// заполняем в таблицу с данными по типу город
	 		
	 		// не уверен, что нужно вносить данные, если из данных есть только нода и ревизия...
	    	db_query("INSERT INTO {content_type_c_city} (vid, nid) VALUES (%d, %d)", $node->vid, $node->nid);
	    	
	 		break;
	 		
	 		
	 		
	 		
	 	case 'район':
	 		// вносим в таблицу с данными по типу район данные об адресе
	 		
	 		// не уверен, что нужно вносить данные, если из данных есть только нода и ревизия...
	    	db_query("INSERT INTO {content_type_c_rajon} (vid, nid) VALUES (%d, %d)", $node->vid, $node->nid);
	    	
	 		break;
	 		
	 		
	 	default:
	 		break;
	  	
	 } // end of switch($zp_element['type']) 
	 
	 */

	 
	 
	 
	 
	 
	 
	 
// окончание внесения дополнительных данных (адресов и т.д.) по разным типам элементов	 
	 
	 	 








	 
	 // внесём в базу коэффициент доставки и минимальной суммы покупки (корзины), в зависимости от типа элемента
	switch($zp_element['type'])
	 {
	 	
	 	case 'страна':
	 	case 'населённый пункт':
	 	case 'район':
	 	case 'магазин':
	 	case 'подотдел':

	    	if
	 		(
				!db_query("INSERT INTO {content_field_d_factor} (vid, nid, field_d_factor_value) VALUES (%d, %d, %f)", $node->vid, $node->nid,  $zp_element['коэффициент_доставки'])
				  OR 
				!db_query("INSERT INTO {content_field_cart_min_sum_f} (vid, nid, field_cart_min_sum_f_value) VALUES (%d, %d, %f)", $node->vid, $node->nid, $zp_element['коэффициент_минимальной_суммы_покупки_(корзины)']) 
			)
			{
				$shop_item['Действие / результат'] = 'change error: ошибка при изменении коэффициентов Доставки или Минимальной суммы покупки (корзины)'; 
				return $shop_item;
			}

	 		break;

	 		
	 	default:
	 		break;
	  	
	 } // end of switch($zp_element['type']) // внесём в базу вторую часть данных по элементу, в зависимости от типа элемента // теперь более индивидуальные данные
	 

	 
	 
	 
	 
	 
	 
	 
	 
	
	// внесём в базу данные о категории, связях и родителях элемента, в зависимости от типа элемента
	// проверка на правильность связей уже проведена выше
	// уже определены вспомогательные переменные
	// $zp_element['term_parent_exists']
	// $zp_element['parent_podgruppa_tid']
	// $zp_element['term_is_dublicate']
	// $zp_element['existing_term_tid']
	// $zp_element['parent_otdel_tid_name']
	// $zp_element['parent_otdel_tid']
	// $zp_element['parent_tid_name']
	// $zp_element['parent_tid']

	switch($zp_element['type'])
	 {
		case 'страна':
						
			$new_tid = db_next_id('{term_data}_tid');
	    	$new_tid_description = '';
    		$new_tid_voc_id = 1; // = catalog 	
   			$new_tid_weight = 0;
    				

    		//echo 'new_tid =' . $new_tid;
    		
    		// создаём терм для страны	
    		db_query("INSERT INTO {term_data} (tid, vid, name, description, weight) VALUES (%d, %d, '%s', '%s', %d)", $new_tid, $new_tid_voc_id, $node->title, $new_tid_description, $new_tid_weight);    		
    		// связываем созданный терм с его родителем. В данном случае родитель - 0 (корень каталога)
    		db_query("INSERT INTO {term_hierarchy} (tid, parent) VALUES (%d, %d)", $new_tid, 0);
    		//привязываем созданный терм к созданной ноде создаваемого элемента
    		db_query("INSERT INTO {term_node} (nid, tid) VALUES (%d, %d)", $node->nid, $new_tid);
			
			break;
	 		 
	 	case 'населённый пункт':	
	 	case 'район':
	 	case 'магазин':
	 	case 'подотдел':
	 	case 'подгруппа':
    		

    		/* 	// чтобы иметь возможность автоматически использовать существующий терм, нужно раскомментировать этот блок и задать способ, что следует делать
    			// - использовать существующий терм или же создавать новый с приставкой '_new'
    		if($zp_element['term_is_dublicate']) // если в базе уже есть у терм с таким названием у указанного родителя
    		{
    		    // если уже существует терм с таким же именем, которое мы хотим создать, 
				// есть два варианта:
				
				$dublicat_action = 'use_existing'; // используем уже существующий терм, к нему и подвязываем наш элемент
				//$dublicat_action = 'add_new'; // создаём новый терм, но с частицей '_new' в конце названия

				switch($dublicat_action)
				{
					case 'use_existing':
						// делаем соответствующую пометку в поле результата обработки элемнта
					    $shop_item['Действие / результат'] = '***Notice: Терм с названием ' . $node->title . ' уже существовал у данного родителя. Используем существующий терм';	    		
    		
    					// для любого типа , кроме подгруппы, созданный терм присваивается созданной ноде элемента
    					// просто у подгруппы нет своей ноды, поэтому и терм подгруппы существует сам по себе, пока к нему не будет подключён товар (товары)
    					if($zp_element['type'] != 'подгруппа')
    		  				db_query("INSERT INTO {term_node} (nid, tid) VALUES (%d, %d)", $node->nid, $zp_element['existing_term_tid']);
						
						break;
						
						
					case 'add_new':
						
						$new_tid = db_next_id('{term_data}_tid');
	    				$new_tid_description = '';
    					$new_tid_weight = 0;
    					$new_tid_voc_id = 1; // = catalog 	
          	
    					echo 'flag_is_dublicat =' . $flag_is_dublicat;
    					echo 'new_tid =' . $new_tid;
						
						// добавляем к имени терма '_new'
		    		    db_query("INSERT INTO {term_data} (tid, vid, name, description, weight) VALUES (%d, %d, '%s', '%s', %d)", $new_tid, $new_tid_voc_id, $node->title . '_new', $new_tid_description, $new_tid_weight);
					    
						// связываем созданный терм с его родителем
    					db_query("INSERT INTO {term_hierarchy} (tid, parent) VALUES (%d, %d)", $new_tid, $zp_element['parent_tid']);
    		
    					// для всех типов, кроме подгруппы созданный терм присваивается созданной ноде
    					// просто у подгруппы нет своей ноды, поэтому и терм подгруппы существует сам по себе, пока к нему не будет подключён товар (товары)
    					if($zp_element['type'] != 'подгруппа')
    		  				db_query("INSERT INTO {term_node} (nid, tid) VALUES (%d, %d)", $node->nid, $new_tid);
    		  				
    		  			// и делаем соответствующую пометку в поле результата обработки элемнта
					    $shop_item['Действие / результат'] = 'Notice: Терм с названием ' . $node->title . ' уже существовал у данного родителя. Создаём терм с именем с частицей _new';	    		

						break;
				} // end of switch($dublicat_action)
    		    
    		} // end of if($flag_is_dublicat) // если в базе уже есть у терм с таким названием у указанного родителя
    		else 
    		*/
    		{
    			$new_tid = db_next_id('{term_data}_tid');
	    		$new_tid_description = '';
    			$new_tid_voc_id = 1; // = catalog 	
          	
    			
    			// пункт 'Прочее' должен стоять самым последним в любом меню
    			if(mb_strtolower($node->title) == 'прочее')
    				//$new_tid_weight = 127;
    				$zp_element['вес_элемента_в_группе'] = 127;
    			//else 
    				//$new_tid_weight = 0;
    				

    				
    			
    			//echo 'flag_is_dublicat =' . $flag_is_dublicat;
    			//echo 'new_tid =' . $new_tid;
    			
    			db_query("INSERT INTO {term_data} (tid, vid, name, description, weight) VALUES (%d, %d, '%s', '%s', %d)", $new_tid, $new_tid_voc_id, $node->title, $new_tid_description, $zp_element['вес_элемента_в_группе']);    		
    			// связываем созданный терм с его родителем
    			db_query("INSERT INTO {term_hierarchy} (tid, parent) VALUES (%d, %d)", $new_tid, $zp_element['parent_tid']);
    		
    			// для всех типов, кроме подгруппы созданный терм присваивается созданной ноде
    			// просто у подгруппы нет своей ноды, поэтому и терм подгруппы существует сам по себе, пока к нему не будет подключён товар (товары)
    			if($zp_element['type'] != 'подгруппа')
    		  		db_query("INSERT INTO {term_node} (nid, tid) VALUES (%d, %d)", $node->nid, $new_tid);
    		} // end of // если в базе нет терма с таким названием у указанного родителя, какое мы хотим создать

    		break;
    		
    		
    		
    		
    		
    		
    	case 'товар':
    		
    		// если терм подгруппы найден в базе в указанном отделе, присваиваем его создаваемому товару, иначе создаём сначала терм подгруппы, и созданный присваиваем создаваемому товару
    		if($zp_element['term_parent_exists'])
    		{
    			// присваиваем найденный (или созданный) терм подгруппы создаваемому товару 
     			db_query("INSERT INTO {term_node} (nid, tid) VALUES (%d, %d)", $node->nid, $zp_element['parent_podgruppa_tid']);
    		}
		
    		break; // end of case 'товар':
    		
    	
    	default:
    		break;
	 
	 } // end of switch($zp_element['type']) // следующий шаг создания и связывания категорий элемента
	
// конец внесения данных о связывании категорий ---------------------------------------------------------







	// после внесения данных о связывании категорий
	// уточним данные по статусу элемента, который уже мог быть внесён ранее
	
	// если уже изначально при внесении в базу элементу присваивается статус hidden, 
	// и это не товар (статус товара не влияет на данные по его связыванию, видимость товара контролируется через вьюс и шаблоны типов) и не подгруппа,
	// то необходимо изменить данные о термах элемента, чтобы не показывался и пункт меню, связанный с ним 
	
	if($zp_element['статус_элемента'] AND $zp_element['статус_элемента'] == 'hidden' AND $zp_element['type'] != 'товар' AND $zp_element['type'] != 'подгруппа')
	{
			  		
		// если элемент скрывается, то должнен быть скрыт и терм, связанный с этим элементом, 
		// иначе останется видимым пункт меню, который не будет никуда вести
				  		
		// но терм скрывается для любого элемента, кроме товара, так как товар имеет терм подгруппы,
		// к которой он принадлежит, и скрытие этого терма повлечёт скрытие всей группы товаров, вместо одного этого товара
		// сам товар и так скрывается, путём не показывания его (с учётом статуса) в вьюсах и шаблоне типа товара
				
							
		// вясним номер тида из каталога, связанный с этим элементом
		$element_tids = taxonomy_node_get_terms_by_vocabulary($node->nid, 1);
		foreach($element_tids as $element_tid)
		{
			//$element_tid_name = $element_tid->name;
			$element_tid = $element_tid->tid;
		}
    						
		// изменим тид на тид+0000.... когда впоследствии для элемента будет снят статус hidden, значение этого тида надо будет восстановить
		$new_tid = $element_tid . '0000';
		db_query("UPDATE {term_data} SET tid = %d WHERE tid = %d", $new_tid, $element_tid);
							
		// привяжем к этому новому тиду текущий нид (чтобы не потерять номер тида и потом его восстановить)
		db_query("UPDATE {term_node} SET tid = %d WHERE tid = %d AND nid = %d ", $new_tid, $element_tid, $node->nid);
						
	}  // end of if($zp_element['статус_элемента'] AND $zp_element['статус_элемента'] == 'hidden' AND $zp_element['type'] != 'товар' AND $zp_element['type'] != 'подгруппа')	
				
						

	
	
	
	
	
	
	 // если заданы "другие" атрибуты товара, внесём их
	 // ранее строка с атрибутами была разобрана в переменные:
	 
     // $attributes[$count]['type'] - тип атрибута (text, select, check, radio)
	 // $attributes[$count]['name'] - имя атрибута
	 // $attributes[$count]['descr'] - описание атрибута
	 // $attributes[$count]['options'] - опции со значением суммы прибавки к цене
	 
	 // пример 'select***Цвет***Описание атрибута[Красный^^^0---Зелёный^^^3,40]text***Размер[24^^^1.20---43^^^5.21]'
	 
     if($zp_element['type'] == 'товар' AND $zp_element['другие_атрибуты_товара'])
     {
	  if($zp_element['другие_атрибуты_товара'] != 'нет')
	  {
		foreach($attributes as $attribute) // перебираем указанные в таблице атрибуты товара
		{
			// выясним тип очередного атрибута в таблице
			switch($attribute['type'])
			{
				case 'text': 
					$attribute['type'] = 0;
					break;
				
				case 'select': 
					$attribute['type'] = 1;
					break;
					
				case 'radio': 
					$attribute['type'] = 2;
					break;
				
			}
			
			// выясним, определён ли в базе такой атрибут и выясним его aid 
			if( 
				!($aid = db_result(db_query("SELECT aid from {uc_attributes} WHERE name = '%s' AND display = %d", $attribute['name'], $attribute['type'])))
	  	  	  )
	  	  	  {
	  	  	  	
	  	  	  	// если такого атрибута в базе нет, вносим его в базу
  	 			if( 
					!db_query("INSERT INTO {uc_attributes} (name, ordering, required, display, description) VALUES ('%s', %d, %d, %d, '%s')", $attribute['name'], 0, 0, $attribute['type'], $attribute['descr'])
		  		  )
		  		  {
					$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. Ошибка при добавлении в базу нового атрибута -' . $attribute['name'] . '-'; 
					return $shop_item;
		  		  }
	  	  		
	  	  	  	// выясняем aid только что внесенного атрибута
	  	  	  	if( 
					!($aid = db_result(db_query("SELECT aid from {uc_attributes} WHERE name = '%s' AND display = %d", $attribute['name'], $attribute['type'])))
		  		  )
		  		  {
					$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. Ошибка при считывании aid только что добавленного в базу нового атрибута -' . $attribute['name'] . '-'; 
					return $shop_item;
		  		  }

	   	  	  } // end of // выясним, определён ли в базе такой атрибут и выясним его aid 
	   	  	  
	   	  	
	   	  	  
	   	  	// перебирвем все опции
	   	  	// выясним, определены ли в базе опции для этого атрибута, указанные в таблице
	   	  	// и выясним их oid
	   	  	$option_count = 0;
			foreach($attribute['options'] as $option_name => $add_price)
			{
				$option_count++;
				
				// выясним, определёна ли в базе такая опция у такого атрибута и выясним его oid 
				if( 
					!($oid = db_result(db_query("SELECT oid from {uc_attribute_options} WHERE name = '%s' AND aid = %d", $option_name, $aid)))
	  	  	  	  )
	  	  	  	  {
	  	  	  	
	  	  	  		// если такой опции нет в этом атрибуте в базе, вносим её в базу
	  	  	  		// задаём нулевые цены, так как это общие данные по опциям, а для каждого товара они будут задаваться свои
  	 				if( 
						!db_query("INSERT INTO {uc_attribute_options} (aid, name, cost, price, weight, ordering) VALUES (%d, '%s', %f, %f, %d, %d)", $aid, $option_name, 0, 0, 0, 0)
		  		  	  )
		  		  	  {
						$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. Ошибка при добавлении в базу новой опции -' . $option_name . '- атрибута -' . $attribute['name'] . '-'; 
						return $shop_item;
		  		  	  }
	  	  		
	  	  	  		// выясняем oid только что внесенной опции текущего атрибута
	  	  	  		if( 
						!($oid = db_result(db_query("SELECT oid from {uc_attribute_options} WHERE aid = %d AND name = '%s'", $aid, $option_name)))
		  		  	  )
		  		  	  {
						$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. Ошибка при считывании oid только что добавленной в базу новой опции -' . $option_name . '- атрибута -' . $attribute['name'] . '-'; 
						return $shop_item;
		  		  	  }
		  		  	  

		  		   } // end of // выясним, определёна ли в базе такая опция у такого атрибута и выясним его oid 	  
		  		  	  
	   	  	
	   	  			// как только определили первую опцию текущего атрибута, вносим атрибут в базу по текущему товару
	   	  			// (единожды вносим этот атрибут)
	   	  			// вносим в базу данные об этом атрибуте для этого товара
  	 				
	   	  			if($option_count == 1)
	   	  			 if( 
						!db_query("INSERT INTO {uc_product_attributes} (nid, aid, ordering, default_option, required, display) VALUES (%d, %d, %d, %d, %d, %d)", $node->nid, $aid, 0, $oid, 0, $attribute['type'])
		  	 		   )
		  	 		   {
						 $shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. Ошибка при добавлении атрибута -' . $attribute['name'] . '- к этому товару'; 
						 return $shop_item;
		  	 		   }
		  	 		   
		  	 		// вносим в базу данные о текущей опции для этого товара
  	 				if( 
						!db_query("INSERT INTO {uc_product_options} (nid, oid, cost, price, weight, ordering) VALUES (%d, %d, %f, %f, %d, %d)", $node->nid, $oid, 0, $add_price, 0, $option_count-1) // $option_count-1 - это порядок отображения опций, как в таблице, начиная с нуля (поэтому вычитаем единицу)
		  		 	  )
		  		 	  {
					 	$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. Ошибка при добавлении опции -' . $option_name . '- атрибута -' . $attribute['name'] . '- к этому товару'; 
						return $shop_item;
		  		  	  }

	
			} // end of foreach($attribute['options'] as $option => $add_price)
		
		 } // end of foreach($attributes as $attribute) // перебираем указанные в таблице атрибуты товара
		
	   } // end of if($zp_element['другие_атрибуты_товара'] != 'нет')

     } // end of if($zp_element['type'] == 'товар' AND $zp_element['другие_атрибуты_товара']) 
       // end of // если заданы "другие" атрибуты товара, внесём их
     
	
	
	
     
     
     
	
     
     
// добавим к элементу Опцию "Ваши пожелания" со значением по умолчанию (нет),
	// если в этом поле стоит "есть" или "1"

	if($zp_element['атрибут_ваши_пожелания'] == 'есть' OR $zp_element['атрибут_ваши_пожелания'] == '1')
	{
		// атрибуты имеют только товары
		switch($zp_element['type'])
		{
			case 'товар':
				 
				// выясним aid атрибута "Ваши пожелания к товару (укажите)"
				if( 
					!($aid = db_result(db_query("SELECT aid from {uc_attributes} WHERE name = '%s'", 'Ваши пожелания к товару (укажите)')))
	  	  	  	  )
	  	  	  	  {
	  	  	  	  	
	  	  	  	  	/*
	  	  	  	  	// если такой атрибут не определён в системе, пропускаем добавление атрибута в элемент
					//$shop_item['Предупреждения'] = 'new warning: в базе не определён атрибут -Ваши пожелания к товару (укажите)-'; 
	  	  	  	  	$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. В базе не определён атрибут -Ваши пожелания к товару (укажите)-'; 
					return $shop_item;
					*/
					
					
					
					
					// если такого атрибута в базе нет, вносим его в базу
  	 				if( 
						!db_query("INSERT INTO {uc_attributes} (name, ordering, required, display, description) VALUES ('%s', %d, %d, %d, '%s')", 'Ваши пожелания к товару (укажите)', 10, 0, 0, 'Например, "Дата изготовления не позднее вчерашнего дня".') // 10 - ставим этот атрибут последним, если будут другие атрибуты
		  		 	  )
		  		  	  {
						$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. Ошибка при добавлении в базу нового атрибута -Ваши пожелания к товару (укажите)-'; 
						return $shop_item;
		  		  	  }
	  	  		
	  	  	  		// выясняем aid только что внесенного атрибута
	  	  	  		if( 
						!($aid = db_result(db_query("SELECT aid from {uc_attributes} WHERE name = '%s' AND display = %d", 'Ваши пожелания к товару (укажите)', 0))) // 0 - текстовое поле
		  		  	  )
		  		  	  {
						$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. Ошибка при считывании aid только что добавленного в базу нового атрибута -Ваши пожелания к товару (укажите)-'; 
						return $shop_item;
		  		  	  }
	   	  	      }
	   	  	      
	   	  	      
				
				// выясним номер oid для опции "Нет" атрибута "Ваши пожелания к товару (укажите)"
				if( 
					!($oid = db_result(db_query("SELECT oid from {uc_attribute_options} WHERE aid = %d AND name = '%s'", $aid, 'Нет')))
	  	  	  	  )
	  	  	  	  {
	  	  	  	  	/*
	  	  	  	  	// если такая опция не определёна в системе, пропускаем добавление атрибута в элемент
					//$shop_item['Предупреждения'] = 'new warning: в базе не определён атрибут -Ваши пожелания к товару (укажите)-'; 
	  	  	  	  	$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. В базе не определёна опция -Нет- для атрибута -Ваши пожелания к товару (укажите)-'; 
					return $shop_item;
					*/
					
					
					
					
					// если такой опции нет в этом атрибуте в базе, вносим её в базу
  	 				if( 
						!db_query("INSERT INTO {uc_attribute_options} (aid, name, cost, price, weight, ordering) VALUES (%d, '%s', %f, %f, %d, %d)", $aid, 'Нет', 0, 0, 0, 0)
		  		  	  )
		  		  	  {
						$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. Ошибка при добавлении в базу новой опции -Нет- атрибута -Ваши пожелания к товару (укажите)-'; 
						return $shop_item;
		  		  	  }
	  	  		
	  	  	  		// выясняем oid только что внесенной опции текущего атрибута
	  	  	  		if( 
						!($oid = db_result(db_query("SELECT oid from {uc_attribute_options} WHERE aid = %d AND name = '%s'", $aid, 'Нет')))
		  		  	  )
		  		  	  {
						$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. Ошибка при считывании oid только что добавленной в базу новой опции -Нет- атрибута -Ваши пожелания к товару (укажите)-'; 
						return $shop_item;
		  		  	  }
		  		  	  
		  		  	  
	   	  	      }
	   	  	      
	   	  	      
	   	  	      
	   	  	      
	   	  	    // вносим в базу данные об этом атрибуте для этого элемента
  	 			if( 
					!db_query("INSERT INTO {uc_product_attributes} (nid, aid, ordering, default_option, required, display) VALUES (%d, %d, %d, %d, %d, %d)", $node->nid, $aid, 10, $oid, 0, 0) // ordering ставим 10, чтобы Поле с пожеланиями стояло последним после любых других атрибутов
		  		  )
		  		  {
					$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. Ошибка при добавлении атрибутв -Ваши пожелания к товару (укажите)-'; 
					return $shop_item;
		  		  }
		  		  
		  		// вносим в базу данные об опции (Нет) этого атрибуте для этого элемента
  	 			if( 
					!db_query("INSERT INTO {uc_product_options} (nid, oid, cost, price, weight, ordering) VALUES (%d, %d, %f, %f, %d, %d)", $node->nid, $oid, 0, 0, 0, 0)
		  		  )
		  		  {
					$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. Ошибка при добавлении атрибутв -Ваши пожелания к товару (укажите)-'; 
					return $shop_item;
		  		  }
		  		
		  		  
		  		    
		  	default: 
				break;
				
		
		} // end of switch($zp_element['type']) // атрибуты имеют только товары
			
	} // end of if($zp_element['опция_ваши_пожелания_(нет)'] == 'есть' OR $zp_element['опция_ваши_пожелания_(нет)'] == '1')


     
	
	
	
	
	





				// после обработки данных помещаем в выходную таблицу сохранённые строки с историей, 
				// убирая маркер изменения ### с начала строки (что значит, что при следующей итерации это поле изменяться не будет)
			if(is_array($new_value_with_history))
				foreach ($new_value_with_history as $key => $value)
				{
					//echo '-key = ' . $key . ', old $shop_item[key] = ' . $shop_item[$key] . '<br>';
					// после внесения в базу, сохраняем в поле с названием полную историю изменения названия, лишь убрав из ней первые три символа ### (если они там были)
	 				// перед этим восстанвливаем первоначальный вид кавчек, если они были
					
	 				
	 				//$shop_item[$key] = zp_restore_quotes($new_value_with_history[$key]); // восстанавливаем полное значение поля, если оно имело историю (убирая признак изменения элемента, если он стоял вначале строки.... остальные разделители версий и сами версии названия остаются)
	 				
	 				$shop_item[$key] = zp_restore_quotes($value); // восстанавливаем полное значение поля, если оно имело историю (убирая признак изменения элемента, если он стоял вначале строки.... остальные разделители версий и сами версии названия остаются)
	 				
	 				//echo '+key = ' . $key . ', new $shop_item[key] = ' . $shop_item[$key] . '<br>';
				}	   
					  	    
    



    
	return $shop_item;	
	
} // конец функции zp_item_new($shop_item) ----------------------------------------------------------------------------------------------------------- 	 






// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// функция добавления нового производителя или поставщика

function zp_item_new_mc($shop_item)
{
	global $user;
	
	// сбрасываем флаг необходимости добавления элемента в базу	
	// в дальнейшем сюда могут добавляться какие-то комментарии
	$shop_item['Действие / результат'] = '';
	
	


					
			    // Проверим, задано ли название элемента
			    
					    
		    	$value = zp_correct_quotes($shop_item['Название']);
			    	
				if(!$value OR $value == '' OR $value == ' ')	    
				{
					$shop_item['Действие / результат'] = 'new error: не задано название элемента' ; // сбрасываем флаг необходимости добавления элемента в базу	
						return $shop_item;
				}
				
				
				// теперь можно создатиь новый объект типа нода, в который будем заносить некоторые необходимые данные по элементу
				$node = new stdClass();
				// и вспомогательный объект $zp_element для прочих данных по элементу
				$zp_element = array();
				
			    // если в значении этого поля (позже таким образом будут проверяться и остальные поля) первые три символа в поле равны '###', 
			    // значит поле может содержать несколько версий и историю изменений... 
			    // уберём эти символы и используем только первое за этими символами значение (остальные отбрасываем)
			    
			    // также эти три сомвола могут содержаться внутри строки - это несколько версий (история изменения) значения этого поля
			    // тогда берём только первую (от начала строки) версию и считаем её текущей
			    
			    // после внесения в базу, сохраняем в поле с названием полную историю изменения значения этого поля, лишь убрав из ней первые три символа ### (если они там были)
			    
		 		
			    $new_value_with_history = FALSE;
				if($value[0] . $value[1] . $value[2] == '###') // управляющие символы в начале строки
		 		{
					$value = explode('###', $value);
		   	
					foreach($value as $key => $val)
					{
						if($key == 0 OR $key == 1)
		      	 		  $new_value_with_history = $new_value_with_history . $val;
		    			else  
		      	 		  $new_value_with_history = $new_value_with_history . '###' . $val;  
					} 
			
					$value = $value[1];
		 		}
		 		else if(strpos($value, '###') !== FALSE) // управляющие символы в середине строки
		 		{
		 			$value = explode('###', $value);
		   	
					foreach($value as $key => $val)
					{
						if($key == 0)
		      	 		  $new_value_with_history = $new_value_with_history . $val;
		    			else  
		      	 		  $new_value_with_history = $new_value_with_history . '###' . $val;  
					} 
			
					$value = $value[0];
		 		}
				
		 		$node->title = $value; // присваиваем значение поля (или последнюю версию из этого поля) рабочей переменной
			
				

		 			
		 			
		 			
		 			
		 			

			    // Проверим, задан внутренний артикул zp mc		
		 			
				$value = zp_correct_quotes($shop_item['Внутренний артикул ZP MC']);
			    	
				if(!$value OR $value == '' OR $value == ' ')	    
				{
					$shop_item['Действие / результат'] = 'new error: не задан внутренний артикул ZP MC' ; // сбрасываем флаг необходимости добавления элемента в базу	
						return $shop_item;
				}
						 			

				$new_value_with_history = FALSE;
				if($value[0] . $value[1] . $value[2] == '###') // управляющие символы в начале строки
		 		{
					$value = explode('###', $value);
		   	
					foreach($value as $key => $val)
					{
						if($key == 0 OR $key == 1)
		      	 		  $new_value_with_history = $new_value_with_history . $val;
		    			else  
		      	 		  $new_value_with_history = $new_value_with_history . '###' . $val;  
					} 
			
					$value = $value[1];
		 		}
		 		else if(strpos($value, '###') !== FALSE) // управляющие символы в середине строки
		 		{
		 			$value = explode('###', $value);
		   	
					foreach($value as $key => $val)
					{
						if($key == 0)
		      	 		  $new_value_with_history = $new_value_with_history . $val;
		    			else  
		      	 		  $new_value_with_history = $new_value_with_history . '###' . $val;  
					} 
			
					$value = $value[0];
		 		}
				
		 		$zp_element['артикул_zp_mc'] = $value; // присваиваем значение поля (или последнюю версию из этого поля) рабочей переменной
			
				
				// после внесения в базу, сохраняем в поле с названием полную историю изменения названия, лишь убрав из ней первые три символа ### (если они там были)
				if($new_value_with_history)
		 			$shop_item['Внутренний артикул ZP MC'] = $new_value_with_history; // восстанавливаем полное значение поля, если оно имело историю (убирая признак изменения элемента, если он стоял вначале строки.... остальные разделители версий и сами версии названия остаются)
					
		
				
				
				

				
				// Проверим, не присутствует ли уже в базе контрагент с внутренним артикулом таким же, как у этого (создаваемого) элемента	

 
	  			$existing_nid_with_such_zp_artikul = db_result(db_query("SELECT nid FROM {content_type_mc_descr} WHERE field_zp_mc_artikul_value = '%s'", $zp_element['артикул_zp_mc']));
	  
	  			if($existing_nid_with_such_zp_artikul)
	  			{
	    			$exisiting_name = db_result(db_query("SELECT title  from {node} WHERE nid = %d", $existing_nid_with_such_zp_artikul));
	  				$shop_item['Действие / результат'] = 'new error: в базе уже присутствует контрагент с артикулом ' . $zp_element['артикул_zp_mc'] . ' и называется ' . $exisiting_name; 
	    
	  				//echo 'new error: в базе уже присутствует элемента с артикулом ' . $shop_item['zp_mc_artikul'] . ' и называется ' . $exisiting_name; 
	  	
	  				return $shop_item;
	  			}

	
				
				
				
	
	
	
	
	
	
	
	
	
	
	// установим все поля по умолчанию, касающиеся стандартного элемента
    
	$node->nid = db_next_id('{node}_nid');
    $node->vid = db_next_id('{node_revisions}_vid');
    
    $node->uid = $user->uid;
    	
    $node->created = time();
    $node->changed = time();
    	
    $node->status = 1;
    $node->comment = 0;
    $node->promote = 0;
    $node->moderate = 0;
    $node->sticky = 0;
    $node->log = ''; // комментарий к созданной ноде, его тоже можно через таблицу внести
    $node->body = ''; // по умолчанию, это поле используется для внутреннего описания товара в магазине или для описания отдела, магазина, района, города, страны...
    $node->teaser = ''; // по умолчанию, эти стандартные поля мы не используем, а вместо них используем специально заданные поля
    $node->format = 1; // надо выяснить, что это за параметр (указывается в таблице node_revisions)
    
    
    $node->type = 'mc_descr'; // тип материала - производитель или поставщик (manufactorer, caterer)	
    	
	 	
    $zp_element['кол_во_картинок'] = 2;
    $zp_element['ориентация_картинок'] = ''; // ориентация может быть вертикальная ("" или "v") или горизонтальная ("h"). При горизонтальной картинка тизера должна быть развёрнута на 90 градусов
	$zp_element['статус_элемента'] = 1; // normal
    
    
    
	
    // перебираем все поля элемента и задаём некоторые исходные данные
	foreach ($shop_item as $field => $value)
	{
		//echo '1`````````````field = ' . $field . ', value = ' . $value . '<br>';
		
		// уберём в полученной строке дубликаты кавычек и кавычки по краям
		$value = zp_correct_quotes($value);

		// если первые три символа в поле '###', значит поле может содержать несколько версий и историю изменений... уберём эти символы и используем только первое за этими символами значение (остальные отбрасываем)
		$new_value_with_history = FALSE;
		if($value[0] . $value[1] . $value[2] == '###')
		 {
			$value = explode('###', $value);
		   	
			foreach($value as $key => $val)
			{
				if($key == 0 OR $key == 1)
		      	 $new_value_with_history[$field] = $new_value_with_history[$field] . $val;
		    	else  
		      	 $new_value_with_history[$field] = $new_value_with_history[$field] . '###' . $val;  
			} 
			
			$value = $value[1];
		 }
		 else if(strpos($value, '###') !== FALSE)
		 {
		 	$value = explode('###', $value);
		   	
			foreach($value as $key => $val)
			{
				if($key == 0)
		      	 $new_value_with_history[$field] = $new_value_with_history[$field] . $val;
		    	else  
		      	 $new_value_with_history[$field] = $new_value_with_history[$field] . '###' . $val;  
			} 
			
			$value = $value[0];
		 	
		 }
	
		
		// зададим необходимые значения для элемента в зависимости от значения его конкретных (ещё не внесённых ранее в этой функции) полей
		switch ($field)
		{

			case 'Тип записи': // тип контрагента - производитель, поставщик...
				if($value AND trim($value) != '') // менять только в том случае, если в поле что-то задано
					$zp_element['тип_контрагента'] = $value;
				break;
			
			
			case 'Описание':
				if($value AND trim($value) != '') // менять только в том случае, если в поле что-то задано
				{
					$zp_element['описание'] = $value;
					$node->body = $value;
				}
				break;
				
				

			case 'Фирменное название (основной бренд)':
				if($value AND trim($value) != '') // менять только в том случае, если в поле что-то задано
					$zp_element['основной_бренд'] = $value;
				break;	
						
	
			case 'Бренды (производимые, поставляемые)':
				if($value AND trim($value) != '') // менять только в том случае, если в поле что-то задано
					$zp_element['бренды_контрагента'] = $value;
				break;	

			case 'Тип(ы) товара':
				if($value AND trim($value) != '') // менять только в том случае, если в поле что-то задано
					$zp_element['типы_товара'] = $value;
				break;	

			case 'Дополнительная информация':
				if($value AND trim($value) != '') // менять только в том случае, если в поле что-то задано
					$zp_element['доп_информация'] = $value;
				break;
				
		
			case 'Страна':
				if($value AND trim($value) != '') // если в этом поле не пусто, то используем значение поля, иначе остаётся знаение по умолчанию "нет"
					$zp_element['страна'] = $value;
				break;			

			case 'Город, местоположение':
				if($value AND trim($value) != '') // если в этом поле не пусто, то используем значение поля, иначе остаётся знаение по умолчанию "нет"
					$zp_element['город_местоположение'] = $value;
				break;					
							
					
			case 'Адрес':
				if($value AND trim($value) != '') // если в этом поле не пусто, то используем значение поля, иначе остаётся знаение по умолчанию "нет"
					$zp_element['адрес'] = $value;
				break;	

				
			case 'Ответственные лица, контакты':
				if($value AND trim($value) != '') // если в этом поле не пусто, то используем значение поля, иначе остаётся знаение по умолчанию "нет"
					$zp_element['контакты'] = $value;
				break;	

			case 'Кол-во картинок':
				if($value AND trim($value) != '') // менять только в том случае, если в поле что-то задано
					$zp_element['кол_во_картинок'] = $value;
				break;	

				
			case 'Ориентация картинок':
				if($value AND trim($value) != '') // менять только в том случае, если в поле что-то задано
					$zp_element['ориентация_картинок'] = $value;
				break;	
									
				
			case 'Статус элемента':
				if($value AND trim($value) != '') 
					$zp_element['статус_элемента'] = $value;
					
				break;

				
	

			default:
				break;
			
		} // end of // зададим необходимые значения для элемента в зависимости от значения его конкретных полей

	} // end of foreach ($shop_item as $field => $value) // перебираем все поля элемента
	


     
	
	

    
    
    
	// начинаем внесение данных в базу    
	//-------------------------------------------------------------------------------------------------------------------------	

	
	// подготовим остальные данные для создания простой ноды и все данные внесём в базу 

	// копируем некоторые строки из стандартной функции друпала по добавлению новой ноды
  		
	// Split off revisions data to another structure
  	$revisions_table_values = array('nid' => $node->nid, 'vid' => $node->vid,
                		    	 'title' => $node->title, 'body' => $node->body,
        		        	     'teaser' => $node->teaser, 'timestamp' => $node->changed,
                     			 'uid' => $node->uid, 'format' => $node->format);
  	$revisions_table_types = array('nid' => '%d', 'vid' => '%d',
                     			'title' => "'%s'", 'body' => "'%s'",
                     			'teaser' => "'%s'", 'timestamp' => '%d',
                     			'uid' => '%d', 'format' => '%d');

  	$revisions_table_values['log'] = $node->log;
  	$revisions_table_types['log'] = "'%s'";

  	$node_table_values = array('nid' => $node->nid, 'vid' => $node->vid,
        		            'title' => $node->title, 'type' => $node->type, 'uid' => $node->uid,
                		    'status' => $node->status, 'created' => $node->created,
                    		'changed' => $node->changed, 'comment' => $node->comment,
                    		'promote' => $node->promote, 'sticky' => $node->sticky);
  	$node_table_types = array('nid' => '%d', 'vid' => '%d',
                    		'title' => "'%s'", 'type' => "'%s'", 'uid' => '%d',
                    		'status' => '%d', 'created' => '%d',
                    		'changed' => '%d', 'comment' => '%d',
                    		'promote' => '%d', 'sticky' => '%d');

  	//Generate the node table query and the
  	//the node_revisions table query
  	$node_query = 'INSERT INTO {node} ('. implode(', ', array_keys($node_table_types)) .') VALUES ('. implode(', ', $node_table_types) .')';
  	$revisions_query = 'INSERT INTO {node_revisions} ('. implode(', ', array_keys($revisions_table_types)) .') VALUES ('. implode(', ', $revisions_table_types) .')';
  
  		
	/* *///пока закомментируем реальные действия с базой
  		
  	// Insert the node into the database:
  	db_query($node_query, $node_table_values);
  	db_query($revisions_query, $revisions_table_values);

  	// Call the node specific callback (if any):
    //node_invoke($node, 'insert');
    //node_invoke_nodeapi($node, 'insert');
  	// Update the node access table for this node.
	node_access_acquire_grants($node);
  	// Clear the cache so an anonymous poster can see the node being added or updated.
  	//cache_clear_all();		
  		
  		
	  

	 
	/*
		// заполняем в таблицу с данными по типу страна
			
		// не уверен, что нужно вносить данные, если из данных есть только нода и ревизия...
	   	db_query("INSERT INTO {content_type_c_country} (vid, nid) VALUES (%d, %d)", $node->vid, $node->nid);
		break;
 	*/

	 
	if(!db_query("INSERT INTO {content_type_mc_descr} (vid, nid, field_zp_mc_artikul_value, field_kontragent_type_value, field_brand_names_value, field_mc_addresses_value, field_types_of_products_value, field_add_info_value, field_contacts_value, field_mc_country_value, field_mc_place_value, field_pics_info_value, field_mc_status_value) VALUES (%d, %d, '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s')", 
				$node->vid, $node->nid, $zp_element['артикул_zp_mc'], $zp_element['тип_контрагента'], $zp_element['основной_бренд'] . ';' . $zp_element['бренды_контрагента'], $zp_element['адрес'], $zp_element['типы_товара'], $zp_element['доп_информация'], $zp_element['контакты'], $zp_element['страна'], $zp_element['город_местоположение'], $zp_element['кол_во_картинок'] . ';' . $zp_element['ориентация_картинок'], $zp_element['статус_элемента']))
	{
		$shop_item['Действие / результат'] = 'new error: ошибка при добавлении данных по новому контрагенту в общую таблицу по типу данных!'; 
		return $shop_item;
	}
			  

	
	
	


	// после обработки данных помещаем в выходную таблицу сохранённые строки с историей, 
	// убирая маркер изменения ### с начала строки (что значит, что при следующей итерации это поле изменяться не будет)
	if(is_array($new_value_with_history))
		foreach ($new_value_with_history as $key => $value)
		{
			// после внесения в базу, сохраняем в поле с названием полную историю изменения названия, лишь убрав из ней первые три символа ### (если они там были)
			// перед этим восстанвливаем первоначальный вид кавчек, если они были
					
			$shop_item[$key] = zp_restore_quotes($value); // восстанавливаем полное значение поля, если оно имело историю (убирая признак изменения элемента, если он стоял вначале строки.... остальные разделители версий и сами версии названия остаются)
		}	   
					  	    
    



    
	return $shop_item;	
	
} // конец функции zp_item_new($shop_item) ----------------------------------------------------------------------------------------------------------- 	 





















// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// запись результатов в файлы обработанных данных и отметки заданий----------------------

function zp_write_results($zp_catalog_processed,
						  $fields, 
	                      $zp_input_data, 
                          $zp_input_data_commented, 
                          $start_num_string,
                          $stop_num_string, 
                          $real_stop_num_string)
{                    
  
    global $zp_server_directory;
	global $zp_preprocess_data;
	    
	//echo '<br>zp_catalog_processed: <br>';
	//print '<PRE>';
	//print_r($zp_catalog_processed);
	//print '</PRE>';
	
	
   //echo 'processed_catalog_filename = ' . $zp_preprocess_data['processed_catalog_filename'] . '<br>';
  
// записать результаты в файлы обработанных данных и отметки заданий----------------------
// -------------------------------------------------------------------------------------   

   
  // если в файле отчёта не были найдены предыдущие результаты вычислений по текущему обрабатываемому файлу, 
  // создадим новый файл для обработанных данных (копия каталога, но с очищенными от инструкций к действиям (изменить, добавить и т.д.) полями)
  // естественно, это же название поместим и в файл отчёта (в формате "<исходный файл>  <диапазон обработанных строк>  <выходной файл, очищенный от инструкций>")
  $flag_new_processed_file = 0;
  if(!$zp_preprocess_data['processed_catalog_filename'])
   {

    	$processed_catalog_filename = explode('---', $zp_input_data['catalog_filename']);
    	$zp_preprocess_data['processed_catalog_filename'] = $processed_catalog_filename[0] . date("---d-m-y--H-i");// . '_out.csv';
    	$flag_new_processed_file = 1; // указываем, что выходные данные будут записываться впервые, в новый файл... следовательно, нужно будет записать в файл все данные до табличных и затем название полей
   }
   else 
   {
   	$processed_catalog_filename = explode('_out', $zp_preprocess_data['processed_catalog_filename']);   	
   	$zp_preprocess_data['processed_catalog_filename'] = $processed_catalog_filename[0];
   }   
   
//echo 'new processed_catalog_filename = ' . $zp_preprocess_data['processed_catalog_filename'] . '<br>';

  //foreach ($zp_catalog[1] as $key => $value)
   //echo $key . '=>' . $value . '<br>';
   
  //foreach ($fields as $key => $value)
   //echo $key . '=>' . $value . '<br>';
  
   
   //$zp_server_directory = 'http://www.zapokupkami.com/zp_import/';
   //$zp_server_directory = 'D:\\WebServers\\home\\zapokupkami.com\\www\\zp_import\\';

   //echo 'processed_catalog_filename = ' . $zp_preprocess_data['processed_catalog_filename'] . '<br>';
   //echo 'zp_server_directory = ' . $zp_server_directory . '<br>';
   
   // to test only
   $file = $zp_server_directory . $zp_preprocess_data['processed_catalog_filename'] . '_out.csv' . '<br>';
   //echo 'file = ' . $file;
      
   if (!($fp = fopen($zp_server_directory . $zp_preprocess_data['processed_catalog_filename'] . '_out.csv', 'a+'))) 
     {
        echo 'Ошибка записи в выходной файл каталога';
        return;
     }
     else 
     {	
     	// если обработанные данные выводядся в новый файл (впервые) выводим данные, предшествующие табличным, и название полей
     	if($flag_new_processed_file)
     	{
     	  fwrite($fp, $zp_preprocess_data['processed_catalog_filename'] . '.csv
');	
     	  // пропускаем пару строк
     	  fwrite($fp, '


');
     	
     	  // внесём все данные, предшествующие табличным	
     	  foreach($zp_input_data as $key => $value)
           {
     		
     	     fwrite($fp, '>' . utf8_to_cp1251($key) . '>' . utf8_to_cp1251($value) . '
');	
     	   }
     	  
     	    
     	  // пропускаем пару строк 
     	  fwrite($fp, '


');
     	  
     	  // внесём все закоментированные данные, предшествующие табличным	
     	  foreach($zp_input_data_commented as $value)
           {
     		
     		fwrite($fp, utf8_to_cp1251($value) . '
');	
     	   }

     	   
     	   // пропускаем пару строк
     	  fwrite($fp, '


');
     	  
     	  fwrite($fp, '>>>
');
     	  // выведем название полей	
     	  $string = implode(';', $fields);
     	  $string = utf8_to_cp1251($string);
     	  fwrite($fp, $string . '
');
		
     	}
     	
     	// выводим в файл все табличные данные построчно
     	$flag_errors = 0;
     	
     	foreach ($zp_catalog_processed as $string){
         //echo $key . '=>' . $value . '<br>';
         //print implode(';', $string);
     	 
     	 //fwrite($fp, iconv("UTF-8", "cp1251" ,implode(';', $string)) . '
     	 //fwrite($fp, iconv("UTF-8", "WINDOWS", implode(';', $string)) . '
     	 //fwrite($fp, utf8_win(implode(';', $string)) . '

     	 // если поле 'Действие / результат' не пустое
     	 // не записываем эту строку (этот элемент) в базу
     	 // таким образом, в выходной файл попадут только успешные данные,
     	 
     	 // Таким образом, после исправления, можно будет проганять то же задание второй раз
     	 // при этом уже введённые данные покажут ошибку (уже введено, исправлено и т.д.)
     	 // и будут пропущены, а исправленные с учётом предыдущих ошибок будут теперь правильно обработаны и введены в базу 
     	 // и, соответственно, записаны в результирующий выходной файл
     	 
     	 if($string['Действие / результат'] != '' AND $string['Действие / результат'] != '' AND $string['Действие / результат'] != '>>')
     	 {
			if(!$flag_errors) // если это первая запись в файл ошибок, создаём пустой файл и добавляем в него название полей
			{
     	 		if (!($fp_errors = fopen($zp_server_directory . $zp_preprocess_data['processed_catalog_filename'] . '_out_errors.csv', 'w'))) 
     			{
        			echo 'Ошибка записи в выходной файл c каталога с пояснением ошибок';
        			return;
     			}
     			else 
     			{
     				// выведем название полей	
   			  	  	$fields = implode(';', $fields);
     	  			$fields = utf8_to_cp1251($fields);
     	  			fwrite($fp_errors, $fields . '
');
     	 			fclose($fp_errors);
     	 			
     	 			$zp_preprocess_data['processed_catalog_filename_errors'] = $zp_preprocess_data['processed_catalog_filename'] . '_out_errors.csv';
     			}
			}	
     	 	
   	  	 	
     	 	
     	 	$flag_errors = 1;
			
			if (!($fp_errors = fopen($zp_server_directory . $zp_preprocess_data['processed_catalog_filename'] . '_out_errors.csv', 'a+'))) 
     		{
        		echo 'Ошибка записи в выходной файл c каталога с пояснением ошибок';
        		return;
     		}
     		else 
     		{
     			$string = implode(';', $string);
     	 		$string = utf8_to_cp1251($string);
     	 		fwrite($fp_errors, $string . '
');		
     	 		fclose($fp_errors);
     		}
     	 
     		
     		
     	 	continue;
     	 }
     	
     	
     	 
     	 $string = implode(';', $string);
     	 $string = utf8_to_cp1251($string);
     	 fwrite($fp, $string . '
');
     	}
     	
     	
        fclose($fp);
     }
  
        
// Теперь сделаем запись в файл отчёта выполнения задач 
// для того, чтобы в следующий раз уже не выполнять данную задачу
// -------------------------------------------------------------------
//---------------------------------------------------------------------------
    
   if(!$flag_errors) // если не было ошибок при вводе, записываем строку о выполнении задания в файл отчёта
   {				 // иначе не записываем. Таким образом, задание при следующем прогоне будет выполняться ещё раз 
   					 // (естественно, пользователь должен будет предварительно исправить указанные программой ошибки в исходном файле)
    
   	 if($fp = fopen($zp_server_directory . '---' . $zp_input_data['shop_filename_clear_for_schedule'] . '---schedule_report.csv', 'a')) 
     {
        

        // количество обработанных строк может отличаться от указанного в задании (может быть меньше, если строк реально меньше)
        // поэтому корректируем реальную цифру конечного номера строки и записываем реальный диапазон последним значением строки отчёта... Возможно, его можно будет в будущем как-то использовать
   
      	$schedule_report_current = date("d.m.y,H:i:s") . ' ' . $zp_input_data['catalog_filename'] . ' ' .  $start_num_string . '-' . $stop_num_string . ' ' . $zp_preprocess_data['processed_catalog_filename'] . '_out.csv' . ' ' . $start_num_string . '-' . $real_stop_num_string . '
';     	
     	
//      $schedule_report_current = date("d.m.y,H:i:s") . ' ' . $zp_input_data['catalog_filename'] . ' ' .  $start_num_string . '-' . $stop_num_string . ' ' . $zp_preprocess_data['processed_catalog_filename'] . '
//';
    	fwrite($fp, $schedule_report_current);
        fclose($fp);
     }  
     else
     {
    	echo 'error opening file';  	
     }
   }

}



















// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// загрузка данных из файлов ------------------------------------------------------------

function zp_load_data_from_files()
{
	
	global $fields;
	global $reported_tasks;
	global $scheduled_tasks; 
	global $zp_input_data;
	global $zp_input_data_commented;
	global $zp_catalog; 
	global $zp_catalog_processed;
	global $zp_preprocess_data;	
	global $zp_server_directory;


  //echo 'filename from dialog =  ' .  $form_values['csvfile'] .'<br>';
  
///home/rasmus/file.gif
  //if (!$fp = fopen($file_name, 'r')) {
  //if (!$fp = fopen(realpath('/zp_import/') . '---zp_shop_input_data.csv', 'a')) {
  //if (!$fp = fopen('home/zapokupkami.com/www/zp_import/' . '---zp_shop_input_data.csv', 'a')) {
  //if (!$fp = fopen(realpath('/zp_import') . '---zp_shop_input_data.csv', 'r')) {
  if (!$fp = fopen($zp_server_directory . $zp_preprocess_data['zp_shop_input_data'], 'r')) {
  	return 'Ошибка открытия файла ' . $zp_preprocess_data['zp_shop_input_data'];
  }

  //если первая строка не название файла (списка), закончить
  $buffer = trim(fgets($fp));
  //echo 'buffer =  ' .  $buffer .'<br>';
  
  
  $buffer = strpos($zp_preprocess_data['zp_shop_input_data'], $buffer);
  if($buffer === false) 
  {
  	return 'Неверный формат файла - первая строка не имя файла в файле ' . $zp_preprocess_data['zp_shop_input_data'];
  } 
  
  while(($buffer = trim(fgets($fp))) != '>>' AND !feof($fp))
  {
    if(!$buffer OR $buffer =='')
     continue;
    
    $buffer = explode('>', $buffer);
    $zp_input_data[$buffer[1]] = $buffer[2];
  }
  
  if(!$zp_input_data['shop_filename_clear_for_schedule'])
   {
   	 return 'Неверный формат файла расписания - не определён магазин для обработки';
   }
   else 
   {
   	//$file_date_time = explode('.', $zp_input_data['shop']);
   	//$file_date_time = explode('---', $file_date_time[0]);
   	//$zp_input_data['shop'] = $file_date_time[0];
   	//$file_date_time = explode('--', $file_date_time[1]);
   	
   	//$zp_input_data['file-data'] = $file_date_time[0];
   	//$zp_input_data['file-time'] = $file_date_time[1];
   }
  
   fclose($fp);



//---------------- считываем список задач из файла с расписанием
  

  //$file_name = '---' . $zp_input_data['shop_filename_clear_for_schedule'] . '---schedule.csv';
  $zp_preprocess_data['zp_schedule_file'] = '---' . $zp_input_data['shop_filename_clear_for_schedule'] . '---schedule.csv';
  //if (!$fp = fopen($file_name, 'r')) {
  if (!$fp = fopen($zp_server_directory . $zp_preprocess_data['zp_schedule_file'], 'r')) 
  {
   return 'Ошибка открытия файла ' . $zp_preprocess_data['zp_schedule_file'];
  }

  $zp_input_data['catalog_filename'] = trim(fgets($fp));
  
  
  //echo 'catalog_filename =  ' .  $zp_input_data['catalog_filename'] .'<br>';

  
  
  
  
  
  
  //если первая строка не название файла (нет в строке расширения csv), закончить
  $buffer = strpos($zp_input_data['catalog_filename'], 'csv');
   if($buffer === false) 
   {
     return 'Неверный формат файла ' . $zp_input_data['catalog_filename'] . ' (первая строка не имя файла)';
   } 
   
   
  //если вторая строка не специальный символ >, закончить
  $buffer = trim(fgets($fp));
  if($buffer != '>') 
  {
    return 'Неверный формат файла ' . $zp_input_data['catalog_filename'];
  } 
 

  //внести все запланированные задачи из файла (ограничитель >>)
  for ($i = 0; (($buffer = trim(fgets($fp))) != '>>'); $i++)  
  {
    if(($buffer[0] == '/' AND $buffer[1] == '/') OR $buffer == '' OR $buffer == ' ') // если закомментировано, пропускаем строку
     continue;
     
    
    // если строка содержит указание о порядке обработки строк - inverse говорит об обратном порядке обработки (с конца в начало)
    $inverse = explode(' ', $buffer);
    if($inverse[1] == 'inverse')
    {
		$buffer = $inverse[0];
    	$inverses[$i] = 'inverse';
    }
    
    $scheduled_tasks[$i] = $buffer;
    
    //echo 'scheduled tasks =  ' .  $scheduled_tasks[$i] .'<br>';
  }
 
  $zp_preprocess_data['scheduled_tasks'] = $scheduled_tasks;
  
  
  fclose($fp);
  
//----------конец загрузки списка задач 





 // заполнение списка с реализованными задачами
  
  //$file_name = '---' . $zp_input_data['shop_filename_clear_for_schedule'] . '---schedule_report.csv';
  $zp_preprocess_data['zp_schedule_report'] = '---' . $zp_input_data['shop_filename_clear_for_schedule'] . '---schedule_report.csv';
  
  if (!$fp = fopen($zp_server_directory . $zp_preprocess_data['zp_schedule_report'], 'r')) 
  {
    return 'Ошибка открытия файла ' . $zp_preprocess_data['zp_schedule_report'];
  }  
  
  
  
  for ($i = 0; !feof($fp) AND (($buffer = trim(fgets($fp))) != '>>'); $i++)  
  {
    if(($buffer[0] == '/' AND $buffer[1] == '/') OR $buffer == '' OR $buffer == ' ') // если строка в файле закомментирована, пропускаем её
     continue;
     
    $reported_tasks[$i] = $buffer;
    
      //echo 'reported tasks =  ' .  $reported_tasks[$i] .'<br>';
  
  }  

  $zp_preprocess_data['reported_tasks'] = $reported_tasks;
  
  $reported_tasks_amount = $i;
    
    fclose($fp);

  // конец заполнения списка с реализованными задачами


  // если последняя отправка произошла менее, 
  // чем заданный минимальный интервал $post_time_interval,
  // заканчиваем выполнение программы
  // иначе продолжаем
 
 
  $last_time_reported = explode(" ", $reported_tasks[$reported_tasks_amount-2]);
  $last_time_reported = $last_time_reported[0];
  $last_time_reported = explode(",", $last_time_reported);
  $last_date_reported = explode(".", $last_time_reported[0]);
  $last_time_reported = $last_time_reported[1];
  $last_time_reported = explode(":", $last_time_reported);
  // сколько секунд прошло с начала дня указанной даты, когда было выполнено задание?
  $last_time_reported = $last_time_reported[0]*60*60 + $last_time_reported[1]*60 + $last_time_reported[2];
  
  $current_time = date("d.m.y,H:i:s");
  $current_time = explode(",", $current_time);
  $current_date = explode(".", $current_time[0]);
  $current_time = $current_time[1];
  $current_time = explode(":", $current_time);
  // сколько секунд прошло с начала сегодняшнего дня до текущего момента?
  $current_time = $current_time[0]*60*60 + $current_time[1]*60 + $current_time[2];

  if($current_date[2] < $last_date_reported[2])
  {
  	return 'В файле расписания: текущий год меньше, чем год выполнения прошлой задачи... Такого вообще не может быть!';
  }
   
  if($current_date[1] < $last_date_reported[1] AND $current_date[2] == $last_date_reported[2])
  {
  	return 'В файле расписания: текущий месяц меньше, чем месяц выполнения прошлой задачи при одинаковом годе... Такого вообще не может быть!';
  }
  
  if($current_date[0] < $last_date_reported[0] AND $current_date[1] == $last_date_reported[1] AND $current_date[2] == $last_date_reported[2])
  {
  	return 'В файле расписания: текущее число меньше, чем число выполнения прошлой задачи при одинаковом месяце и годе... Такого вообще не может быть!';
  }
  
  // теперь остались варианты только такого же числа, месяца, года или больше сегодня, чем дата прошлой отправки

/*  
  // если даты совпадают, проверяем условия соответствия времени
  // если условия по датам не совпадают (текущее число, месяц или год больше даты прошлой расссылки), то значит время проверять время не нужно - оно в любом случае правильное 
  if($current_date[0] == $last_date_reported[0] AND $current_date[1] == $last_date_reported[1] AND $current_date[2] == $last_date_reported[2])
  {
    // Если прошло менее установленного минимального времени (между отправками) с момента последней отправки
    // заканчиваем программу, иначе продолжаем
    if($current_time < ($last_time_reported + $post_time_interval*60))
    {
      echo 'Прошло всего ' . ($current_time - $last_time_reported)/60 . ' минут (менее установленного времени с момента последней отправки), а должно пройти ' . $post_time_interval . ' минут';
       return;
    }
  }
*/

  
  //находим нереализованную задачу в списке запланированных задач
  $current_task = 0; // обнуляем текущую задачу
  foreach ($scheduled_tasks as $i => $scheduled_task)
  {
  	foreach ($reported_tasks as $reported_task)
  	{
  		
  		//echo 'reported_task = ' . $reported_task;
  		
  		$reported_task = explode(" ", $reported_task);
  		$reported_task_check = $reported_task[1] . ' ' . $reported_task[2];
  		if($reported_task_check == $zp_input_data['catalog_filename'] . ' ' . $scheduled_task )
  		{
		  // если обработка файла с таким названием уже производилась, сохранить название обработанного файла каталога, чтобы в него производить дозапись
		  // если ни одного обработанного файла не найдено, при записи обработанного файла каталога необходимо будет сгенерировать новое название выходного файла (по дате и времени) и произвести в него запись
  		  
		  //$zp_preprocess_data['processed_catalog_filename'] = $reported_task[3];
  		  $zp_preprocess_data['processed_catalog_filename'] = $reported_task[3];
  		  //echo '1 zp_preprocess_data[processed_catalog_filename] = ' . $zp_preprocess_data['processed_catalog_filename'];
  		  continue 2;
  		}  
  		
  	}
  	$zp_preprocess_data['current_task'] = $scheduled_task; // если в выполненных задачах нет текущей проверяемой задачи из запланированных
  	                                 // значит назначаем её текущей выполняемой
  	if($inverses[$i] == 'inverse')
	    $zp_preprocess_data['inverse'] = 'yes';
	
    break; // прекратим перебор запланированных заданий, так как уже нашлось задание, которое ещё не выполнено 	                                 
  }
  
  
 
  
  
  if(!$zp_preprocess_data['current_task'])
  { 
    return 'В файле расписания: нет невыполненных задач! Программа остановлена. <BR> Загрузите файл с новым расписанием задач!';
  }
  
  //$start_num_letter = explode('-', $current_task);
  $start_num_string = explode('-', $zp_preprocess_data['current_task']);
  $zp_preprocess_data['stop_num_string'] = $start_num_string[1]; // начальная строка списка адресов для текущей задачи рассылки
  $zp_preprocess_data['start_num_string'] = $start_num_string[0]; // конечная строка списка адресов для текущей задачи рассылки



  
  //echo 'current_task =  ' .  $zp_preprocess_data['current_task'] .'<br>';
  

  
  
  
  
  
  
  
  
//---------------- заполняем все данные из определённого на предыдущем этапе файла c табличными данными


  if (!$fp = fopen($zp_server_directory . $zp_input_data['catalog_filename'], 'r')) 
  {
     return 'Ошибка открытия файла с исходной таблицей ' . $zp_input_data['catalog_filename'];
  }
  
  $buffer = explode(';', fgets($fp));
  
  $buffer = trim($buffer[0]);
  if($buffer == '') 
  {
   return 'Неверный формат файла ' . $zp_input_data['catalog_filename'];
  }
  
  
  /*
  //если первая строка не входит в название файла (города), закончить
  $buffer = strpos($zp_input_data['catalog_filename'], $buffer);
  if($buffer === false) 
  {
    return 'Неверный формат файла ' . $zp_input_data['catalog_filename'] . ' (первая строка не имя файла)';
  }
  
  
  //если вторая строка не специальный символ >, закончить
  $buffer = explode(';', fgets($fp));
  if(trim($buffer[0]) != '>') 
  {
   return 'Неверный формат файла ' . $zp_input_data['catalog_filename'];
  }
  */
  
  
  
  // вводим все данные, предшествующие табличным, в формате >
  while(!feof($fp))
  {
    $buffer = explode(';', cp1251_to_utf8_recursive((fgets($fp)))); 
    //$buffer = explode(';', iconv("cp1251", "UTF-8", (fgets($fp)))); 
    
    // пока не встретится в начале строки >>>, выходим из цикла и переходим к вводу табличных данных
    $buffer = trim($buffer[0]);
    if(trim($buffer) == '>>>')
     break;
  	
  	if(!$buffer OR $buffer =='')
     continue;
     
    if($buffer[0] == '/' AND $buffer[1] == '/') 
    {
      $zp_input_data_commented[] = $buffer;
      continue;	
    }
    
     
    $buffer = explode('>', $buffer);
    if($buffer[1] AND $buffer[2])
      $zp_input_data[$buffer[1]] = $buffer[2];
      
      
        //echo '$zp_input_data =  ' .  $zp_input_data[$buffer[1]] .'<br>';
  }
  

  
  
  // переходим к вводу табличных данных --------------------------------------------------
  
  //запоминаем названия полей для данных
  $buffer = cp1251_to_utf8_recursive(trim(fgets($fp)));
  
  
  //echo 'названия полей для данных =  ' .  $buffer  .'<br>';
  $fields = explode(";", $buffer);
  
  // пропускаем одну строку (нумерация полей)
  $buffer = fgets($fp);
  
  
  $count = 0;
  $string_count=-1;
  //for ($i = 0; (($buffer = trim(fgets($fp))) != '>>'); $i++)
  for ($i = 0; !feof($fp); $i++)
  { 
  	$count++;   
  	
  	$buffer = fgets($fp);
  	$buffer = cp1251_to_utf8_recursive($buffer);
  	$buffer = explode(";", $buffer);
  	
  	/*
  	if(trim($buffer[1]) == '>>' OR trim($buffer[2]) == '')
  	{
      $count--;
      $i--;
      continue;	
    }
  	*/
    
    if(($zp_preprocess_data['stop_num_string'] > 0 AND ($count < $zp_preprocess_data['start_num_string'] OR $count > $zp_preprocess_data['stop_num_string']))) // если номер строки вне интервала номеров строк, определённого в задаче, то пропускаем эту строку и уменьшаем счётчик $i на единицу
    {
      $i--;
      continue;	
    }
  	
    for ($j = 0; $j < count($buffer); $j++)
     {
       $zp_catalog[$i][$fields[$j]] = trim($buffer[$j]);
     }  
     
     //foreach ($zp_catalog[$i] as $key => $value)
      //echo $key . ' =>' .  $value . '<br>';
  } 
  
  
  
  /*
  foreach($zp_catalog as $values)
  {
  	$string = '';
   foreach($values as $value)
     $string = $string . ' > ' . $value;
   
   echo 'данные для обработки =  ' .  $string  .'<br>';
     
  }
  */

  
  
  
  // количество обработанных строк может отличаться от указанного в задании (может быть меньше, если строк реально меньше)
  // поэтому корректируем реальную цифру конечного номера строки
  $zp_preprocess_data['real_stop_num_string'] = $zp_preprocess_data['start_num_string'] + ($i-1); 
    
  fclose($fp);

  
  
  
  
  return;
	
	
	
}











// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// Прочие функции -------------------------------------------------------------------------------







// Преобразование кодировок------------------------------------

function cp1251_to_utf8_recursive(/*mixed*/ $data)
{
	if (is_array($data))
	{
		$d = array();
		foreach ($data as $k => &$v)
		{
			$d[cp1251_to_utf8_recursive($k)] = cp1251_to_utf8_recursive($v);
		}
		return $d;
	}
	if (is_string($data)) return iconv('cp1251', 'utf-8//IGNORE//TRANSLIT', $data);
	if (is_scalar($data) or is_null($data)) return $data;
	#throw warning, if the $data is resource or object:
	trigger_error('An array, scalar or null type expected, ' . gettype($data) . ' given!', E_USER_WARNING);
	return $data;
}



/*  //declared also in Z:\home\zapokupkami.com\www\includes\unicode.inc:211


function truncate_utf8($string, $len, $wordsafe = FALSE, $dots = FALSE) {
	$slen = strlen($string);
	if ($slen <= $len) {
		return $string;
	}
	if ($wordsafe) {
		$end = $len;
		while (($string[--$len] != ' ') && ($len > 0)) {};
		if ($len == 0) {
			$len = $end;
		}
	}
	if ((ord($string[$len]) < 0x80) || (ord($string[$len]) >= 0xC0)) {
		return substr($string, 0, $len) . ($dots ? ' ...' : '');
	}
	while (--$len >= 0 && ord($string[$len]) >= 0x80 && ord($string[$len]) < 0xC0) {};
	return substr($string, 0, $len) . ($dots ? ' ...' : '');
}

*/






function translit_no_spaces($string, $format = 1)
{
	// таблица для транслита
	$iso1 = array(
	"Р„"=>"Ye","Р†"=>"I","Рѓ"=>"G","С–"=>"i","в„–"=>"#","С”"=>"ye","С“"=>"g",
	"Рђ"=>"A","Р‘"=>"B","Р’"=>"V","Р“"=>"G","Р”"=>"D",
	"Р•"=>"E","РЃ"=>"Yo","Р–"=>"Zh",
	"Р—"=>"Z","Р?"=>"I","Р™"=>"J","Рљ"=>"K","Р›"=>"L",
	"Рњ"=>"M","Рќ"=>"N","Рћ"=>"O","Рџ"=>"P","Р "=>"R",
	"РЎ"=>"S","Рў"=>"T","РЈ"=>"U","Р¤"=>"F","РҐ"=>"Kh",
	"Р¦"=>"Ts","Р§"=>"Ch","РЁ"=>"Sh","Р©"=>"Sch","РЄ"=>"'",
	"Р«"=>"Y","Р¬"=>"","Р"=>"E","Р®"=>"Yu","РЇ"=>"Ya",
	"Р°"=>"a","Р±"=>"b","РІ"=>"v","Рі"=>"g","Рґ"=>"d",
	"Рµ"=>"e","С‘"=>"yo","Р¶"=>"zh",
	"Р·"=>"z","Рё"=>"i","Р№"=>"j","Рє"=>"k","Р»"=>"l",
	"Рј"=>"m","РЅ"=>"n","Рѕ"=>"o","Рї"=>"p","СЂ"=>"r",
	"СЃ"=>"s","С‚"=>"t","Сѓ"=>"u","С„"=>"f","С…"=>"kh",
	"С†"=>"ts","С‡"=>"ch","С€"=>"sh","С‰"=>"shh","СЉ"=>"",
	"С‹"=>"y","СЊ"=>"","СЌ"=>"e","СЋ"=>"yu","СЏ"=>"ya","В«"=>"","В»"=>"","вЂ”"=>"-","С—"=>"i","Р‡"=>"I"
	);

	// добавляем не вошедшие в таблицу символы
	$iso1[cp1251_to_utf8_recursive('И')] = "I";
	$iso1[cp1251_to_utf8_recursive('П')] = "P";
	$iso1[cp1251_to_utf8_recursive('Р')] = "R";
	$iso1[cp1251_to_utf8_recursive('Э')] = "E";


	if ($format == 1)
	$translit = strtr(cp1251_to_utf8_recursive($string), $iso1);
	else
	$translit = strtr($string, $iso1);
	
	// заменяем пробелы на дефисы
	
	//$translit = preg_replace('/[^a-z0-9]/', '-', strtolower($translit)); -------------------------------<<<
	$translit = preg_replace('/[^a-z0-9]/', '-', mb_strtolower($translit));
	if(strpos($translit, '--') !== FALSE)
	{
		$translit = str_replace('--', '-', $translit);
	}
	
	$translit = trim($translit, '-'); // убираем - по краям
	
	/*
	if(strpos($translit, ' ') !== FALSE)
	{
		$translit = str_replace(' ', '-', $translit);
	}
	*/

	return $translit;

}







function translit($string, $format = 1)
{
	// таблица для транслита
	$iso1 = array(
	"Р„"=>"Ye","Р†"=>"I","Рѓ"=>"G","С–"=>"i","в„–"=>"#","С”"=>"ye","С“"=>"g",
	"Рђ"=>"A","Р‘"=>"B","Р’"=>"V","Р“"=>"G","Р”"=>"D",
	"Р•"=>"E","РЃ"=>"Yo","Р–"=>"Zh",
	"Р—"=>"Z","Р?"=>"I","Р™"=>"J","Рљ"=>"K","Р›"=>"L",
	"Рњ"=>"M","Рќ"=>"N","Рћ"=>"O","Рџ"=>"P","Р "=>"R",
	"РЎ"=>"S","Рў"=>"T","РЈ"=>"U","Р¤"=>"F","РҐ"=>"Kh",
	"Р¦"=>"Ts","Р§"=>"Ch","РЁ"=>"Sh","Р©"=>"Sch","РЄ"=>"'",
	"Р«"=>"Y","Р¬"=>"","Р"=>"E","Р®"=>"Yu","РЇ"=>"Ya",
	"Р°"=>"a","Р±"=>"b","РІ"=>"v","Рі"=>"g","Рґ"=>"d",
	"Рµ"=>"e","С‘"=>"yo","Р¶"=>"zh",
	"Р·"=>"z","Рё"=>"i","Р№"=>"j","Рє"=>"k","Р»"=>"l",
	"Рј"=>"m","РЅ"=>"n","Рѕ"=>"o","Рї"=>"p","СЂ"=>"r",
	"СЃ"=>"s","С‚"=>"t","Сѓ"=>"u","С„"=>"f","С…"=>"kh",
	"С†"=>"ts","С‡"=>"ch","С€"=>"sh","С‰"=>"shh","СЉ"=>"",
	"С‹"=>"y","СЊ"=>"","СЌ"=>"e","СЋ"=>"yu","СЏ"=>"ya","В«"=>"","В»"=>"","вЂ”"=>"-","С—"=>"i","Р‡"=>"I"
	);

	// добавляем не вошедшие в таблицу символы
	$iso1[cp1251_to_utf8_recursive('И')] = "I";
	$iso1[cp1251_to_utf8_recursive('П')] = "P";
	$iso1[cp1251_to_utf8_recursive('Р')] = "R";
	$iso1[cp1251_to_utf8_recursive('Э')] = "E";


	if ($format == 1)
	$translit = strtr(cp1251_to_utf8_recursive($string), $iso1);
	else
	$translit = strtr($string, $iso1);

	return $translit;

}


function utf8_to_cp1251($s)
        {
            for ($c=0;$c<strlen($s);$c++)
            {
               $i=ord($s[$c]);
               if ($i<=127) $out.=$s[$c];
                   if ($byte2){
                       $new_c2=($c1&3)*64+($i&63);
                       $new_c1=($c1>>2)&5;
                       $new_i=$new_c1*256+$new_c2;
                   if ($new_i==1025){
                       $out_i=168;
                   } else {
                       if ($new_i==1105){
                           $out_i=184;
                       } else {
                           $out_i=$new_i-848;
                       }
                   }
                   $out.=chr($out_i);
                   $byte2=false;
                   }
               if (($i>>5)==6) {
                   $c1=$i;
                   $byte2=true;
               }
            }
            return $out;
        }

 
function utf8_win ($s){
//## перекодировка unicode UTF-8 -> win1251
	$out="";
	$c1="";
	$byte2=false;
	for ($c=0;$c<strlen($s);$c++){
		$i=ord($s[$c]);
		if ($i<=127) $out.=$s[$c];
		if ($byte2){
			$new_c2=($c1&3)*64+($i&63);
			$new_c1=($c1>>2)&5;
			$new_i=$new_c1*256+$new_c2;
			if ($new_i==1025){
				$out_i=168;
			}else{
				if ($new_i==1105){
					$out_i=184;
				}else {
					$out_i=$new_i-848;
				}
			}
			$out.=chr($out_i);
			$byte2=false;
		}
		if (($i>>5)==6) {
			$c1=$i;
			$byte2=true;
		}
	}
	return $out;
}
        


function zp_clear_cache_drupal()
{
	drupal_clear_css_cache();
 
	$core = array('cache', 'cache_content', 'cache_filter', 'cache_menu', 'cache_page', 'cache_views');
	$alltables = array_merge($core, module_invoke_all('devel_caches'));
	foreach ($alltables as $table) 
	{
  		cache_clear_all('*', $table, true);
	}
	
	//print(t('Cache cleared.'));
}





function show($value){
	
	echo '<PRE>';
	print_r($value);
	echo '</PRE>';
}