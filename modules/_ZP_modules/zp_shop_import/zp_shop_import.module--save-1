<?php

global $version;
$version = '2.1b 20-05-10';




// название полей с данными в таблице в исходном файле
global $fields;
$fields = array();
  
// данные о запланированных и реализованных задачах
global $reported_tasks;
$reported_tasks = array();
global $scheduled_tasks; 
$scheduled_tasks = array(); 
  
// исходные данные из файла (кроме табличных)
global $zp_input_data;
$zp_input_data = array();
global $zp_input_data_commented;
$zp_input_data_commented  = array();

// массив с исходными табличными данными из файла
global $zp_catalog; 
$zp_catalog = array(); 
    
// массив выходных данных, которые уже прошли обработку 
//(у них будут сняты все пометки о необходимости редактирования 
// и добавлена метка error в поле 'Действие / результат', если булут какие-либо проблемы при обработке)
global $zp_catalog_processed;
$zp_catalog_processed = array();
 
// дополнительные текущие данные, в том числе название файлов для обработки
global $zp_preprocess_data;
$zp_preprocess_data = array();

// ----- считываем из файла исходных данных имя файла с данными, с которыми придётся работать
$zp_preprocess_data['zp_shop_input_data'] = '---zp_shop_input_data.csv';
//$file_name = '---zp_shop_input_data.csv';
//$file_name = $form_values['csvfile'];

// катарол на сервере с исходными и выходными файлами с данными
global $zp_server_directory;
//$zp_server_directory = 'http://www.zapokupkami.com/zp_import_data/';
//$zp_server_directory = 'D:\\WebServers\\home\\zapokupkami.com\\www\\zp_import_data\\';
$zp_server_directory = $_SERVER['DOCUMENT_ROOT'] . base_path() . 'zpwrk/shop_import/';



/**
 * Implementation of hook_menu().
 */
function zp_shop_import_menu($may_cache)
{
    global $form_values;
  $items = array();
    $items[] = array(
        'path' => 'admin/store/products/import/zp_shop_import',
        'access' => user_access('import'),
        //'title' => t('ZP Shop Import /Ver. '. Version),
        'title' => t('ZP Shop Import'),
        'callback' => 'drupal_get_form',
        'callback arguments' => array('zp_shop_import_multiform'),
        'type' => MENU_NORMAL_ITEM,
    );


  return $items;
}




function zp_shop_import_get_delimiter($in = '')
{
    $delimiter_map = array(
        'semi colin'    => ';',
        'comma'         => ',',
        'tab'           => "\t"
    );
    if(isset($delimiter_map[$in]))
        return $delimiter_map[$in];
    elseif(empty($in))
        return  ';';
}







// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------

// Multistep form for collecting the import options before processing the

function zp_shop_import_multiform($values = NULL)
{
    //global $output_i_results;
	global $version;
	
	
	global $fields;
	global $reported_tasks;
	global $scheduled_tasks; 
	global $zp_input_data;
	global $zp_input_data_commented;
	global $zp_catalog; 
	global $zp_catalog_processed;
	global $zp_preprocess_data;
	
	
	
    $form = array();

    $form['#multistep'] = TRUE;
    $form['#redirect'] = FALSE;

    // Find out which step we are on. If $values is NULL,
    // that means we are on step 1.
    $step = !is_null($values) ? (int) $values['step'] : 1;

    // переменная для возврата на первое окно импорта
    global $new_import;
    if($new_import != 0) $step = $new_import;

    $form['step'] = array(
        '#type' => 'hidden',
        '#value' => $step + 1
    );

    switch($step)
    {
        case 1:     // STEP 1

        
        	  
  			$error_mesage = zp_load_data_from_files();	
  			
  			if($error_mesage)
  			{
  			  	//echo $error_mesage;
  			  
            	$form['step1'] = array(
                '#type' => 'fieldset',
                '#collapsible' => TRUE,
                '#collapsed' => FALSE,
                '#title' => t('Шаг 1: Исходные данные /Ver. ' . $version)
            	);
            
            	$form['step1']['errors'] = array(
                '#type'             => 'textarea',
                '#title'            => 'Обнаруженные ошибки загрузки исходных данных',
                '#default_value'    => $error_mesage,
                //'#description'      => t('Path to the images on the server. Its assumed you have already uploaded the images. You can define the file name for each product in a column in your CSV file.'),
            	);
            
             	// заменяем кнопку Submit на ссылку на начальную страницу импорта (фактически, перезагружаем страницу)
            	$form['step1']['reload'] = array(
			  	'#type' => 'item',
  				//'#title' => l(t('Перезагрузить страницу'), 'admin/store/products/import/zp_shop_import', array('title' => t('Обновить страницу'))),
  				'#value' => l(t('Перезагрузить страницу'), 'admin/store/products/import/zp_shop_import', array('title' => t('Обновить страницу'))),
  				'#prefix' => '<strong>',
  				'#suffix' => '</strong>', 
				);

            	/*
            	// кнопка  Submit
	    		$form['submit'] = array(
	        	'#type' => 'submit',
	        	'#value' => t('Обновить эту страницу после загрузки новых данных')
	        	);
	        	*/

              	$new_import = 1; // вернуться на первую страницу (первый шаг)

              	//break;
              	return $form;
  			}


  			 $form['step1'] = array(
                '#type' => 'fieldset',
                '#collapsible' => TRUE,
                '#collapsed' => FALSE,
                '#title' => t('Шаг 1: Исходные данные /Ver. ' . $version)
            );

  			$source_files = 'Главный файл с описанием файлов с исходными данными: ' . $zp_preprocess_data['zp_shop_input_data'] . '
  			
' . 'Расписание задач: ' . $zp_preprocess_data['zp_schedule_file'] . '
' . 'Ранее выполненные задачи (отчёт): ' . $zp_preprocess_data['zp_schedule_report'] . '
' . 'Табличные данные для загрузки в базу данных: ' . $zp_input_data['catalog_filename'] . '

';		
  			// если загрузка не первая из этого файла, то уже известно название выходного файла с обработанной таблицей
  			if($zp_preprocess_data['processed_catalog_filename'])
  			  $source_files = $source_files . 'Файл с обработанными табличными данными (в него записывается результат работы): ' . $zp_preprocess_data['processed_catalog_filename'];
			
  			  
  			 //echo 'step 1 zp_preprocess_data[processed_catalog_filename] = ' . $zp_preprocess_data['processed_catalog_filename'];
  			
  			$form['step1']['source_files'] = array(
                '#type'             => 'textarea',
                '#title'            => 'Файлы с исходными данными (данные считаны из файла' . $zp_preprocess_data['zp_shop_input_data'] . ')',
                '#default_value'    => $source_files,
                //'#description'      => t('Принято в обработку ' . $count_processed . ' строк из '. $count_whole . ' строк (c ' . $zp_preprocess_data['start_num_string'] . ' по ' . $zp_preprocess_data['stop_num_string'] .  '), указанных в задании (из них пустых ' . ($count_whole - $count_processed) .' строк не показаны и обрабатываться не будут)'),
            	);
            	
            
  
            $all_scheduled_tasks = '';	
            foreach($zp_preprocess_data['scheduled_tasks'] as $scheduled_task)
             $all_scheduled_tasks = $all_scheduled_tasks . '
' . $scheduled_task;
            
            $form['step1']['scheduled_task'] = array(
                '#type'             => 'textarea',
                '#title'            => 'Все задачи из файла с расписанием задач ' . $zp_preprocess_data['zp_schedule_file'],
                '#default_value'    => $all_scheduled_tasks,
                '#description'      => t('Часть задач уже может быть выполнена (см. ниже содержимое файла отчёта с уже выполненными задачами)'),
            	);
  			
            $all_reported_tasks = '';	
            foreach($zp_preprocess_data['reported_tasks'] as $reported_task)
             $all_reported_tasks = $all_reported_tasks . '
' . $reported_task;

             $form['step1']['reported_task'] = array(
                '#type'             => 'textarea',
                '#title'            => 'Все задачи из файла с расписанием задач ' . $zp_preprocess_data['zp_schedule_report'],
                '#default_value'    => $all_reported_tasks,
                '#description'      => t('Эти задачи уже выполняться не будут'),
            	);
             
            
            	
            if($zp_preprocess_data['inverse'] == 'yes')
  			 $process_order = ', инвертированный порядок обработки строк (с конца в начало), полезно при удалении элементов';
  			  
            $form['step1']['current_task'] = array(
                '#type'             => 'textarea',
                '#title'            => 'Текущая (очередная) задача (строки из файла ' . $zp_input_data['catalog_filename'] . '), готовая к обработке',
                '#default_value'    => 'Строки ' . $zp_preprocess_data['current_task'] . ' из исходной таблицы' . $process_order,
                '#description'      => t('Задача выбрана из расписания задач ' . $zp_preprocess_data['zp_schedule_file'] . ', с учётом уже выполненных задач (по данным из файла отчёта' . $zp_preprocess_data['zp_schedule_report'] . ')'),
            	);
  			 

  			
  			$string = '';
  			foreach ($fields as $field)
  			  $string = $string . ' > ' . $field;
  			$string = $string . '

';
  			$count_whole = 0;
  			$count_processed = 0;
  			foreach($zp_catalog as $values)
  			{
  				$count_whole++;
  				if(trim($values['Действие / результат']) == '' OR  trim($values['Действие / результат']) == '>>')
  				  continue;
  				  
  				$count_processed++;
   				foreach($values as $value)
     			   $string = $string . ' > ' . $value;
     			$string = $string . '

';
			}
  
 	
			// все данные из файла в форме массива
			//$real_data = $zp_catalog;
			//foreach ($real_data as $key => $value) 
			foreach ($zp_catalog as $key => $value) 
			{
				if($value['Тип записи'] == '' OR $value['Тип записи'] == ' ')
				{
					//unset($real_data[$key]);
					continue;
				}
				$real_data[$key . '-' . $value['Действие / результат']] = $zp_catalog[$key];
			}
			
			$form['step1']['all_data'] = array(
                '#type'             => 'textarea',
                '#title'            => 'Все данные, считанные из файла ' . $zp_input_data['catalog_filename'] . ' в соответствием с заданием (расписанием)',
                '#default_value'    => print_r($real_data, TRUE), //print_r($zp_catalog, TRUE),
                '#description'      => t('Файл содержит '. $count_whole . ' строк (c ' . $zp_preprocess_data['start_num_string'] . ' по ' . $zp_preprocess_data['stop_num_string'] .  '), указанных в задании (из них пустых ' . ($count_whole - $count_processed) .' строк показаны, но обрабатываться не будут)'),
            	);
			
			
			
        	$form['step1']['data_to_process'] = array(
                '#type'             => 'textarea',
                '#title'            => 'Данные, считанные из файла ' . $zp_input_data['catalog_filename'] . ' в соответствием с заданием (расписанием) и готовые к обработке',
                '#default_value'    => $string,
                '#description'      => t('Принято в обработку ' . $count_processed . ' строк из '. $count_whole . ' строк (c ' . $zp_preprocess_data['start_num_string'] . ' по ' . $zp_preprocess_data['stop_num_string'] .  '), указанных в задании (из них пустых ' . ($count_whole - $count_processed) .' строк не показаны и обрабатываться не будут)'),
            	);
            	  
  

	   		 // кнопка  Submit
	    	$form['submit'] = array(
	        	'#type' => 'submit',
	        	'#value' => t('Внести данные в базу')
	        );

            $new_import = 0;

            break;






        case 2:     // STEP 2


// Save data from perivious step to pass on to next step (hidden)...
// сохранение полей выбора пользователя
// если здесь не прописать все поля, то на последующих шагах не сохранятся значения, выбранные пользователем
// соответственно, не будет к ним доступа (они все будут неопределены) и их нельзя будет использовать

            
			echo 'STEP 2 starts... with file ' . $zp_preprocess_data['zp_shop_input_data'] . '<br>';
			
			zp_process_loaded_data();
			
			
			
			
            $form['step2'] = array(
                '#type' => 'fieldset',
                //'#title' => t('Step 2: Map CSV columns to Ubercart product data.'),
                '#title' => t('Шаг 2: Результаты обработки данных'),
                //'#description' => t('For each column in the CSV listed bellow select what it maps to on a Product. Items with a * after their name mus be mapped to something.')
            );
			
			
			
			
			// сформируем название полей табличных данных (чтобы показать их в исходных и обработанных табличных данных)
			
			$fields_string = '';
  			foreach ($fields as $field)
  			  $fields_string = $fields_string . ' > ' . $field;
  			$fields_string = $fields_string . '

';
  			// выведем исходные табличные данные для сравнения
  			$string = '';
  			$count_whole = 0;
  			$count_processed = 0;
  			foreach($zp_catalog as $values)
  			{
  				$count_whole++;
  				if(trim($values['Действие / результат']) == '' OR  trim($values['Действие / результат']) == '>>')
  				  continue;
  				  
  				$count_processed++;
   				foreach($values as $value)
     			   $string = $string . ' > ' . $value;
     			$string = $string . '

';
 			    //echo 'данные для обработки =  ' .  $string  .'<br>';
			}
  	
			$string = $fields_string . $string;
			
			$form['step2']['previous_data'] = array(
                '#type' => 'fieldset',
                //'#title' => t('Step 2: Map CSV columns to Ubercart product data.'),
                '#title' => t('Исходные данные (для сравнения)'),
                '#description' => t('Данные, считанные из исходных файлов'),
                '#collapsible' => TRUE,
                '#collapsed' => TRUE,
            );
 	
        	$form['step2']['previous_data']['data_to_process'] = array(
                '#type'             => 'textarea',
                '#title'            => 'Данные, считанные из файла ' . $zp_input_data['catalog_filename'] . ' в соответствием с заданием (расписанием) и затем обработанные (результат см. ниже)',
                '#default_value'    => $string,
                '#description'      => t('Принято в обработку ' . $count_processed . ' строк из '. $count_whole . ' строк (c ' . $zp_preprocess_data['start_num_string'] . ' по ' . $zp_preprocess_data['stop_num_string'] .  '), указанных в задании (из них пустых ' . ($count_whole - $count_processed) .' строк не показаны и обрабатываться не будут)'),
            	);

            	
            	
            	
            	
            // выводим результаты работы
            
			$form['step2']['results_data'] = array(
                '#type' => 'fieldset',
                //'#title' => t('Step 2: Map CSV columns to Ubercart product data.'),
                '#title' => t('Результаты работы'),
                '#description' => t('Данные, обработанные программой из исходных файлов. Часть или полностью могут быть загружены в базу (в зависимости от наличия или отсутствия ошибок в данных)'),
                '#collapsible' => TRUE,
                '#collapsed' => FALSE,
            );            

            

            
   
             
            // выведем данные о выполненном задании, обновлённом расписанием 
            // (с учётом только что обработанных данных), исходных и выходных файлах и т.д.

  			 $form['step2']['results_data']['schedule'] = array(
                '#type' => 'fieldset',
                '#collapsible' => TRUE,
                '#collapsed' => TRUE,
                '#title' => t('Данные об исходных, выходных файлах и выполненном задании')
            );

  			$source_files = 'Главный файл с описанием файлов с исходными данными: ' . $zp_preprocess_data['zp_shop_input_data'] . '
  			
' . 'Расписание задач: ' . $zp_preprocess_data['zp_schedule_file'] . '
' . 'Ранее выполненные задачи (отчёт): ' . $zp_preprocess_data['zp_schedule_report'] . '
' . 'Исходные табличные данные для загрузки в базу данных: ' . $zp_input_data['catalog_filename'] . '

';		

  			// если загрузка не первая из этого файла, то уже известно название выходного файла с обработанной таблицей
  			if($zp_preprocess_data['processed_catalog_filename'])
  			  $source_files = $source_files . 'Файл с успешно обработанными табличными данными (в него записан результат работы): ' . $zp_preprocess_data['processed_catalog_filename'] . '_out.csv

';

  			if($zp_preprocess_data['processed_catalog_filename_errors'])
  			  $source_files = $source_files . 'Файл с описанием ошибок или замечаний, возникших при обработке табличных данных (по каждому элементу): ' . $zp_preprocess_data['processed_catalog_filename_errors'];
  			
  			$form['step2']['results_data']['schedule']['source_and_result_files'] = array(
                '#type'             => 'textarea',
                '#title'            => 'Файлы с исходными и выходными данными (исходные данные считаны из файла' . $zp_preprocess_data['zp_shop_input_data'] . ')',
                '#default_value'    => $source_files,
                //'#description'      => t('Принято в обработку ' . $count_processed . ' строк из '. $count_whole . ' строк (c ' . $zp_preprocess_data['start_num_string'] . ' по ' . $zp_preprocess_data['stop_num_string'] .  '), указанных в задании (из них пустых ' . ($count_whole - $count_processed) .' строк не показаны и обрабатываться не будут)'),
            	);
            	
            
  			 /*
            $all_scheduled_tasks = '';	
            foreach($zp_preprocess_data['scheduled_tasks'] as $scheduled_task)
             $all_scheduled_tasks = $all_scheduled_tasks . '
' . $scheduled_task;
            
            $form['step2']['results_data']['schedule']['scheduled_task'] = array(
                '#type'             => 'textarea',
                '#title'            => 'Все задачи из файла с расписанием задач ' . $zp_preprocess_data['zp_schedule_file'],
                '#default_value'    => $all_scheduled_tasks,
                '#description'      => t('Часть задач уже может быть выполнена'),
            	);
  			
            $all_reported_tasks = '';	
            foreach($zp_preprocess_data['reported_tasks'] as $reported_task)
             $all_reported_tasks = $all_reported_tasks . '
' . $reported_task;

            
             $form['step2']['results_data']['schedule']['reported_task'] = array(
                '#type'             => 'textarea',
                '#title'            => 'Все задачи из файла с расписанием задач ' . $zp_preprocess_data['zp_schedule_report'],
                '#default_value'    => $all_reported_tasks,
                '#description'      => t('Эти задачи уже выполняться не будут'),
            	);
             */
             
  			if($zp_preprocess_data['inverse'] == 'yes')
  			 $process_order = ', инвертированный порядок обработки строк (с конца в начало), полезно при удалении элементов';
  			 
            $form['step2']['results_data']['schedule']['current_task'] = array(
                '#type'             => 'textarea',
                '#title'            => 'Выполненная (текущая) задача (строки из файла ' . $zp_input_data['catalog_filename'] . '), готовая к обработке',
                '#default_value'    => 'Строки ' . $zp_preprocess_data['current_task'] . ' из исходной таблицы' . $process_order,
                '#description'      => t('Задача выбрана из расписания задач ' . $zp_preprocess_data['zp_schedule_file'] . ', с учётом уже выполненных задач (по данным из файла отчёта' . $zp_preprocess_data['zp_schedule_report'] . ')'),
            	);
  			 
            

            	
            	
            	           
            	 
            
            // выведем обработанные табличные данные		  
			$string = '';
			$count_whole = 0;
  			$count_processed = 0;
  			foreach($zp_catalog_processed as $values)
  			{
  				$count_whole++;
  				if(trim($values['Действие / результат']) == '>>')
  				  continue;
  				  
  				$count_processed++;
   				foreach($values as $value)
     			   $string = $string . ' > ' . $value;
     			$string = $string . '

';
 			    //echo 'данные для обработки =  ' .  $string  .'<br>';
			}
            
			if($string)
			  $string = $fields_string . $string;	
			else 
			  $string = 'Не обработано ни одного элемента';
			
            $form['step2']['results_data']['processed_data_all'] = array(
                '#type'             => 'textarea',
                '#title'            => 'Обработанные табличные данные (все), считанные из файла ' . $zp_input_data['catalog_filename'] . ' в соответствии с заданием (расписанием)',
                '#default_value'    => $string,
                '#description'      => t('Обработано ' . $count_processed . ' строк из '. $count_whole . ' строк (c ' . $zp_preprocess_data['start_num_string'] . ' по ' . $zp_preprocess_data['stop_num_string'] .  '), указанных в задании (из них пустых ' . ($count_whole - $count_processed) .' строк не показаны и не обрабатывались)'),
            	);
            
            	
            	
            		
  			// выведем обработанные табличные данные, внесённые в базу, в которых не возникло ошибок или замечаний/предупреждений
			$string = '';
			$count_whole = 0;
  			$count_processed = 0;
  			foreach($zp_catalog_processed as $values)
  			{
  				$count_whole++;
  				if(trim($values['Действие / результат']) != '')
  				  continue;
  				  
  				$count_processed++;
   				foreach($values as $value)
     			   $string = $string . ' > ' . $value;
     			$string = $string . '

';
 			    //echo 'данные для обработки =  ' .  $string  .'<br>';
			}            	
            
			if($string)
			  $string = $fields_string . $string;	
			else 
			  $string = 'Нет элементов, успешно обработанных и внесённых в базу';
            	
            $form['step2']['results_data']['processed_data_ok'] = array(
                '#type'             => 'textarea',
                '#title'            => 'Успешно обработанные (без ошибок и предупреждений) табличные данные, считанные из файла ' . $zp_input_data['catalog_filename'] . ' в соответствии с заданием (расписанием) и записанные в выходной файл ' . $zp_preprocess_data['processed_catalog_filename'] . '_out.csv',
                '#default_value'    => $string,
                '#description'      => t('Показаны только те данные (из общего количества, показанного в предыдущей таблице), при обработке которых не возникло проблем или замечаний. Успешно обработано ' . $count_processed . ' строк из '. $count_whole . ' строк'),
            	);            	
            	
            	
            	
			// выведем обработанные табличные данные, НЕ внесённые в базу, в которых возникли ошибки или замечания/предупреждений
			$string = '';
			$count_whole = 0;
  			$count_processed = 0;
  			foreach($zp_catalog_processed as $values)
  			{
  				$count_whole++;
  				if(trim($values['Действие / результат']) == '' OR trim($values['Действие / результат']) == '>>')
  				  continue;
  				  
  				$count_processed++;
   				foreach($values as $value)
     			   $string = $string . ' > ' . $value;
     			$string = $string . '

';
 			    //echo 'данные для обработки =  ' .  $string  .'<br>';
			}            	
			
			if($string)
			  $string = $fields_string . $string;	
			else 
			  $string = 'Нет элементов, при обработке которых возникли проблемы или замечания';
			
			if($zp_preprocess_data['processed_catalog_filename_errors'])
			  $errors = ' (записаны в файл ' . $zp_preprocess_data['processed_catalog_filename_errors'] . ')';
            	
            $form['step2']['results_data']['processed_data_not_ok'] = array(
                '#type'             => 'textarea',
                '#title'            => 'Табличные данные, при обработке которых возникли ошибки или предупреждения' . $errors ,
                '#default_value'    => $string,
                '#description'      => t('Показаны только те данные (из общего количества, показанного в предыдущей таблице), при обработке которых возникли проблемы или замечания. Всего ' . $count_processed . ' таких элементов (обработанных строк) из '. $count_whole . ' строк общего количества обработанных данных'),
            	);                   	
            	
            	
            	
            	
            	
            	
              	
            
            /*
			
            $form['csvfile'] = array(
                '#type' => 'hidden',
                '#value' => $csv_file
            );
            
            */
           
            /*
            $form['delimiter'] = array(
                '#type' => 'hidden',
                '#value' => $values['delimiter']
            );
            */


            // заменяем кнопку Submit на ссылку на первую начальную страницу загрузки
            $form['step2']['reload'] = array(
			  	'#type' => 'item',
  				//'#title' => l(t('Загрузить следующее задание'), 'admin/store/products/import/zp_shop_import', array('title' => t('Загрузить следующее задание'))),
  				'#value' => l(t('Загрузить следующее задание'), 'admin/store/products/import/zp_shop_import', array('title' => t('Загрузить следующее задание'))),
  				'#prefix' => '<strong>',
  				'#suffix' => '</strong>', 
				);
				
			/*	
			// кнопка  Submit
    		$form['submit'] = array(
        		'#type' => 'submit',
        		'#value' => t('Загрузить следующее задание')
        	);
        	*/
			
        	$new_import = 1;

            break;




            
        case 3:     // STEP 3
              $form['save_report_csv'] = array(
                '#type' => 'hidden',
                '#value' => $values['save_report_csv']
            );

            $form['step3'] = array(
                '#type' => 'fieldset',
                '#title' => t('Step 3: Map CSV columns to Ubercart product data.'),
                '#description' => t('For each column in the CSV listed bellow select what it maps to on a Product. Items with a * after their name mus be mapped to something.')
            );


            // кнопка  Submit
            $form['submit'] = array(
            '#type' => 'submit',
            '#value' => t('Save results or New Import')
            );
            
            
			/*
            $tmp = variable_get('save_report_csv', $form_values['save_report_csv']);
            //drupal_set_message("save_report_csv = $tmp", 'error');
            if($tmp == 'Save')
               $new_import = 4; //значит слеждующий шаг - на первое (начальное) окно импорта
            else 
              */
              $new_import = 1;

            break;

            
            


        case 4:     // STEP 4

            $form['step4'] = array(
                '#type' => 'fieldset',
                '#title' => t('Step 4: Map CSV columns to Ubercart product data.'),
                '#description' => t('For each column in the CSV listed bellow select what it maps to on a Product. Items with a * after their name mus be mapped to something.')
            );


            /*
            
			//$output_i_results = '"Title";"Snippet";"Link";"Type","Author","Date","Comments","Attachments","Score"'."\n".'2"Title","Snippet","Link","Type","Author","Date","Comments","Attachments","Score"';
            $output_i_results = variable_get('output_i_results_var', $output_i_results);
			drupal_set_message("r_t_f = $output_i_results", 'error');
			$output_i_results = utf8_win($output_i_results);
			drupal_set_message("r_t_f = $output_i_results", 'error');
			// если пользователь на первом экране указал производить запись результатов импорта в файл
            // и если есть, что записывать в файл (были добавления новых продуктов или их изменения), делаем это
			//if(0)
			if ($output_i_results != '' AND $form_values['save_report_csv'] == 'Save')
  			  {
   		 	    if($file = file_save_data($output_i_results, file_directory_temp() ."/product_import_results_" . date("MjS_H-i") . ".csv", FILE_EXISTS_REPLACE))
			      {
       				//drupal_set_message(print_r($file, true));
       				file_transfer($file, array(
         			'Content-Type: text/x-comma-seperated-values', //application/xml',
         			'Content-Disposition: attachment; filename="'. $file .'"',));
     	          }
  			  }
  			  			  
  			*/
  			  
            $new_import = 1; //значит слеждующий шаг - на первое (начальное) окно импорта

            break;
           
            

    } // end of switch($step)

    
    return $form;
}











// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// Validate handler for form ID 'zp_shop_import_multiform'.

function zp_shop_import_multiform_validate($form_id, $form_values, $form)
{
	
	global $fields;
	global $reported_tasks;
	global $scheduled_tasks; 
	global $zp_input_data;
	global $zp_input_data_commented;
	global $zp_catalog; 
	global $zp_catalog_processed;
	global $zp_preprocess_data;
	
	/*

    if(isset($form_values['step']))
    {
        $step = $form_values['step'] - 1;

        switch($step)
        {
            case 1:

                if($File = file_check_upload('csvfile'))
                {
                    variable_set('zp_shop_import_filename', $File->filepath);
                    //form_set_value($form['csvfile'], $File->filepath);    // not working??
                    form_set_value($form['csvfile_path'], $File->filepath);

                    drupal_set_message('Got file: '.$File->filename.' (on server: '.$File->filepath.')');
                    echo 'Got file: '.$File->filename.' (on server: '.$File->filepath.')';
                }
                else
                {
                    //form_set_error('csvfile', 'Problem uploading CSV file. Could not proceed to next step.');
                }

                variable_set('uc_importer_handle_duplicates', $form_values['handle_duplicates']);
                variable_set('save_report_csv', $form_values['save_report_csv']);

                break;


            default:
                break;
        }
    }
    else
        form_set_error('step', 'Can not determine process step number?');
        
        
  */        
}











// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// основная функция обработки файла с таблицей ----------------------------------------

function zp_shop_import_multiform_submit($form_id, $form_values)
{
	global $fields;
	global $reported_tasks;
	global $scheduled_tasks; 
	global $zp_input_data;
	global $zp_input_data_commented;
	global $zp_catalog; 
	global $zp_catalog_processed;
	global $zp_preprocess_data;
	
	
	
   // отключим вывод ошибок
   //@error_reporting(0);
  
	
   // Have all the data, time to process it...
   if(intval($form_values['step']) != 3)
     return;

   //drupal_set_message('Step 3: File handling starts...', 'error'); // просто контрольная точка
	//echo 'step = ' . intval($form_values['step']) . '<br>';
   
   
   //global $user; // для доступа к данных о текущем юзере

        
// Единожды для всех строк (продуктов) в выбранном файле выполняем различные действия, в том числе, уcтанавливаем различные переменные

   //$delimiter = zp_shop_import_get_delimiter($form_values['delimiter']);
   //$csvfile_name = $form_values['csvfile'];

   
   //echo 'delimiter =  ' . $delimiter . '<br>';

   
   /*
   //эту функцию для возможности использования транслитерации pathauto вызовем один раз в начале функции
   _pathauto_include();
   // инициализируем данные для возможности транслитерации, с использованием pathauto
   static $i18n_loaded = false;
   static $translations = array();
   if (!$i18n_loaded)
    {
 	 $path = drupal_get_path('module', 'pathauto');
	 if (is_file($path. '/i18n-ascii.txt'))
	   {
	     $translations = parse_ini_file($path. '/i18n-ascii.txt');
       }
           $i18n_loaded = true;
    }
   $pattern = '/[^a-zA-Z0-9]/'; // символы, которые останутся в строке (имени файла, например) после фильтрации
   $separator = ''; // этим будут заменены остальные символы в строке... Пустота "" означает, что лишние символы просто будут удалены

   $r_t_f = "No:;Product_name;Artikul_postavki;Proizvoditel;Artikul_proizv;Bar;Gorod->Magazin->Otdel(s);Artikul_zp;Action;Notice;Price;Kol-vo;Kartinki;" . "\n";

   */ 
      
      
// Перебираем последовательно все строки файла, пока файл не закончится
//-------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------

  
  // zp_load_data_from_files();

  
    



//--------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------
// окончание функции

   //drupal_set_message("Processed $row_count rows of the CSV file $csvfile_name.");
   //drupal_set_message($product_created_count.' products created.');
   //drupal_set_message($product_updated_count.' products updated.');

   //$r_t_f = '1"Title";"Snippet";"Link";"Type","Author","Date","Comments","Attachments","Score"'."\n".'2"Title","Snippet","Link","Type","Author","Date","Comments","Attachments","Score"';
   //$output_i_results = $r_t_f;
   //variable_set('output_i_results_var', $output_i_results);

   // обнуляем кэш, иначе данные на сайте не обновятся! Делаем это единожды в конце функии!
   //db_query("TRUNCATE TABLE {cache_content}");
   return;
}











// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// начало обработки данных из файлов ------------------------------------------------------------

function zp_process_loaded_data()
{
//--------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------  
// начало обработки данных------------------------------------------------------------
  

	
	global $fields;
	global $reported_tasks;
	global $scheduled_tasks; 
	global $zp_input_data;
	global $zp_input_data_commented;
	global $zp_catalog; 
	global $zp_catalog_processed;
	global $zp_preprocess_data;



  //echo 'zp_process_loaded_data' . '<br>';


  
  if($zp_preprocess_data['inverse'] == 'yes')
  {
  	for($i = count($zp_catalog) - 1; $i >= 0; $i--)
  	{
  		echo 'обратный порядок)))))) элемент № ' . $i . ', поле с номером ' . $zp_catalog[$i]['#'] . '<br>';
  		
  		// если в поле Действие не указано действие, пропустить этот элемент и добавить его в список обработанных элементов
  		if(!$zp_catalog[$i]['Действие / результат'] OR $zp_catalog[$i]['Действие / результат'] == '' OR $zp_catalog[$i]['Действие / результат'] == '>>')
  	  		$zp_catalog_processed[] = $zp_catalog[$i];
  		else 
  		{ 
  	  		$result = zp_process_shop_item($zp_catalog[$i]);
  	  		$zp_catalog_processed[] = $result;
  	  
  	  		if($result['Действие / результат'] != '' AND $result['Действие / результат'] != ' ')
  	  			break; // выходим из цикла, если наткнулись на ошибку
  		} 
  	}
  	
  }
  else
  {
   foreach($zp_catalog as $shop_item)
   {
  	echo 'прямой порядок)))))) элемент № ' . $i . ', поле с номером ' . $zp_catalog[$i]['#'] . '<br>';
  	
   	// если в поле Действие не указано действие, пропустить этот элемент и добавить его в список обработанных элементов
  	if(!$shop_item['Действие / результат'] OR $shop_item['Действие / результат'] == '' OR $shop_item['Действие / результат'] == '>>')
  	  $zp_catalog_processed[] = $shop_item;
  	else 
  	{ 
    
  		echo '<PRE>';
  		print_r($shop_item);
  		echo '</PRE>';
  		
  	  ///////////////////////////////////$result = zp_process_shop_item($shop_item);
  	  $zp_catalog_processed[] = $result;
  	  
  	  if($result['Действие / результат'] != '' AND $result['Действие / результат'] != ' ')
  	  	break; // выходим из цикла, если наткнулись на ошибку
  	} 
   }
  }

	
  
  	
    
 	// переписываем алиас с помощью транслита pathauto
	// для этого сначала удаляем существующий алиас,
	// а потом запускаем функцию node_pathauto_bulkupdate, которая создаёт алиасы для всех нодов, к которых нет алиасов
	
	//db_query("DELETE FROM {url_alias}  WHERE src = '%s'", 'node/'.$nid);
	//db_query("DELETE FROM {url_alias}  WHERE src = '%s'", 'node/'.$nid.'/edit');

	//для возможности вызова node_pathauto_bulkupdate один раз вначале текущей функции вызываем _pathauto_include();
	_pathauto_include();
	node_pathauto_bulkupdate();
  
  
  
  
  
  
  
  // Clear the cache so an anonymous poster can see the node being added or updated.
  //cache_clear_all();		
  zp_clear_cache_drupal();
  
  //print '<PRE>';
  //print_r($zp_catalog_processed);
  //print '</PRE>';

  
  // записать результаты в файлы обработанных данных и отметки заданий-----------------------
  zp_write_results($zp_catalog_processed,
                    $fields, 
                    $zp_input_data, 
                    $zp_input_data_commented, 
                    $zp_preprocess_data['start_num_string'],
                    $zp_preprocess_data['stop_num_string'], 
                    $zp_preprocess_data['real_stop_num_string']);

   return 0; // 0 = нет ошибок

}









// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// функция-коллектор обработки элементов магазина ---------------------------------------

function zp_process_shop_item($shop_item)
{
	
	switch ($shop_item['Действие / результат'])
	{
		case 'new':
			$shop_item = zp_item_new($shop_item);
			break;
			
		case 'change':
			$shop_item = zp_item_change($shop_item);
			break;
		
			
		case 'delete':
			$shop_item = zp_item_delete($shop_item);
			break;
				
		
		case 'hide':
			$shop_item = zp_item_hide_and_unhide($shop_item, 'hide');
			break;
			
			
		case 'unhide':
			$shop_item = zp_item_hide_and_unhide($shop_item, 'unhide');
			break;
			
		
		default:
			break;	
	}

	return $shop_item;
}













// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// функция убирает в полученной строке дубликаты кавычек и кавычки по краям
function zp_correct_quotes($string)
{
	// проверим, нет ли в полученной строке дубликатов кавычек
	// и если есть, заменим две на одну, а одинарные (по краям) вообще уберём

	if(strpos($string, '""') !== FALSE)
	{

		$string = str_replace('""', '"', $string);
		
		if($string[0] = '"')
			$string[0] = ' ';
		
		$last = strlen($string) - 1;
		if($string[$last] = '"')
			$string[$last] = ' ';
			
		$string = trim($string);
	}

	return $string;
}
		 		





// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// функция восстанавливает в полученной строке дубликаты кавычек и кавычки по краям, 
// если изначально были такие дубликаты в строке
function zp_restore_quotes($string)
{
	// проверим, нет ли в полученной строке кавычек
	// и если есть, заменим одну на две и добавим по одной по краям
	 			
	
	if(strpos($string, '"') !== FALSE)
	{
		$string = str_replace('"', '""', $string);
		$string = '"' . $string . '"';
	}
			 			
	return $string;
}


















// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// функция изменения видимости элемента -------------------------------------------------

function zp_item_hide_and_unhide($shop_item, $action)
{
				// сбрасываем флаг действия
				$shop_item['Действие / результат'] = '';
				
				
	
				// создатим новый объект типа нода, в который будем заносить некоторые необходимые данные по элементу
				$node = new stdClass();
				// и вспомогательный объект $zp_element для прочих данных по элементу
				$zp_element = array();
				
				
				// если значение поля содержит тип (в формате "значение***тип"), выясняем этот тип
				//$value = $shop_item['Тип записи'];
				$zp_element['type'] = zp_correct_quotes($shop_item['Тип записи']);
				
				//echo ' >>> type = ' . $zp_element['type'] . ', type of type = ' . $zp_element['type_of_type'];
				
				$zp_element['type_of_type'] = strpos($zp_element['type'], '***');
  				if($zp_element['type_of_type'] !== false) 
  				{
				  $zp_element['type_of_type'] = explode('***', $zp_element['type']);
				  $zp_element['type'] = $zp_element['type_of_type'][0];
				  $zp_element['type_of_type'] = $zp_element['type_of_type'][1];
				} 
				
				//echo 'shop_item[Тип записи] = ' . $shop_item['Тип записи'] . ', value = ' . $value . ', value_type = ' . $zp_element['type_of_type'];
				
				// уберём в полученных строках дубликаты кавычек и кавычки по краям
		 		$zp_element['type'] = $zp_element['type'];
		 		$zp_element['type_of_type'] = $zp_element['type_of_type'];
		 		
		 		
	
				// если не задан тип элемента, выходим
				if(!$zp_element['type'] OR $zp_element['type'] == '' OR $zp_element['type'] == ' ')
				{
					$shop_item['Действие / результат'] = 'hide-unhide error: не указан тип элемента'; 
						return $shop_item;
				}
				
				echo ' >>>2 type = ' . $zp_element['type'] . ', type of type = ' . $zp_element['type_of_type'];
				
				// правильно ли указан тип элемента?
				switch($zp_element['type'])
				{
					case 'страна':
					case 'населённый пункт':
					case 'район':
					case 'магазин':
					case 'подотдел':
					case 'товар': 
						break; 
						
					case 'подгруппа':
						$shop_item['Действие / результат'] = 'hide-unhide error: подгруппу нельзя скрыть или показать. Скрыть можно только реальные элементы (страна, город, район, магазин, подотдел, товар)'; 
						return $shop_item;
						
					default:
						$shop_item['Действие / результат'] = 'hide-unhide error: указан неизвестный или неправильный тип элемента'; 
						return $shop_item;
				}

							
				echo ' >>>2 type = ' . $zp_element['type'] . ', type of type = ' . $zp_element['type_of_type'];
				
				
				/*
				// если не задан тип элемента, выходим
				if(!$zp_element['type'] == 'товар' AND (!$zp_element['type_of_type'] OR $zp_element['type_of_type'] == '' OR $zp_element['type_of_type'] == ' '))
				{
					$shop_item['Действие / результат'] = 'hide-unhide error: не указан тип товара';
						return $shop_item;
				}
				*/
				
				echo ' >>>2 type = ' . $zp_element['type'] . ', type of type = ' . $zp_element['type_of_type'];
				
				
				// проверим, есть ли какие-либо изменения в элементе
				$changes_exists = 0;
				$shop_item_changed = array();
				foreach ($shop_item as $key => $value)
				{
					//echo '---key = ' . $key . ', value = ' . $value . '<br>';
					
					// исправим лишние кавычки, если есть
					$value = zp_correct_quotes($value);
					
					/* // на всякий случай все поля добавляем в промежуточный массив... всё равно лишние поля не обрабатываются...
					
					// данные по артикулу не добавляем в промежуточный массив
				    if($key == 'Страна' OR
					   $key == 'Город' OR
					   $key == 'Район' OR
					   $key == 'Магазин' OR
					   $key == 'Подотдел' OR
					   //$key == 'Подгруппа / тип элемента' OR  // это поле используется не только при изменении артикулов, поэтому его тоже добавляем в общий массив
					   $key == 'Товар / родительский подотдел'
					  )
					continue; 
					*/

				//echo ' >>> key = ' . $key . ', value = ' . $value . '<br>';
					
					
					if($value[0] . $value[1] . $value[2] == '###')
					{	
						$shop_item_changed[$key] = $value;
						//echo '---shop_item_changed[key] = ' . $shop_item_changed[$key] . ', where key = ' . $key;
		  				$changes_exists = 1;
		  				
		  				// пометим, были ли изменения в артикуле и связях
					}
				}
					
				echo ' >>>2 type = ' . $zp_element['type'] . ', type of type = ' . $zp_element['type_of_type'];
				
				// если изменений нет, выходим
				if($changes_exists)
				{
					$shop_item['Действие / результат'] = 'hide-unhide error: элемент содержит указания к изменению в некоторых полях. Сначала очистите указания к изменениям, а затем показывайте или прячьте элемент элемент';
						return $shop_item;
				}
				
				
				echo ' >>>2 type = ' . $zp_element['type'] . ', type of type = ' . $zp_element['type_of_type'];

				
				
				
				echo '_zp_element[type] = ' . $zp_element['type'] . '<br>';
				
				
				
				$artikul_changes_exists = 0;
				$new_value_with_history = array();
				
				// перебираем все поля из артикула и выясним текущие значения номеров артикула
				foreach ($shop_item as $key => $value)
				{
					// работаем только с полями артикула
					if($key != 'Страна' AND
					   $key != 'Город' AND
					   $key != 'Район' AND
					   $key != 'Магазин' AND
					   $key != 'Подотдел' AND
					   $key != 'Подгруппа / тип элемента' AND
					   $key != 'Товар / родительский подотдел'
					  )
					continue;
					
					
					// исправим лишние кавычки, если есть
					$value = zp_correct_quotes($value);
				
					
		 			if(strpos($value, '###') !== FALSE) // управляющие символы в середине строки
		 			{
		 				$value = explode('###', $value);
		   	
			
						//$value_old = $value[1];
						$value = $value[0];
						$value_old = $value;
						
						echo ' hist --- key = ' . $key . ', new value = ' . $value . ', old value = ' . $value_old . '<br>';
						
		 			}
		 			else 
		 			{
		 				$value_old = $value;
		 			}
		 		
		 			
		 			
		 			// уберём в полученной строке дубликаты кавычек и кавычки по краям
		 			// и сохраним в массив 
		 			
		 			$zp_new_artikuls[$key] = $value;
		 			$zp_old_artikuls[$key] = $value_old;
		 			
		 			//if(!$zp_old_artikuls[$key])
		 			  //$zp_old_artikuls[$key] = $zp_new_artikuls[$key]; // если старое значение в истории не задано (например в виде ###однозначение), приравниваем старое значение к новому значению
					
		 			
				} // end of foreach ($shop_item as $key => $value) // перебираем все поля из артикула  и выясним новые и старые значения номеров артикула
				
				
				echo '_zp_element[type] = ' . $zp_element['type'] . '<br>';
				
				foreach($zp_new_artikuls as $key => $value)
				{
					
					echo ' <<<<<<< key = ' . $key . ', new value = ' . $value . '<br>';
					echo ' > old value = ' . $zp_old_artikuls[$key] . '<br>'; 
					//echo ' > value with history = ' . $new_value_with_history[$key] . '<br>'; 
				}
				
				//echo ' >>>key = ' . $key . ', value = ' . $value . ', art_changed = ' . $artikul_changes_exists . '<br>';				
				
				echo '_zp_element[type] = ' . $zp_element['type'] . '<br>';
				
				// выясним название элемента, (пока старое, если необходимы изменения)

				// исправим лишние кавычки, если есть
				$value = zp_correct_quotes($shop_item['Название']);
					
				
		 		if(strpos($value, '###') !== FALSE) // управляющие символы в середине строки
		 		{
		 			$value = explode('###', $value);
					$value = $value[0];
		 		}

		 			
		 		echo '_zp_element[type] = ' . $zp_element['type'] . '<br>';
		 		
				$zp_element['название'] = $value;
					
				//if(!$zp_element['старое_название'])
				 //$zp_element['старое_название'] = $zp_element['новое_название']; // если в таблице не задано старое название, приравниваем его новому
				
				
				echo ' ===new name = ' . $zp_element['название'] . ', history value = ';				
				
				
				
				
				echo '_zp_element[type] = ' . $zp_element['type'];
				
								
				
				

				
				// Определим артикулы для элементов разных типов и их стрые и новые (если заданы) родительские артикулы
				// а также зададим некоторые основные переменные и значения
				switch($zp_element['type'])
				{
					case 'страна':
						
						// если заданы не все составляющие артикула места (и, соответственно, местоположения места)
						// выходим из подпрограммы с указанием ошибки в поле "действие / результат"
						if(!$zp_old_artikuls['Страна'])
						 {
						 	$shop_item['Действие / результат'] = 'hide-unhide error: неправильно указан исходный артикул страны'; 
							return $shop_item;
						 }
						
						// выясним старый и новый артикулы страны
						$zp_element['zp_artikul'] = 'z' . $zp_new_artikuls['Страна']; 
					
						//$node->type = 'c_country';						
						
						//$zp_element['pics_field'] = 'country_img';
						//$zp_element['pics_path'] = 'country_img';
						
						break;	
						
						
					case 'населённый пункт': // обычно город
					
						if(!$zp_old_artikuls['Страна'] OR !$zp_old_artikuls['Город'])
						 {
						 	$shop_item['Действие / результат'] = 'hide-unhide error: неправильно указан исходный артикул населённого пункта' ; 
							return $shop_item;
						 }
				
	
						// выясним старый и новый артикулы города
						$zp_element['zp_artikul'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город']; 
								
						// выясним новый и старый артикулы родительской страны
						//$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна']; 

						
						//$node->type = 'c_city';
						
						//$zp_element['pics_field'] = 'city_img';
						//$zp_element['pics_path'] = 'city_img';
						
						break;
						
						
					case 'район':
						
						if(!$zp_old_artikuls['Страна'] OR !$zp_old_artikuls['Город'] OR !$zp_old_artikuls['Район'])
						 {
						 	$shop_item['Действие / результат'] = 'hide-unhide error: неправильно указан исходный артикул района' ; 
							return $shop_item;
						 }
						
						// выясним старый и новый артикулы района
						$zp_element['zp_artikul'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район']; 
								
						// выясним новый и старый артикулы родительского города
						//$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город']; 
						
						//$node->type = 'c_rajon';
						
						//$zp_element['pics_field'] = 'rajon_img';
						//$zp_element['pics_path'] = 'rajon_img';
						
						break;
						
					
					case 'магазин':
						
						if(!$zp_old_artikuls['Страна'] OR !$zp_old_artikuls['Город'] OR !$zp_old_artikuls['Район'] OR !$zp_old_artikuls['Магазин'])
						 {
						 	$shop_item['Действие / результат'] = 'hide-unhide error: неправильно указан исходный артикул магазина' ; 
							return $shop_item;
						 }
						
						// выясним старый и новый артикулы магазина
						$zp_element['zp_artikul'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин']; 
							
						// выясним новый и старый артикулы родительского района 
						//$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район']; 
						
						//$node->type = 'c_shop';
						
						//$zp_element['pics_field'] = 'shop_img';
						//$zp_element['pics_path'] = 'shop_img';
						
						break;
						
						
					case 'подотдел':
								
						
						if(!$zp_old_artikuls['Страна'] OR !$zp_old_artikuls['Город'] OR !$zp_old_artikuls['Район'] OR !$zp_old_artikuls['Магазин'] OR !$zp_old_artikuls['Подотдел'] OR !$zp_old_artikuls['Товар / родительский подотдел'])
						 {
						 	$shop_item['Действие / результат'] = 'hide-unhide error: неправильно указан исходный артикул подотдела' ; 
							return $shop_item;
						 }
						
						// выясним старый и новый артикулы подотдела
						$zp_element['zp_artikul'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин'] . $zp_new_artikuls['Подотдел']; 
								
						
						//if($zp_new_artikuls['Товар / родительский подотдел'] == '000')
							//$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин']; 
						//else
							//$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин'] . $zp_new_artikuls['Товар / родительский подотдел']; 

						
						//$zp_element['родительский подотдел'] = $zp_new_artikuls['Товар / родительский подотдел']; // проверить, где используется эта переменная и нужна ли она вообще
						
						//$node->type = 'c_department';
						
						//$zp_element['pics_field'] = 'dept_img';
						//$zp_element['pics_path'] = 'dept_img';
							
						break;
						
						
					case 'подгруппа':	

						
						break;		
						
					
					case 'товар':
						
						if(!$zp_old_artikuls['Страна'] OR !$zp_old_artikuls['Город'] OR !$zp_old_artikuls['Район'] OR !$zp_old_artikuls['Магазин'] OR !$zp_old_artikuls['Подотдел'] OR !$zp_old_artikuls['Подгруппа / тип элемента'] OR !$zp_old_artikuls['Товар / родительский подотдел'])
						 {
						 	$shop_item['Действие / результат'] = 'hide-unhide error: не заданы какие-то из номеров местоположения и товара для формирования внутреннего артикула zp'; 
							return $shop_item;
						 }
						 

						// выясним старый и новый артикулы товара
						$zp_element['zp_artikul'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин'] . $zp_new_artikuls['Подотдел'] . $zp_new_artikuls['Товар / родительский подотдел']; 
						
						$node->model = $zp_element['zp_artikul']; // заранее установим новый артикул, так как на следующем шаге будет произведено изменение артикула, если оно задано в таблице
								
						// выясним новый и старый артикулы родительского отдела 
						//$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин'] . $zp_new_artikuls['Подотдел']; 

						
						// то же самое, но по-другому называется... для совместимости.. вроде где-то дальше используется такая переменная
						// задаём сразу новые значения, так как они будут изменены на следующем шаге
						//$zp_element['parent_otdel_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин'] . $zp_new_artikuls['Подотдел'];
						
						/*
						// в зависимости от типа товара (который указан через *** от слова "товар") зададим типа ноды для товара
						switch($zp_element['type_of_type'])
						{
							case 'продукты':
								$node->type = 'product_food';
								//$zp_element['pics_field'] = 'p_food_img';
								$zp_element['pics_path'] = 'p_food_img';
								break;	
								
							case 'вещи':
								$node->type = 'product_clothes';
								//$zp_element['pics_field'] = 'p_clothes_img';
								$zp_element['pics_path'] = 'p_clothes_img';
								
								break;
									
							default:
								// иначе тип товара не определён в системе
								$shop_item['Действие / результат'] = 'del error: тип продукта ' . $zp_element['type_of_type'] . ' не определён в системе';
								return $shop_item;
								
						} // end of в зависимости от типа товара (который указан через *** от слова "товар") зададим типа ноды для товара
						*/
						
						break;		
					
									

					default:
						break;
					
				}
				
				
				
				// определим нид и некоторые другие данные текущего элемента, в зависимости от его типа
				switch($zp_element['type'])
				{
					case 'страна':
					case 'населённый пункт': // обычно город
					case 'район':
					case 'магазин':
					case 'подотдел':
					
						// определим нид текущего элемента по старому артикулу
						//$element_nid = db_result(db_query("SELECT nid from {content_field_zp_art_place} WHERE field_zp_art_place_value = '%s'", $zp_element['zp_old_artikul']));
					
						$element_nid = db_fetch_object(db_query("SELECT nid, vid from {content_field_zp_art_place} WHERE field_zp_art_place_value = '%s'", $zp_element['zp_artikul']));
						
						$node->vid = $element_nid->vid; 
						$node->nid = $element_nid->nid;
						 
						echo '------------- node->vid = ' . $node->vid . ', node->nid = ' . $node->nid . '<br>';
						
						
						
						if(!$node->nid OR !$node->vid)
						{
							$shop_item['Действие / результат'] = 'hide-unhide error: ошибка при чтении базы данных или нет элемента с таким артикулом ' . $zp_element['zp_artikul'] . ' в базе'; 
							return $shop_item;
						}
						
						
						$element_nid = $element_nid->nid;
						
						/*
						
						// определим тид текущего элемента
						$element_tids = taxonomy_node_get_terms_by_vocabulary($element_nid, 1);
   						foreach($element_tids as $element_tid)
    					{
     						$element_tid_name = $element_tid->name;
     						$element_tid = $element_tid->tid;
    					}
    					*/
    					
    					echo '------------- element_tid = ' . $element_tid . '<br>';
						
    					
						break;	
					
						
					case 'подгруппа':

											
						break;
						
						
						
						
					case 'товар':	
						
						
						$element_nid = db_fetch_object(db_query("SELECT nid, vid from {uc_products} WHERE model = '%s'", $zp_element['zp_artikul']));
						
						$node->vid = $element_nid->vid; 
						$node->nid = $element_nid->nid;
						 
						if(!$node->nid OR !$node->vid)
						{
							$shop_item['Действие / результат'] = 'hide-unhide error: ошибка при чтении базы данных или нет товара с таким артикулом ' . $zp_element['zp_artikul'] . ' в базе'; 
							return $shop_item;
						}
						
						$element_nid = $element_nid->nid;
									
						break;
						
						
					default:
						break;	
				
				}
				
				
				
				
				
				
				
				// на данном этапе изместно, что элемент есть
				
				echo '<br>Можно изменять видимость элемента!<br>';
				
				switch($zp_element['type'])
				{

					case 'страна':
					case 'населённый пункт': // обычно город
					case 'район':
					case 'магазин':
					case 'подотдел':
					case 'товар':
					
						if($action == 'hide')
						{
							// проверим, а не спрятан ли уже этот элемент (судя по таблице)
							//if($shop_item['Состояние элемента'] == 'hidden')
							
							// или лучше судя по базе
							if(db_result(db_query("SELECT status from {node} WHERE nid = %d", $element_nid)) != 1)
							{
								$shop_item['Действие / результат'] = 'hide-unhide error: элемент с таким артикулом ' . $zp_element['zp_artikul'] . ' и так уже спрятан.'; 
								return $shop_item;
							}
							
							
							// изменяем статус элемента в базе
							db_query("UPDATE {node} SET status = %d WHERE nid = %d", 0, $element_nid);
							
							
							// прячем пункт меню, связанный с этим элементом
							
							// вясним номер тида из каталога, связанный с этим элементом
							$element_tids = taxonomy_node_get_terms_by_vocabulary($element_nid, 1);
   							foreach($element_tids as $element_tid)
    						{
     							//$element_tid_name = $element_tid->name;
     							$element_tid = $element_tid->tid;
    						}
    						
    						// временно изменим тид на тид+0000
							$new_tid = $element_tid . '0000';
							db_query("UPDATE {term_data} SET tid = %d WHERE tid = %d", $new_tid, $element_tid);
							
							
							// привяжем к этому новому тиду текущий нид (чтобы не потерять номер тида и потом его восстановить)
							db_query("UPDATE {term_node} SET tid = %d WHERE tid = %d AND nid = %d ", $new_tid, $element_tid, $element_nid);
							
							// очистим поле в таблице, показывая, что элемент не спрятан
							$shop_item['Состояние элемента'] = 'hidden';
							
						}	
						else if($action == 'unhide')
						{
							// проверим, а не показан ли уже этот элемент (судя по таблице)
							//if($shop_item['Состояние элемента'] != 'hidden')
							
							// или лучше судя по базе
							if(db_result(db_query("SELECT status from {node} WHERE nid = %d", $element_nid)) == 1)
							{
								$shop_item['Действие / результат'] = 'hide-unhide error: элемент с таким артикулом ' . $zp_element['zp_artikul'] . ' и так не спрятан.'; 
								return $shop_item;
							}
							
							// изменяем статус элемента в базе
							db_query("UPDATE {node} SET status = %d WHERE nid = %d", 1, $element_nid);
							
							
							// восстанавливаем пункт меню, связанный с этим элементом
							
							// вясним номер тида из каталога, связанный с этим элементом
							$element_tids = taxonomy_node_get_terms_by_vocabulary($node->nid, 1);
   							foreach($element_tids as $element_tid)
    						{
     							$element_tid_name = $element_tid->name;
     							$element_tid = $element_tid->tid;
    						}
    						
							// восстановим оригинальное значение тида, которое в изменённом виде сейчас должно иметь вид в базе "исходный тид+0000"
    						// вычислим длину и уберём последние четыре символа
							$lenght = strlen($element_tid);
							for($count = 1; $count <= ($lenght - 4); $count++ )
							{
								$new_tid = $new_tid . $element_tid[$count-1]; // $count-1 потому, что нумерация в массиве идёт от нуля, а количество символов массива считаем от единицы
						    }
						    
						    // запишем в базу восстановленный тид
						    db_query("UPDATE {term_data} SET tid = %d WHERE tid = %d", $new_tid, $element_tid);
							
							
							// привяжем к этому восстановленному тиду текущий нид
							db_query("UPDATE {term_node} SET tid = %d WHERE tid = %d AND nid = %d ", $new_tid, $element_tid, $element_nid);
							

							
							// укажем в поле в таблице, что элемент спрятан
							$shop_item['Состояние элемента'] = '';
						}
		
						break;
	  		  
					default: 
						break;
				}
				
				
				
				

	
	echo '<br>Изменение видимости элемента произведено произведено успешно!<br>';

	
	return $shop_item;
				
}				

























// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// функция удаления элемента ------------------------------------------------------------

function zp_item_delete($shop_item)
{
				// сбрасываем флаг действия
				$shop_item['Действие / результат'] = '';
				
				
	
				// создатим новый объект типа нода, в который будем заносить некоторые необходимые данные по элементу
				$node = new stdClass();
				// и вспомогательный объект $zp_element для прочих данных по элементу
				$zp_element = array();
				
				
				// если значение поля содержит тип (в формате "значение***тип"), выясняем этот тип
				//$value = $shop_item['Тип записи'];
				$zp_element['type'] = zp_correct_quotes($shop_item['Тип записи']);
				
				//echo ' >>> type = ' . $zp_element['type'] . ', type of type = ' . $zp_element['type_of_type'];
				
				$zp_element['type_of_type'] = strpos($zp_element['type'], '***');
  				if($zp_element['type_of_type'] !== false) 
  				{
				  $zp_element['type_of_type'] = explode('***', $zp_element['type']);
				  $zp_element['type'] = $zp_element['type_of_type'][0];
				  $zp_element['type_of_type'] = $zp_element['type_of_type'][1];
				} 
				
				//echo 'shop_item[Тип записи] = ' . $shop_item['Тип записи'] . ', value = ' . $value . ', value_type = ' . $zp_element['type_of_type'];
				
				// уберём в полученных строках дубликаты кавычек и кавычки по краям
		 		$zp_element['type'] = $zp_element['type'];
		 		$zp_element['type_of_type'] = $zp_element['type_of_type'];
		 		
		 		
	
				// если не задан тип элемента, выходим
				if(!$zp_element['type'] OR $zp_element['type'] == '' OR $zp_element['type'] == ' ')
				{
					$shop_item['Действие / результат'] = 'del error: не указан тип элемента'; 
						return $shop_item;
				}
				
				echo ' >>>2 type = ' . $zp_element['type'] . ', type of type = ' . $zp_element['type_of_type'];
				
				// правильно ли указан тип элемента?
				switch($zp_element['type'])
				{
					case 'страна':
					case 'населённый пункт':
					case 'район':
					case 'магазин':
					case 'подотдел':
					case 'подгруппа':
					case 'товар': 
						break; 
						
					default:
						$shop_item['Действие / результат'] = 'del error: указан неизвестный или неправильный тип элемента'; 
						return $shop_item;
				}

							
				echo ' >>>2 type = ' . $zp_element['type'] . ', type of type = ' . $zp_element['type_of_type'];
				
				// если не задан тип элемента, выходим
				if(!$zp_element['type'] == 'товар' AND (!$zp_element['type_of_type'] OR $zp_element['type_of_type'] == '' OR $zp_element['type_of_type'] == ' '))
				{
					$shop_item['Действие / результат'] = 'del error: не указан тип товара';
						return $shop_item;
				}
				
				echo ' >>>2 type = ' . $zp_element['type'] . ', type of type = ' . $zp_element['type_of_type'];
				
				
				// проверим, есть ли какие-либо изменения в элементе
				$changes_exists = 0;
				$shop_item_changed = array();
				foreach ($shop_item as $key => $value)
				{
					//echo '---key = ' . $key . ', value = ' . $value . '<br>';
					
					// исправим лишние кавычки, если есть
					$value = zp_correct_quotes($value);
					
					/* // на всякий случай все поля добавляем в промежуточный массив... всё равно лишние поля не обрабатываются...
					
					// данные по артикулу не добавляем в промежуточный массив
				    if($key == 'Страна' OR
					   $key == 'Город' OR
					   $key == 'Район' OR
					   $key == 'Магазин' OR
					   $key == 'Подотдел' OR
					   //$key == 'Подгруппа / тип элемента' OR  // это поле используется не только при изменении артикулов, поэтому его тоже добавляем в общий массив
					   $key == 'Товар / родительский подотдел'
					  )
					continue; 
					*/

				//echo ' >>> key = ' . $key . ', value = ' . $value . '<br>';
					
					
					if($value[0] . $value[1] . $value[2] == '###')
					{	
						$shop_item_changed[$key] = $value;
						//echo '---shop_item_changed[key] = ' . $shop_item_changed[$key] . ', where key = ' . $key;
		  				$changes_exists = 1;
		  				
		  				// пометим, были ли изменения в артикуле и связях
					}
				}
					
				echo ' >>>2 type = ' . $zp_element['type'] . ', type of type = ' . $zp_element['type_of_type'];
				
				// если изменений нет, выходим
				if($changes_exists)
				{
					$shop_item['Действие / результат'] = 'del error: элемент содержит указания к изменению в некоторых полях. Сначала очистите указания к изменениям, а затем удаляйте элемент';
						return $shop_item;
				}
				
				
				echo ' >>>2 type = ' . $zp_element['type'] . ', type of type = ' . $zp_element['type_of_type'];

				
				
				
				echo '_zp_element[type] = ' . $zp_element['type'] . '<br>';
				
				
				
				$artikul_changes_exists = 0;
				$new_value_with_history = array();
				
				// перебираем все поля из артикула и выясним текущие значения номеров артикула
				foreach ($shop_item as $key => $value)
				{
					// работаем только с полями артикула
					if($key != 'Страна' AND
					   $key != 'Город' AND
					   $key != 'Район' AND
					   $key != 'Магазин' AND
					   $key != 'Подотдел' AND
					   $key != 'Подгруппа / тип элемента' AND
					   $key != 'Товар / родительский подотдел'
					  )
					continue;
					
					
					// исправим лишние кавычки, если есть
					$value = zp_correct_quotes($value);
				
					
		 			if(strpos($value, '###') !== FALSE) // управляющие символы в середине строки
		 			{
		 				$value = explode('###', $value);
		   	
			
						//$value_old = $value[1];
						$value = $value[0];
						$value_old = $value;
						
						echo ' hist --- key = ' . $key . ', new value = ' . $value . ', old value = ' . $value_old . '<br>';
						
		 			}
		 			else 
		 			{
		 				$value_old = $value;
		 			}
		 		
		 			
		 			
		 			// уберём в полученной строке дубликаты кавычек и кавычки по краям
		 			// и сохраним в массив 
		 			
		 			$zp_new_artikuls[$key] = $value;
		 			$zp_old_artikuls[$key] = $value_old;
		 			
		 			//if(!$zp_old_artikuls[$key])
		 			  //$zp_old_artikuls[$key] = $zp_new_artikuls[$key]; // если старое значение в истории не задано (например в виде ###однозначение), приравниваем старое значение к новому значению
					
		 			
				} // end of foreach ($shop_item as $key => $value) // перебираем все поля из артикула  и выясним новые и старые значения номеров артикула
				
				
				echo '_zp_element[type] = ' . $zp_element['type'] . '<br>';
				
				foreach($zp_new_artikuls as $key => $value)
				{
					
					echo ' <<<<<<< key = ' . $key . ', new value = ' . $value . '<br>';
					echo ' > old value = ' . $zp_old_artikuls[$key] . '<br>'; 
					//echo ' > value with history = ' . $new_value_with_history[$key] . '<br>'; 
				}
				
				//echo ' >>>key = ' . $key . ', value = ' . $value . ', art_changed = ' . $artikul_changes_exists . '<br>';				
				
				echo '_zp_element[type] = ' . $zp_element['type'] . '<br>';
				
				// выясним название элемента, (пока старое, если необходимы изменения)

				// исправим лишние кавычки, если есть
				$value = zp_correct_quotes($shop_item['Название']);
					
				
		 		if(strpos($value, '###') !== FALSE) // управляющие символы в середине строки
		 		{
		 			$value = explode('###', $value);
					$value = $value[0];
		 		}

		 			
		 		echo '_zp_element[type] = ' . $zp_element['type'] . '<br>';
		 		
				$zp_element['название'] = $value;
					
				//if(!$zp_element['старое_название'])
				 //$zp_element['старое_название'] = $zp_element['новое_название']; // если в таблице не задано старое название, приравниваем его новому
				
				
				echo ' ===new name = ' . $zp_element['название'] . ', history value = ';				
				
				
				
				
				echo '_zp_element[type] = ' . $zp_element['type'];
				
								
				
				

				
				// Определим артикулы для элементов разных типов и их стрые и новые (если заданы) родительские артикулы
				// а также зададим некоторые основные переменные и значения
				switch($zp_element['type'])
				{
					case 'страна':
						
						// если заданы не все составляющие артикула места (и, соответственно, местоположения места)
						// выходим из подпрограммы с указанием ошибки в поле "действие / результат"
						if(!$zp_old_artikuls['Страна'])
						 {
						 	$shop_item['Действие / результат'] = 'del error: неправильно указан исходный артикул страны'; 
							return $shop_item;
						 }
						
						// выясним старый и новый артикулы страны
						$zp_element['zp_artikul'] = 'z' . $zp_new_artikuls['Страна']; 
					
						//$node->type = 'c_country';						
						
						//$zp_element['pics_field'] = 'country_img';
						//$zp_element['pics_path'] = 'country_img';
						
						break;	
						
						
					case 'населённый пункт': // обычно город
					
						if(!$zp_old_artikuls['Страна'] OR !$zp_old_artikuls['Город'])
						 {
						 	$shop_item['Действие / результат'] = 'del error: неправильно указан исходный артикул населённого пункта' ; 
							return $shop_item;
						 }
				
	
						// выясним старый и новый артикулы города
						$zp_element['zp_artikul'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город']; 
								
						// выясним новый и старый артикулы родительской страны
						$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна']; 

						
						//$node->type = 'c_city';
						
						//$zp_element['pics_field'] = 'city_img';
						//$zp_element['pics_path'] = 'city_img';
						
						break;
						
						
					case 'район':
						
						if(!$zp_old_artikuls['Страна'] OR !$zp_old_artikuls['Город'] OR !$zp_old_artikuls['Район'])
						 {
						 	$shop_item['Действие / результат'] = 'del error: неправильно указан исходный артикул района' ; 
							return $shop_item;
						 }
						
						// выясним старый и новый артикулы района
						$zp_element['zp_artikul'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район']; 
								
						// выясним новый и старый артикулы родительского города
						$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город']; 
						
						//$node->type = 'c_rajon';
						
						//$zp_element['pics_field'] = 'rajon_img';
						//$zp_element['pics_path'] = 'rajon_img';
						
						break;
						
					
					case 'магазин':
						
						if(!$zp_old_artikuls['Страна'] OR !$zp_old_artikuls['Город'] OR !$zp_old_artikuls['Район'] OR !$zp_old_artikuls['Магазин'])
						 {
						 	$shop_item['Действие / результат'] = 'del error: неправильно указан исходный артикул магазина' ; 
							return $shop_item;
						 }
						
						// выясним старый и новый артикулы магазина
						$zp_element['zp_artikul'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин']; 
							
						// выясним новый и старый артикулы родительского района 
						$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район']; 
						
						//$node->type = 'c_shop';
						
						//$zp_element['pics_field'] = 'shop_img';
						//$zp_element['pics_path'] = 'shop_img';
						
						break;
						
						
					case 'подотдел':
								
						
						if(!$zp_old_artikuls['Страна'] OR !$zp_old_artikuls['Город'] OR !$zp_old_artikuls['Район'] OR !$zp_old_artikuls['Магазин'] OR !$zp_old_artikuls['Подотдел'] OR !$zp_old_artikuls['Товар / родительский подотдел'])
						 {
						 	$shop_item['Действие / результат'] = 'del error: неправильно указан исходный артикул подотдела' ; 
							return $shop_item;
						 }
						
						// выясним старый и новый артикулы подотдела
						$zp_element['zp_artikul'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин'] . $zp_new_artikuls['Подотдел']; 
								
						
						if($zp_new_artikuls['Товар / родительский подотдел'] == '000')
							$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин']; 
						else
							$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин'] . $zp_new_artikuls['Товар / родительский подотдел']; 

						
						$zp_element['родительский подотдел'] = $zp_new_artikuls['Товар / родительский подотдел']; // проверить, где используется эта переменная и нужна ли она вообще
						
						//$node->type = 'c_department';
						
						//$zp_element['pics_field'] = 'dept_img';
						//$zp_element['pics_path'] = 'dept_img';
							
						break;
						
						
					case 'подгруппа':	
						
						echo 'Страна = ' . $zp_old_artikuls['Страна'] . '<br>'; 
						echo 'Город = ' . $zp_old_artikuls['Город'] . '<br>'; 
						echo 'Район = ' . $zp_old_artikuls['Район'] . '<br>'; 
						echo 'Магазин = ' . $zp_old_artikuls['Магазин'] . '<br>'; 
						echo 'Подотдел = ' . $zp_old_artikuls['Подотдел'] . '<br>'; 
						echo 'старое название = ' . $zp_element['старое_название'] . '<br>';
						
						//return;

						if(!$zp_old_artikuls['Страна'] OR !$zp_old_artikuls['Город'] OR !$zp_old_artikuls['Район'] OR !$zp_old_artikuls['Магазин'] OR !$zp_old_artikuls['Подотдел'] OR !$zp_element['название'])
						 {
						 	$shop_item['Действие / результат'] = 'del error: неправильно указан исходный артикул и/или название подгруппы'; 
							return $shop_item;
						 }	
						
						// выясним новый и старый артикулы родительского отдела 
						$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин'] . $zp_new_artikuls['Подотдел']; 
						
						break;		
						
					
					case 'товар':
						
						if(!$zp_old_artikuls['Страна'] OR !$zp_old_artikuls['Город'] OR !$zp_old_artikuls['Район'] OR !$zp_old_artikuls['Магазин'] OR !$zp_old_artikuls['Подотдел'] OR !$zp_old_artikuls['Подгруппа / тип элемента'] OR !$zp_old_artikuls['Товар / родительский подотдел'])
						 {
						 	$shop_item['Действие / результат'] = 'del error: не заданы какие-то из номеров местоположения и товара для формирования внутреннего артикула zp'; 
							return $shop_item;
						 }
						 

						// выясним старый и новый артикулы товара
						$zp_element['zp_artikul'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин'] . $zp_new_artikuls['Подотдел'] . $zp_new_artikuls['Товар / родительский подотдел']; 
						
						$node->model = $zp_element['zp_artikul']; // заранее установим новый артикул, так как на следующем шаге будет произведено изменение артикула, если оно задано в таблице
								
						// выясним новый и старый артикулы родительского отдела 
						$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин'] . $zp_new_artikuls['Подотдел']; 

						
						// то же самое, но по-другому называется... для совместимости.. вроде где-то дальше используется такая переменная
						// задаём сразу новые значения, так как они будут изменены на следующем шаге
						$zp_element['parent_otdel_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин'] . $zp_new_artikuls['Подотдел'];
						
						/*
						// в зависимости от типа товара (который указан через *** от слова "товар") зададим типа ноды для товара
						switch($zp_element['type_of_type'])
						{
							case 'продукты':
								$node->type = 'product_food';
								//$zp_element['pics_field'] = 'p_food_img';
								$zp_element['pics_path'] = 'p_food_img';
								break;	
								
							case 'вещи':
								$node->type = 'product_clothes';
								//$zp_element['pics_field'] = 'p_clothes_img';
								$zp_element['pics_path'] = 'p_clothes_img';
								
								break;
									
							default:
								// иначе тип товара не определён в системе
								$shop_item['Действие / результат'] = 'del error: тип продукта ' . $zp_element['type_of_type'] . ' не определён в системе';
								return $shop_item;
								
						} // end of в зависимости от типа товара (который указан через *** от слова "товар") зададим типа ноды для товара
						*/
						
						break;		
					
									

					default:
						break;
					
				}
				
				
				
				// определим нид и некоторые другие данные текущего элемента, в зависимости от его типа
				switch($zp_element['type'])
				{
					case 'страна':
					case 'населённый пункт': // обычно город
					case 'район':
					case 'магазин':
					case 'подотдел':
					
						// определим нид текущего элемента по старому артикулу
						//$element_nid = db_result(db_query("SELECT nid from {content_field_zp_art_place} WHERE field_zp_art_place_value = '%s'", $zp_element['zp_old_artikul']));
					
						$element_nid = db_fetch_object(db_query("SELECT nid, vid from {content_field_zp_art_place} WHERE field_zp_art_place_value = '%s'", $zp_element['zp_artikul']));
						
						$node->vid = $element_nid->vid; 
						$node->nid = $element_nid->nid;
						 
						echo '------------- node->vid = ' . $node->vid . ', node->nid = ' . $node->nid . '<br>';
						
						
						
						if(!$node->nid OR !$node->vid)
						{
							$shop_item['Действие / результат'] = 'del error: ошибка при чтении базы данных или нет элемента с таким артикулом ' . $zp_element['zp_artikul'] . ' в базе'; 
							return $shop_item;
						}
						
						$element_nid = $element_nid->nid;
						
						
						
						// определим тид текущего элемента
						$element_tids = taxonomy_node_get_terms_by_vocabulary($element_nid, 1);
   						foreach($element_tids as $element_tid)
    					{
     						$element_tid_name = $element_tid->name;
     						$element_tid = $element_tid->tid;
    					}
    					
    					
    					echo '------------- element_tid = ' . $element_tid . '<br>';
						
    					
						break;	
					
						
					case 'подгруппа':

						// определим нид текущего (старого) родительского отдела
						$parent_otdel_nid = db_fetch_object(db_query("SELECT nid, vid from {content_field_zp_art_place} WHERE field_zp_art_place_value = '%s'", $zp_element['parent_zp_art']));
						
						$parent_otdel_vid = $parent_otdel_nid->vid; 
						$parent_otdel_nid = $parent_otdel_nid->nid;
						 
						if(!$parent_otdel_nid OR !$parent_otdel_vid)
						{
							$shop_item['Действие / результат'] = 'del error: ошибка при чтении базы данных или нет подотдела (заданного как родитель удаляемой подгруппы) с таким артикулом ' . $zp_element['parent_zp_art'] . ' в базе'; 
							return $shop_item;
						}
						
						


	  		  			$parent_otdel_name = db_result(db_query("SELECT title from {node} WHERE nid = %d", $parent_otdel_nid));
									
						// определим тид текущего  родительского отдела
						$parent_otdel_tids = taxonomy_node_get_terms_by_vocabulary($parent_otdel_nid, 1);
   						foreach($parent_otdel_tids as $parent_otdel_tid)
    					{
     						$parent_otdel_tid_name = $parent_otdel_tid->name;
     						$parent_otdel_tid = $parent_otdel_tid->tid;
    					}

    					// найдём всех потомков текущего (старого) родительского отдела, у которых нет своих детей, т.е., найдём все подгруппы родительского отдела, если он их имеет
    					// и среди них найдём потомка с названием текущей подгруппы и возьмём его тид
						$parent_otdel_tid_children = taxonomy_get_children($parent_otdel_tid, 1, 'name'); // taxonomy_get_children($tid, $vid = 0, $key = 'tid');
						$current_podgruppa_tid = FALSE;
						foreach($parent_otdel_tid_children as $child_name => $child_values)
						{
							if(taxonomy_get_children($child_values->tid, 1, 'name'))
								continue; // если потомок имеет своих потомков, значит это не подгруппа, а подотдел-потомок, а нам нужна группа!
									
									  		
							if($child_name == $zp_element['название'])
							{
								$current_podgruppa_tid = $child_values->tid;
								$current_podgruppa_tid_name = $child_values->name;
								break;
							}
						}
								
						// если в текущем родительском отделе нет такой подгруппы, которую нужно удалить
						if(!$current_podgruppa_tid)
						{
							$shop_item['Действие / результат'] = 'del error: в базе в данном отделе с артикулом -' . $zp_element['zp_artikul'] . '- и названием -' . $parent_otdel_name . '- нет подгруппы с названием ' . $zp_element['название'] . ', у которой вы пытаетесь изменить артикул'; 
							return $shop_item;
						}
									
						// если тид текущей подгруппы имеет хоть одна нода (этой нодой может быть только товар), то значит подгруппа имеет потомков, значит её изменять нельзя
						if($child_nid = db_result(db_query("SELECT nid from {term_node} WHERE tid = %d", $current_podgruppa_tid)))
						{
							$shop_item['Действие / результат'] = 'del error: в данной подгруппе с названием ' . $zp_element['название'] . 'содержатся товары, поэтому удаление подгруппы невозможно. Сначала освободите подгруппу от товаров.'; 
							return $shop_item;
						}
						
						
						break;
						
						
						
						
					case 'товар':	
						
						// найдём тид самого элемента по старому артикулу
						$element_nid = db_fetch_object(db_query("SELECT nid, vid from {uc_products} WHERE model = '%s'", $zp_element['zp_artikul']));
						
						$node->vid = $element_nid->vid; 
						$node->nid = $element_nid->nid;
						 
						if(!$node->nid OR !$node->vid)
						{
							$shop_item['Действие / результат'] = 'del error: ошибка при чтении базы данных или нет товара с таким артикулом ' . $zp_element['zp_artikul'] . ' в базе'; 
							return $shop_item;
						}
						
						$element_nid = $element_nid->nid;
									
						break;
						
						
					default:
						break;	
				
				}
				
				
				
				
				
				
				
				// на данном этапе изместно, что элемент есть, у него нет потомков, его можно удалить.
				
				echo '<br>Можно удалять!<br>';
				
				switch($zp_element['type'])
				{

					case 'страна':
					case 'населённый пункт': // обычно город
					case 'район':
					case 'магазин':
					case 'подотдел':
					case 'товар':
						
						//node_delete($node->nid);
						
						$node_to_del = node_load($node->nid);

  						//if (node_access('delete', $node)) 
  						//{
    						db_query('DELETE FROM {node} WHERE nid = %d', $node_to_del->nid);
    						db_query('DELETE FROM {node_revisions} WHERE nid = %d', $node_to_del->nid);

    						// Call the node-specific callback (if any):
    						node_invoke($node_to_del, 'delete');
    						node_invoke_nodeapi($node_to_del, 'delete');

    						// Clear the cache so an anonymous poster can see the node being deleted.
    						// кеш очищаем в основной функции после обновлении всех нодов
    						// cache_clear_all();

						    // Remove this node from the search index if needed.
    						if (function_exists('search_wipe')) 
    						{
      							search_wipe($node_to_del->nid, 'node');
    						}
    						
    						//drupal_set_message(t('%title has been deleted.', array('%title' => $node->title)));
    						
    						watchdog('content', t('@type: deleted %title.', array('@type' => t($node_to_del->type), '%title' => $node_to_del->title)));
  						//}

						

						
						break;
	  		  
					default: 
						break;
				}
				
				
				
				
				switch($zp_element['type'])
				{

					case 'страна':
					case 'населённый пункт': // обычно город
					case 'район':
					case 'магазин':
					case 'подотдел':

						// удаляем элемент и его терм
						db_query('DELETE FROM {term_data} WHERE tid = %d', $element_tid);
						db_query('DELETE FROM {term_hierarchy} WHERE tid = %d', $element_tid);
						
						break;
			
						
						
					case 'подгруппа':

						// удаляем только терм подгруппы (а больше ничего и нет у подгруппы)
						db_query('DELETE FROM {term_data} WHERE tid = %d', $current_podgruppa_tid);
						db_query('DELETE FROM {term_hierarchy} WHERE tid = %d', $current_podgruppa_tid);

						break;
						
						

					case 'товар':
						
						// удаляем товар и данные о количестве товара из соответствующей таблицы
						db_query('DELETE FROM {uc_product_stock} WHERE nid = %d', $node_to_del->nid);
						
						break;
						
						
	  		  
					default: 
						break;
				}
	

				
				
				// если для элемента было задано копирование картинок из другого элемента, удалить эту запись из базы
				switch($zp_element['type'])
				{

					case 'страна':
					case 'населённый пункт': // обычно город
					case 'район':
					case 'магазин':
					case 'подотдел':
					case 'товар':
				
						if( // если ранее было задано копирование картинок из другого элемента, удалить эту запись из базы
			
			 				db_result(db_query("SELECT nid from {content_field_source_of_pics} WHERE nid = %d", $node->nid))
		  			  	  )
		  			  	  {
							if( 
			 					!(db_query('DELETE FROM {content_field_source_of_pics} WHERE nid = %d', $node->nid))
		  	  			  	  )
		  	  			  	  {
		  						$shop_item['Действие / результат'] = 'del error: ошибка при удалении записи об элемента-источнике картинок'; 
								return $shop_item;
		      			  	  }

		  			  	  } // end of if( // если ранее было задано копирование картинок из другого элемента, удалить эту запись из базы
						
						break;
						
						
	  		  
					default: 
						break;
				}
				
				
				
				
				// если для элемента было задано копирование логотипов (для магазина и подотдела) из другого элемента, удалить эту запись из базы
				switch($zp_element['type'])
				{

					case 'магазин':
					case 'подотдел':
						
						if( // если ранее было задано копирование логотипов из другого элемента, удалить эту запись из базы
			 				db_result(db_query("SELECT nid from {content_field_source_of_logo} WHERE nid = %d", $node->nid))
		  			  	  )
		  			  	  {
							if( 
			 					!(db_query('DELETE FROM {content_field_source_of_logo} WHERE nid = %d', $node->nid))
		  	 			  	  )
		  	 			  	  {
		  						$shop_item['Действие / результат'] = 'del error: ошибка при удалении записи об элемента-источнике картинок логотипов'; 
								return $shop_item;
		      			  	  }

		  			  	  } 

						break;
						
						
	  		  
					default: 
						break;
				}
				
		  			  
		  		
				
				
				
				
				
				// если для товара были заданы атрибуты, удалить их вместе с опциями
				switch($zp_element['type'])
				{

					case 'товар':
						
						// выясним, есть ли в базе какие-то атрибуты у этого элемента.. и удаляем все, если есть
						if( 
							db_result(db_query("SELECT aid from {uc_product_attributes} WHERE nid = %d", $node->nid))
	  	  	  	  		  )
	  	  	  	  		  {
	  	  	  	  		  	if( 
			 					!(db_query('DELETE FROM {uc_product_attributes} WHERE nid = %d', $node->nid))
		  	 			  	  )
		  	 			  	  {
		  						$shop_item['Действие / результат'] = 'del error: Возможно, не все данные по этому элементу удалены. Ошибка при удалении атрибутов элемента'; 
								return $shop_item;
		      			  	  }
	   	  	      		  }
				
	   	  	      		// выясним, есть ли в базе какие-то опции атрибутов у этого элемента.. и удаляем все, если есть
						if( 
							db_result(db_query("SELECT oid from {uc_product_options} WHERE nid = %d", $node->nid))
	  	  	  	  		  )
	  	  	  	  		  {
	  	  	  	  		  	if( 
			 					!(db_query('DELETE FROM {uc_product_options} WHERE nid = %d', $node->nid))
		  	 			  	  )
		  	 			  	  {
		  						$shop_item['Действие / результат'] = 'del error: Возможно, не все данные по этому элементу удалены. Ошибка при удалении опций атрибутов элемента'; 
								return $shop_item;
		      			  	  }
	   	  	      		  } 

						break;
						
						
	  		  
					default: 
						break;
				}
				
				
				
				
				
				
				// если для элемента был задан алиас pathauto, удаляем его
				switch($zp_element['type'])
				{

					case 'страна':
					case 'населённый пункт': // обычно город
					case 'район':
					case 'магазин':
					case 'подотдел':
					case 'товар':
						
						//db_query("DELETE FROM {url_alias}  WHERE src = '%s'", 'node/'.$nid);
						//db_query("DELETE FROM {url_alias}  WHERE src = '%s'", 'node/'.$nid.'/feed');
				
						if( 
			 				db_result(db_query("SELECT pid from {url_alias} WHERE scr = '%s'", 'node/' . $node->nid))
		  			  	  )
		  			  	  {
							if( 
			 					!(db_query("DELETE FROM {url_alias} WHERE scr = '%s'", 'node/' . $node->nid))
			 					  OR
			 					!(db_query("DELETE FROM {url_alias} WHERE scr = '%s'", 'node/' . $node->nid . '/feed'))
		  	  			  	  )
		  	  			  	  {
		  						$shop_item['Действие / результат'] = 'del error: Не все данные удалены. Ошибка при удалении алиасов pathauto'; 
								return $shop_item;
		      			  	  }

		  			  	  } 
						
						break;
						
						
	  		  
					default: 
						break;
				}
				
	
				
	
	echo '<br>Удаление произведено успешно!<br>';
	
	$shop_item['Состояние элемента'] = 'deleted';
	
	return $shop_item;
				
}				































// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// функция изменения элемента в магазине (отдела, подгруппы, товара и т.д.)--------------

function zp_item_change($shop_item)
{
			
				
				// создатим новый объект типа нода, в который будем заносить некоторые необходимые данные по элементу
				$node = new stdClass();
				// и вспомогательный объект $zp_element для прочих данных по элементу
				$zp_element = array();
				
				
				// если значение поля содержит тип (в формате "значение***тип"), выясняем этот тип
				//$value = $shop_item['Тип записи'];
				$zp_element['type'] = zp_correct_quotes($shop_item['Тип записи']);
				
				//echo ' >>> type = ' . $zp_element['type'] . ', type of type = ' . $zp_element['type_of_type'];
				
				$zp_element['type_of_type'] = strpos($zp_element['type'], '***');
  				if($zp_element['type_of_type'] !== false) 
  				{
				  $zp_element['type_of_type'] = explode('***', $zp_element['type']);
				  $zp_element['type'] = $zp_element['type_of_type'][0];
				  $zp_element['type_of_type'] = $zp_element['type_of_type'][1];
				} 
				
				//echo 'shop_item[Тип записи] = ' . $shop_item['Тип записи'] . ', value = ' . $value . ', value_type = ' . $zp_element['type_of_type'];
				
				// уберём в полученных строках дубликаты кавычек и кавычки по краям
		 		$zp_element['type'] = $zp_element['type'];
		 		$zp_element['type_of_type'] = $zp_element['type_of_type'];
		 		
		 		
	
				// если не задан тип элемента, выходим
				if(!$zp_element['type'] OR $zp_element['type'] == '' OR $zp_element['type'] == ' ')
				{
					$shop_item['Действие / результат'] = 'change error: не указан тип элемента'; 
						return $shop_item;
				}
				
				echo ' >>>2 type = ' . $zp_element['type'] . ', type of type = ' . $zp_element['type_of_type'];
				
				// правильно ли указан тип элемента?
				switch($zp_element['type'])
				{
					case 'страна':
					case 'населённый пункт':
					case 'район':
					case 'магазин':
					case 'подотдел':
					case 'подгруппа':
					case 'товар': 
						break; 
						
					default:
						$shop_item['Действие / результат'] = 'change error: указан неизвестный или неправильный тип элемента'; 
						return $shop_item;
				}

							
				echo ' >>>2 type = ' . $zp_element['type'] . ', type of type = ' . $zp_element['type_of_type'];
				
				// если не задан тип элемента, выходим
				if(!$zp_element['type'] == 'товар' AND (!$zp_element['type_of_type'] OR $zp_element['type_of_type'] == '' OR $zp_element['type_of_type'] == ' '))
				{
					$shop_item['Действие / результат'] = 'change error: не указан тип товара';
						return $shop_item;
				}
				
				echo ' >>>2 type = ' . $zp_element['type'] . ', type of type = ' . $zp_element['type_of_type'];
				
				
				// проверим, есть ли какие-либо изменения в элементе
				$changes_exists = 0;
				$shop_item_changed = array();
				foreach ($shop_item as $key => $value)
				{
					//echo '---key = ' . $key . ', value = ' . $value . '<br>';
					
					// исправим лишние кавычки, если есть
					$value = zp_correct_quotes($value);
					
					/* // на всякий случай все поля добавляем в промежуточный массив... всё равно лишние поля не обрабатываются...
					
					// данные по артикулу не добавляем в промежуточный массив
				    if($key == 'Страна' OR
					   $key == 'Город' OR
					   $key == 'Район' OR
					   $key == 'Магазин' OR
					   $key == 'Подотдел' OR
					   //$key == 'Подгруппа / тип элемента' OR  // это поле используется не только при изменении артикулов, поэтому его тоже добавляем в общий массив
					   $key == 'Товар / родительский подотдел'
					  )
					continue; 
					*/

				//echo ' >>> key = ' . $key . ', value = ' . $value . '<br>';
					
					
					if($value[0] . $value[1] . $value[2] == '###')
					{	
						$shop_item_changed[$key] = $value;
						//echo '---shop_item_changed[key] = ' . $shop_item_changed[$key] . ', where key = ' . $key;
		  				$changes_exists = 1;
		  				
		  				// пометим, были ли изменения в артикуле и связях
					}
				}
					
				echo ' >>>2 type = ' . $zp_element['type'] . ', type of type = ' . $zp_element['type_of_type'];
				
				// если изменений нет, выходим
				if(!$changes_exists)
				{
					$shop_item['Действие / результат'] = 'change error: элемент не содержит изменений или неправильно указан признак изменения'; // сбрасываем флаг необходимости добавления элемента в базу	
						return $shop_item;
				}
				
				
				echo ' >>>2 type = ' . $zp_element['type'] . ', type of type = ' . $zp_element['type_of_type'];

				
				
				
				echo '_zp_element[type] = ' . $zp_element['type'] . '<br>';
				
				
				// изменяем артикулы и, соответственно, связи для разных типов элементов
				$artikul_changes_exists = 0;
				$new_value_with_history = array();
				
				// перебираем все поля из артикула и выясним новые и старые значения номеров артикула
				foreach ($shop_item as $key => $value)
				{
					// работаем только с полями артикула
					if($key != 'Страна' AND
					   $key != 'Город' AND
					   $key != 'Район' AND
					   $key != 'Магазин' AND
					   $key != 'Подотдел' AND
					   $key != 'Подгруппа / тип элемента' AND
					   $key != 'Товар / родительский подотдел'
					  )
					continue;
					
					
					// исправим лишние кавычки, если есть
					$value = zp_correct_quotes($value);

					//$new_value_with_history[$key] = FALSE;
					
					if($value[0] . $value[1] . $value[2] == '###') // управляющие символы в начале строки
		 			{
						$value = explode('###', $value);
		   	
						foreach($value as $k => $val)
						{
							if($k == 0 OR $k == 1)
		      	 		  		$new_value_with_history[$key] = $new_value_with_history[$key] . $val;
		    				else  
		      	 		  		$new_value_with_history[$key] = $new_value_with_history[$key] . '###' . $val;  
						} 
			
						$value_old = $value[2];
						$value = $value[1];
						
						$artikul_changes_exists = 1;  // значит какой-то из номеров артикула изменился
		 			}
		 			else if(strpos($value, '###') !== FALSE) // управляющие символы в середине строки
		 			{
		 				$value = explode('###', $value);
		   	
						foreach($value as $k => $val)
						{
							if($k == 0)
		      	 		 	 	$new_value_with_history[$key] = $new_value_with_history[$key] . $val;
		    				else  
		      	 		 	 	$new_value_with_history[$key] = $new_value_with_history[$key] . '###' . $val;  
						} 
			
						//$value_old = $value[1];
						$value = $value[0];
						$value_old = $value;
						
						echo ' hist --- key = ' . $key . ', new value = ' . $value . ', old value = ' . $value_old . '<br>';
						
		 			}
		 			else 
		 			{
		 				$value_old = $value;
		 			}
		 		
		 			
		 			
		 			// уберём в полученной строке дубликаты кавычек и кавычки по краям
		 			// и сохраним в массив 
		 			
		 			$zp_new_artikuls[$key] = $value;
		 			$zp_old_artikuls[$key] = $value_old;
		 			
		 			//if(!$zp_old_artikuls[$key])
		 			  //$zp_old_artikuls[$key] = $zp_new_artikuls[$key]; // если старое значение в истории не задано (например в виде ###однозначение), приравниваем старое значение к новому значению
					
		 			
				} // end of foreach ($shop_item as $key => $value) // перебираем все поля из артикула  и выясним новые и старые значения номеров артикула
				
				
				echo '_zp_element[type] = ' . $zp_element['type'] . '<br>';
				
				foreach($zp_new_artikuls as $key => $value)
				{
					
					echo ' <<<<<<< key = ' . $key . ', new value = ' . $value . '<br>';
					echo ' > old value = ' . $zp_old_artikuls[$key] . '<br>'; 
					echo ' > value with history = ' . $new_value_with_history[$key] . '<br>'; 
				}
				
				//echo ' >>>key = ' . $key . ', value = ' . $value . ', art_changed = ' . $artikul_changes_exists . '<br>';				
				
				echo '_zp_element[type] = ' . $zp_element['type'] . '<br>';
				
				// выясним название элемента, (пока старое, если необходимы изменения)

				// исправим лишние кавычки, если есть
				$value = zp_correct_quotes($shop_item['Название']);
					
				$name_changed = FALSE;
				if($value[0] . $value[1] . $value[2] == '###') // управляющие символы в начале строки
		 		{
					$value = explode('###', $value);
		   	
					foreach($value as $k => $val)
					{
						if($k == 0 OR $k == 1)
		      		  		$new_value_with_history['Название'] = $new_value_with_history['Название'] . $val;
		    			else  
		      		  		$new_value_with_history['Название'] = $new_value_with_history['Название'] . '###' . $val;  
					} 
			
					
					$value_old = $value[2];
					$value = $value[1];
						
					$name_changed = 1;  // назмание изменилось
		 		}
		 		else if(strpos($value, '###') !== FALSE) // управляющие символы в середине строки
		 		{
		 			$value = explode('###', $value);
		   	
					foreach($value as $k => $val)
		 			{
						if($k == 0)
		      		 	 	$new_value_with_history['Название'] = $new_value_with_history['Название'] . $val;
		    			else  
		      		 	 	$new_value_with_history['Название'] = $new_value_with_history['Название'] . '###' . $val;  
					} 
			
					//$value_old = $value[1];
					$value = $value[0];
					$value_old = $value;
					
		 		}
		 		else 
		 		{
		 			$value_old = $value;
		 		}
		 			
		 		echo '_zp_element[type] = ' . $zp_element['type'] . '<br>';
		 		
				$zp_element['старое_название'] = $value_old;
				$zp_element['новое_название'] = $value;
					
				//if(!$zp_element['старое_название'])
				 //$zp_element['старое_название'] = $zp_element['новое_название']; // если в таблице не задано старое название, приравниваем его новому
				
				
				echo ' ===new name = ' . $zp_element['новое_название'] . ', old value = ' . $zp_element['старое_название'] . ', art_changed = ' . $artikul_changes_exists . ', history value = ' . $new_value_with_history['Название'] . '<br>';				
				
				
				
				
				echo '_zp_element[type] = ' . $zp_element['type'];
				
								
				
				

				
				// Определим старые и новые (если заданы) артикулы для элементов разных типов и их стрые и новые (если заданы) родительские артикулы
				// а также зададим некоторые основные переменные и значения
				switch($zp_element['type'])
				{
					case 'страна':
						
						// если заданы не все составляющие артикула места (и, соответственно, местоположения места)
						// выходим из подпрограммы с указанием ошибки в поле "действие / результат"
						if(!$zp_old_artikuls['Страна'])
						 {
						 	$shop_item['Действие / результат'] = 'change error: неправильно указан исходный артикул страны'; 
							return $shop_item;
						 }
						
						// выясним старый и новый артикулы страны
						$zp_element['zp_old_artikul'] = 'z' . $zp_old_artikuls['Страна']; 
						$zp_element['zp_artikul'] = 'z' . $zp_new_artikuls['Страна']; 

						 
						 // задаём zp номер страны (зададим новый номер заранее)
						$zp_element['zp_number'] = $zp_new_artikuls['Страна'];
						
						$node->type = 'c_country';						
						
						//$zp_element['pics_field'] = 'country_img';
						$zp_element['pics_path'] = 'country_img';
						
						
						
						echo '------------- zp_element[zp_old_artikul] = ' . $zp_element['zp_old_artikul'] . ', zp_element[zp_artikul] = ' . $zp_element['zp_artikul'] . ', zp_element[zp_number] = ' . $zp_element['zp_number'] . ', node->type = ' . $node->type . ', zp_element[pics_path] = ' . $zp_element['pics_path'] . '<br>';
						
						
						break;	
						
						
					case 'населённый пункт': // обычно город
					
						if(!$zp_old_artikuls['Страна'] OR !$zp_old_artikuls['Город'])
						 {
						 	$shop_item['Действие / результат'] = 'change error: неправильно указан исходный артикул населённого пункта' ; 
							return $shop_item;
						 }
				
	
						// выясним старый и новый артикулы города
						$zp_element['zp_old_artikul'] = 'z' . $zp_old_artikuls['Страна'] . $zp_old_artikuls['Город']; 
						$zp_element['zp_artikul'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город']; 
								
						// выясним новый и старый артикулы родительской страны
						$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна']; 
						$zp_element['parent_zp_old_art'] = 'z' . $zp_old_artikuls['Страна']; 
						
						
						// задаём номер населённого пункта (внутри его страны)
						$zp_element['zp_number'] = $zp_new_artikuls['Город'];
						
						$node->type = 'c_city';
						
						//$zp_element['pics_field'] = 'city_img';
						$zp_element['pics_path'] = 'city_img';
						
						break;
						
						
					case 'район':
						
						if(!$zp_old_artikuls['Страна'] OR !$zp_old_artikuls['Город'] OR !$zp_old_artikuls['Район'])
						 {
						 	$shop_item['Действие / результат'] = 'change error: неправильно указан исходный артикул района' ; 
							return $shop_item;
						 }
						
						// выясним старый и новый артикулы района
						$zp_element['zp_old_artikul'] = 'z' . $zp_old_artikuls['Страна'] . $zp_old_artikuls['Город'] . $zp_old_artikuls['Район']; 
						$zp_element['zp_artikul'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район']; 
								
						// выясним новый и старый артикулы родительского города
						$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город']; 
						$zp_element['parent_zp_old_art'] = 'z' . $zp_old_artikuls['Страна'] . $zp_old_artikuls['Город']; 
						
						
						// задаём номер района (внутри населённого пункта, города)
						$zp_element['zp_number'] = $zp_new_artikuls['Район'];
						
						$node->type = 'c_rajon';
						
						//$zp_element['pics_field'] = 'rajon_img';
						$zp_element['pics_path'] = 'rajon_img';
						
						break;
						
					
					case 'магазин':
						
						if(!$zp_old_artikuls['Страна'] OR !$zp_old_artikuls['Город'] OR !$zp_old_artikuls['Район'] OR !$zp_old_artikuls['Магазин'])
						 {
						 	$shop_item['Действие / результат'] = 'change error: неправильно указан исходный артикул магазина' ; // сбрасываем флаг необходимости добавления элемента в базу	
							return $shop_item;
						 }
						
						// выясним старый и новый артикулы магазина
						$zp_element['zp_old_artikul'] = 'z' . $zp_old_artikuls['Страна'] . $zp_old_artikuls['Город'] . $zp_old_artikuls['Район'] . $zp_old_artikuls['Магазин']; 
						$zp_element['zp_artikul'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин']; 
							
						// выясним новый и старый артикулы родительского района 
						$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район']; 
						$zp_element['parent_zp_old_art'] = 'z' . $zp_old_artikuls['Страна'] . $zp_old_artikuls['Город'] . $zp_old_artikuls['Район']; 
						
												
						
						// задаём номер магазина (внутри внутри района)
						$zp_element['zp_number'] = $zp_new_artikuls['Магазин'];
						
						$node->type = 'c_shop';
						
						//$zp_element['pics_field'] = 'shop_img';
						$zp_element['pics_path'] = 'shop_img';
						
						break;
						
						
					case 'подотдел':
								
						
						if(!$zp_old_artikuls['Страна'] OR !$zp_old_artikuls['Город'] OR !$zp_old_artikuls['Район'] OR !$zp_old_artikuls['Магазин'] OR !$zp_old_artikuls['Подотдел'] OR !$zp_old_artikuls['Товар / родительский подотдел'])
						 {
						 	$shop_item['Действие / результат'] = 'change error: неправильно указан исходный артикул подотдела' ; // сбрасываем флаг необходимости добавления элемента в базу	
							return $shop_item;
						 }
						
						// выясним старый и новый артикулы подотдела
						$zp_element['zp_old_artikul'] = 'z' . $zp_old_artikuls['Страна'] . $zp_old_artikuls['Город'] . $zp_old_artikuls['Район'] . $zp_old_artikuls['Магазин'] . $zp_old_artikuls['Подотдел']; 
						$zp_element['zp_artikul'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин'] . $zp_new_artikuls['Подотдел']; 
								
						// выясним новый и старый артикулы родительского подотдела/магазина 
						if($zp_old_artikuls['Товар / родительский подотдел'] == '000')
							$zp_element['parent_zp_old_art'] = 'z' . $zp_old_artikuls['Страна'] . $zp_old_artikuls['Город'] . $zp_old_artikuls['Район'] . $zp_old_artikuls['Магазин']; 
						else
							$zp_element['parent_zp_old_art'] = 'z' . $zp_old_artikuls['Страна'] . $zp_old_artikuls['Город'] . $zp_old_artikuls['Район'] . $zp_old_artikuls['Магазин'] . $zp_old_artikuls['Товар / родительский подотдел']; 
						
							
						if($zp_new_artikuls['Товар / родительский подотдел'] == '000')
							$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин']; 
						else
							$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин'] . $zp_new_artikuls['Товар / родительский подотдел']; 

							
							
						// задаём номер подотдела (внутри магазина)
						$zp_element['zp_number'] = $zp_new_artikuls['Подотдел'];
						
						$zp_element['родительский подотдел'] = $zp_new_artikuls['Товар / родительский подотдел']; // проверить, где используется эта переменная и нужна ли она вообще
						
						$node->type = 'c_department';
						
						//$zp_element['pics_field'] = 'dept_img';
						$zp_element['pics_path'] = 'dept_img';
							
						break;
						
						
					case 'подгруппа':	

						if(!$zp_old_artikuls['Страна'] OR !$zp_old_artikuls['Город'] OR !$zp_old_artikuls['Район'] OR !$zp_old_artikuls['Магазин'] OR !$zp_old_artikuls['Подотдел'] OR !$zp_element['старое_название'])
						 {
						 	$shop_item['Действие / результат'] = 'change error: неправильно указан исходный артикул и/или название подгруппы'; // сбрасываем флаг необходимости добавления элемента в базу	
							return $shop_item;
						 }	
						
						// выясним новый и старый артикулы родительского отдела 
						$zp_element['parent_zp_old_art'] = 'z' . $zp_old_artikuls['Страна'] . $zp_old_artikuls['Город'] . $zp_old_artikuls['Район'] . $zp_old_artikuls['Магазин'] . $zp_old_artikuls['Подотдел']; 
						$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин'] . $zp_new_artikuls['Подотдел']; 
						
						break;		
						
					
					case 'товар':
						
						if(!$zp_old_artikuls['Страна'] OR !$zp_old_artikuls['Город'] OR !$zp_old_artikuls['Район'] OR !$zp_old_artikuls['Магазин'] OR !$zp_old_artikuls['Подотдел'] OR !$zp_old_artikuls['Подгруппа / тип элемента'] OR !$zp_old_artikuls['Товар / родительский подотдел'])
						 {
						 	$shop_item['Действие / результат'] = 'change error: не заданы какие-то из номеров местоположения и товара для формирования внутреннего артикула zp'; // сбрасываем флаг необходимости добавления элемента в базу	
							return $shop_item;
						 }
						 

						// выясним старый и новый артикулы товара
						$zp_element['zp_old_artikul'] = 'z' . $zp_old_artikuls['Страна'] . $zp_old_artikuls['Город'] . $zp_old_artikuls['Район'] . $zp_old_artikuls['Магазин'] . $zp_old_artikuls['Подотдел'] . $zp_old_artikuls['Товар / родительский подотдел']; 
						$zp_element['zp_artikul'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин'] . $zp_new_artikuls['Подотдел'] . $zp_new_artikuls['Товар / родительский подотдел']; 
						
						$node->model = $zp_element['zp_artikul']; // заранее установим новый артикул, так как на следующем шаге будет произведено изменение артикула, если оно задано в таблице
								
						// выясним новый и старый артикулы родительского отдела 
						$zp_element['parent_zp_old_art'] = 'z' . $zp_old_artikuls['Страна'] . $zp_old_artikuls['Город'] . $zp_old_artikuls['Район'] . $zp_old_artikuls['Магазин'] . $zp_old_artikuls['Подотдел']; 
						$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин'] . $zp_new_artikuls['Подотдел']; 

						
						// то же самое, но по-другому называется... для совместимости.. вроде где-то дальше используется такая переменная
						// задаём сразу новые значения, так как они будут изменены на следующем шаге
						$zp_element['parent_otdel_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин'] . $zp_new_artikuls['Подотдел'];
						
						
						// в зависимости от типа товара (который указан через *** от слова "товар") зададим типа ноды для товара
						switch($zp_element['type_of_type'])
						{
							case 'продукты':
								$node->type = 'product_food';
								//$zp_element['pics_field'] = 'p_food_img';
								$zp_element['pics_path'] = 'p_food_img';
								break;	
								
							case 'вещи':
								$node->type = 'product_clothes';
								//$zp_element['pics_field'] = 'p_clothes_img';
								$zp_element['pics_path'] = 'p_clothes_img';
								
								break;
									
							default:
								// иначе тип товара не определён в системе
								$shop_item['Действие / результат'] = 'change error: тип продукта ' . $zp_element['type_of_type'] . ' не определён в системе';
								return $shop_item;
								
						} // end of в зависимости от типа товара (который указан через *** от слова "товар") зададим типа ноды для товара
						
						break;		
					
									

					default:
						break;
					
				}
				
				
				
				// определим нид и некоторые другие данные текущего элемента, в зависимости от его типа
				switch($zp_element['type'])
				{
					case 'страна':
					case 'населённый пункт': // обычно город
					case 'район':
					case 'магазин':
					case 'подотдел':
					
						// определим нид текущего элемента по старому артикулу
						//$element_nid = db_result(db_query("SELECT nid from {content_field_zp_art_place} WHERE field_zp_art_place_value = '%s'", $zp_element['zp_old_artikul']));
					
						$element_nid = db_fetch_object(db_query("SELECT nid, vid from {content_field_zp_art_place} WHERE field_zp_art_place_value = '%s'", $zp_element['zp_old_artikul']));
						
						$node->vid = $element_nid->vid; 
						$node->nid = $element_nid->nid;
						 
						echo '------------- node->vid = ' . $node->vid . ', node->nid = ' . $node->nid . '<br>';
						
						
						
						if(!$node->nid OR !$node->vid)
						{
							$shop_item['Действие / результат'] = 'change error: ошибка при чтении базы данных или нет элемента с таким артикулом ' . $zp_element['zp_old_artikul'] . ' в базе'; 
							return $shop_item;
						}
						
						$element_nid = $element_nid->nid;
						
						
						
						// определим тид текущего элемента
						$element_tids = taxonomy_node_get_terms_by_vocabulary($element_nid, 1);
   						foreach($element_tids as $element_tid)
    					{
     						$element_tid_name = $element_tid->name;
     						$element_tid = $element_tid->tid;
    					}
    					
    					
    					echo '------------- element_tid = ' . $element_tid . '<br>';
						
    					
						break;	
					
						
					case 'подгруппа':

						// определим нид текущего (старого) родительского отдела
						$parent_nid = db_fetch_object(db_query("SELECT nid, vid from {content_field_zp_art_place} WHERE field_zp_art_place_value = '%s'", $zp_element['parent_zp_old_art']));
						
						$parent_vid = $parent_nid->vid; 
						$parent_nid = $parent_nid->nid;
						 
						if(!$parent_nid OR !$parent_vid)
						{
							$shop_item['Действие / результат'] = 'change error: ошибка при чтении базы данных или нет элемента с таким артикулом ' . $zp_element['parent_zp_old_art'] . ' в базе'; 
							return $shop_item;
						}
						
						
						break;
						
						
					case 'товар':	
						
						// найдём тид самого элемента по старому артикулу
						$element_nid = db_fetch_object(db_query("SELECT nid, vid from {uc_products} WHERE model = '%s'", $zp_element['zp_old_artikul']));
						
						$node->vid = $element_nid->vid; 
						$node->nid = $element_nid->nid;
						 
						if(!$node->nid OR !$node->vid)
						{
							$shop_item['Действие / результат'] = 'change error: ошибка при чтении базы данных или нет элемента с таким артикулом ' . $zp_element['zp_old_artikul'] . ' в базе'; 
							return $shop_item;
						}
						
						$element_nid = $element_nid->nid;
									
						break;
						
						
					default:
						break;	
				
				}
				
				
				echo 'zp_element[p_artikul] = ' . $zp_element['zp_artikul'] . '<br>';
				echo 'zp_element[zp_old_artikul] = ' . $zp_element['zp_old_artikul'] . '<br>';
				echo 'zp_element[parent_zp_art] = ' . $zp_element['parent_zp_art'] . '<br>';
				echo 'zp_element[parent_zp_old_art] = ' . $zp_element['parent_zp_old_art'] . '<br>';
				

				
				
				
					
					// зададим значение по умолчанию для базы названий картинок
					$zp_element['source_of_pics'] = 'зп-артикул'; 
					
					
					// удалим лишние кавычки, если есть
					if($shop_item['На основе чего формируется название картинок'] AND $shop_item['На основе чего формируется название картинок'] != '' AND $shop_item['На основе чего формируется название картинок'] != ' ')
					{
						$source_of_pics = zp_correct_quotes($shop_item['На основе чего формируется название картинок']);
					
						// удалим управляющие символы
						if($source_of_pics[0] . $source_of_pics[1] . $source_of_pics[2] == '###') // управляющие символы в начале строки
		 				{
							$source_of_pics = explode('###', $source_of_pics);
							foreach($value as $k => $val)
							{
								if($k == 0 OR $k == 1)
		      		  				$new_value_with_history['На основе чего формируется название картинок'] = $new_value_with_history['На основе чего формируется название картинок'] . $val;
		    					else  
		      		  				$new_value_with_history['На основе чего формируется название картинок'] = $new_value_with_history['На основе чего формируется название картинок'] . '###' . $val;  
							} 
			
							$source_of_pics = $source_of_pics[1];
							$markers = 'start';
							$zp_element['source_of_pics_markers'] = 'start';
		 				}
		 				else if(strpos($source_of_pics, '###') !== FALSE) // управляющие символы в середине строки
		 				{
			 				$source_of_pics = explode('###', $source_of_pics);
			 				foreach($value as $k => $val)
		 					{
								if($k == 0)
		      		 	 			$new_value_with_history['На основе чего формируется название картинок'] = $new_value_with_history['На основе чего формируется название картинок'] . $val;
		    					else  
		      		 	 			$new_value_with_history['На основе чего формируется название картинок'] = $new_value_with_history['На основе чего формируется название картинок'] . '###' . $val;  
							} 
					
							$source_of_pics = $source_of_pics[0];
							$zp_element['source_of_pics_markers'] = 'middle';
			 			}

						$zp_element['source_of_pics'] = $source_of_pics;
					}
				
				
						 			
		 			
		 			
		 			
				
				
					
				
				// если какой-то из номеров артикула или название изменились
				if($artikul_changes_exists OR $zp_element['старое_название'] != $zp_element['новое_название'])
				{   
						
					
					
					// изменяем артикул одним махом для разных типов элементов
					// перебор типов элемента для изменения артикула, подгруппы, называния для некоторых типов
					switch($zp_element['type'])
					  {
							case 'страна':
							
    							// если изменился артикул страны
    							if($zp_element['zp_artikul'] != $zp_element['zp_old_artikul'])
    							{
    								echo 'Изменился артикул <br>';
									
									echo 'страна ------------- element_tid = ' . $element_tid . '<br>';
									//return;
    					
    	
									// проверим, есть ли сейчас потомки (города) у этой (не изменённой ещё) страны 
									// если артикул должен поменяться и при этом есть потомки, не давать изменять артикул страны, так как при его изменении потомки-города окажутся потерянными
    								if($element_tid_children = taxonomy_get_children($element_tid, 1, 'name')) // taxonomy_get_children($tid, $vid = 0, $key = 'tid');
									{
										$shop_item['Действие / результат'] = 'change error: в даннй стране содержатся города, поэтому менять артикул нельзя, так как тогда эти города окажутся потерянными. Сначала удалите или перенесите в другие страны города-потомки, а потом уже изменяйте артикул (и родителя) этой страны'; 
										return $shop_item;
									}
								
    								
    								// проверим, нет ли в базе элемента с таким артикулом, на который требуется поменять артикул данной страны
    								if($existing_element_nid = db_result(db_query("SELECT nid from {content_field_zp_art_place} WHERE field_zp_art_place_value = '%s'", $zp_element['zp_new_artikul'])))
    								{
    									$shop_item['Действие / результат'] = 'change error: в базе уже есть элемент с таким артикулом ' . $zp_element['zp_new_artikul']; 
										return $shop_item;
    								}

    								
    								
									// если дошли до этого шага, значит можем менять артикул страны на новый
									if(
										!db_query("UPDATE {content_field_zp_art_place} SET field_zp_art_place_value = '%s' WHERE nid = %d", $zp_element['zp_artikul'], $element_nid)
								  	  )
								  	  {
										$shop_item['Действие / результат'] = 'change error: ошибка при изменении артикула страны на новый ' . $zp_element['zp_artikul']; 
										return $shop_item;
	  							  	  }

    							} // end of if($zp_element['zp_artikul'] != $zp_element['zp_old_artikul'])								
								
								
								// если изменилось название, меняем название и соответствующего терма страны
								// название самой страны изменяется позже, вместе с остальными полями
								if($zp_element['новое_название'] != $zp_element['старое_название'])
								{
									echo 'Изменилось название<br>';
									
									
									if(
										!db_query("UPDATE {term_data} SET name = '%s' WHERE tid = %d", $zp_element['новое_название'], $element_tid)
								  	  )
								  	  {
										$shop_item['Действие / результат'] = 'change error: ошибка при изменении названия терма страны на новое - ' . $zp_element['новое_название']; 
										return $shop_item;
	  							  	  }
	  							  	  
								}
								
								
								break; // end of case 'страна':
								
								
								
								
								
								
								
								
							case 'населённый пункт': // обычно город

    							// если изменился артикул любым способом (хоть только номер, без изменения родителя, хоть с изменением родителя)
    							if($zp_element['zp_artikul'] != $zp_element['zp_old_artikul'])
    							{
    	
									// проверим, есть ли сейчас потомки (районы) у этого (не изменённого ещё) города 
									// если артикул должен поменяться и при этом есть потомки, не давать изменять артикул и родительскую страны, так как при его изменении потомки города окажутся потерянными
    								if($element_tid_children = taxonomy_get_children($element_tid, 1, 'name')) // taxonomy_get_children($tid, $vid = 0, $key = 'tid');
									{
										$shop_item['Действие / результат'] = 'change error: в данном населённом пункте содержатся районы, поэтому менять артикул нельзя, так как тогда эти районы окажутся потерянными. Сначала удалите или перенесите в другие города районы-потомки, а потом уже изменяйте артикул (и родителя) этого города'; 
										return $shop_item;
									}
								
    								
    								// проверим, нет ли в базе элемента с таким артикулом, на который требуется поменять артикул данного города
    								if($existing_element_nid = db_result(db_query("SELECT nid from {content_field_zp_art_place} WHERE field_zp_art_place_value = '%s'", $zp_element['zp_new_artikul'])))
    								{
    									$shop_item['Действие / результат'] = 'change error: в базе уже есть элемент с таким артикулом ' . $zp_element['zp_new_artikul']; 
										return $shop_item;
    								}
								
    							} // end of if($zp_element['zp_artikul'] != $zp_element['zp_old_artikul'])
    							
    							
    							
    							// если у города не просто меняется номер внутри страны, а меняется и родитель (страна)
    							if($zp_element['parent_zp_art'] != $zp_element['parent_zp_old_art'])
    							{	
    								// проверим, есть ли в новом родительской стране потомки (города) с таким названием, как новое (если изменилось) название этого города
								
									// определим нид новой родительской страны
									// и если нид неопределён, значит заданного нового родителя не существует в базе
									if(
										!($parent_nid = db_result(db_query("SELECT nid from {content_field_zp_art_place} WHERE field_zp_art_place_value = '%s'", $zp_element['parent_zp_art'])))
    								  )
    								  {
    								  		$shop_item['Действие / результат'] = 'change error: не определёна страна с артикулом ' . $zp_element['parent_zp_art'] . ' которая задана в качестве нового родителя для этого города'; 
											return $shop_item;
    								  }
								
									// определим тид новой родительской страны
									$parent_tids = taxonomy_node_get_terms_by_vocabulary($parent_nid, 1);
   									foreach($parent_tids as $parent_tid)
    								{
     									$parent_tid_name = $parent_tid->name;
     									$parent_tid = $parent_tid->tid;
    								}

    								// найдём всех потомков новой родительской страны
    								// и среди них попробуем найти потомка с названием, равным новому назвыванию текущего города
    								// если найдётся, значит назначить заявленные новый артикул/название нельзя
									$parent_tid_children = taxonomy_get_children($parent_tid, 1, 'name'); // taxonomy_get_children($tid, $vid = 0, $key = 'tid');
									foreach($parent_tid_children as $child_name => $child_values)
									{
										if($child_name == $zp_element['новое_название'])
										{
											$shop_item['Действие / результат'] = 'change error: в новой стране в базе уже есть города с таким названием' . $zp_element['новое_название']; 
											return $shop_item;
										}
									}
									
									
									
									// если дошли до этого шага, значит можно менять терм родителя города на новый, терм новой страны
									if(
										!db_query("UPDATE {term_hierarchy} SET parent = %d WHERE tid = %d", $parent_tid, $element_tid)
								  	  )
								  	  {
										$shop_item['Действие / результат'] = 'change error: ошибка при изменении терма родителя города на терм новой родительской страны'; 
										return $shop_item;
	  							  	  }
	
	  							  	  
    							} // end of if($zp_element['parent_zp_art'] != $zp_element['parent_zp_old_art'])
    							
    							
    							
    							if($zp_element['zp_artikul'] != $zp_element['zp_old_artikul'])
    							{
									// если дошли до этого шага, значит можем менять артикул города на новый
									if(
										!db_query("UPDATE {content_field_zp_art_place} SET field_zp_art_place_value = '%s' WHERE nid = %d", $zp_element['zp_artikul'], $element_nid)
								  	  )
								  	  {
										$shop_item['Действие / результат'] = 'change error: ошибка при изменении артикула города на новый ' . $zp_element['zp_artikul']; 
										return $shop_item;
	  							  	  }

    							} // end of if($zp_element['zp_artikul'] != $zp_element['zp_old_artikul'])								
								
								
								// если изменилось название, меняем название и соответствующего терма города
								// название самого города изменяется позже, вместе с остальными полями
								if($zp_element['новое_название'] != $zp_element['старое_название'])
								{
									if(
										!db_query("UPDATE {term_data} SET name = '%s' WHERE tid = %d", $zp_element['новое_название'], $element_tid)
								  	  )
								  	  {
										$shop_item['Действие / результат'] = 'change error: ошибка при изменении названия терма города на новое - ' . $zp_element['новое_название']; 
										return $shop_item;
	  							  	  }
	  							  	  
								}
								
								
								break; // end of case 'населённый пункт':
								
								
								
								
								
								
								
							case 'район':
								
    							// если изменился артикул любым способом (хоть только номер, без изменения родителя, хоть с изменением родителя)
    							if($zp_element['zp_artikul'] != $zp_element['zp_old_artikul'])
    							{
    	
									// проверим, есть ли сейчас потомки (магазины) у этого (не изменённого ещё) района 
									// если артикул должен поменяться и при этом есть потомки, не давать изменять артикул и родительский город, так как при его изменении потомки района окажутся потерянными
    								if($element_tid_children = taxonomy_get_children($element_tid, 1, 'name')) // taxonomy_get_children($tid, $vid = 0, $key = 'tid');
									{
										$shop_item['Действие / результат'] = 'change error: в данном районе содержатся магазины, поэтому менять артикул нельзя, так как тогда эти магазины окажутся потерянными. Сначала удалите или перенесите в другие районы магазины потомки, а потом уже изменяйте артикул (и родителя) этого района'; 
										return $shop_item;
									}
								
    								
    								// проверим, нет ли в базе элемента с таким артикулом, на который требуется поменять артикул данного района
    								if($existing_element_nid = db_result(db_query("SELECT nid from {content_field_zp_art_place} WHERE field_zp_art_place_value = '%s'", $zp_element['zp_new_artikul'])))
    								{
    									$shop_item['Действие / результат'] = 'change error: в базе уже есть элемент с таким артикулом ' . $zp_element['zp_new_artikul']; 
										return $shop_item;
    								}
								
    							} // end of if($zp_element['zp_artikul'] != $zp_element['zp_old_artikul'])
    							
    							
    							
    							// если у района не просто меняется номер внутри города, а меняется и родитель (город)
    							if($zp_element['parent_zp_art'] != $zp_element['parent_zp_old_art'])
    							{	
    								// проверим, нет ли в новом родительском городе потомки (районы) с таким названием, как новое (если изменилось) название этого района
								
									// определим нид нового родительского города
									// и если нид неопределён, значит заданного нового родителя не существует в базе
									if(
										!($parent_nid = db_result(db_query("SELECT nid from {content_field_zp_art_place} WHERE field_zp_art_place_value = '%s'", $zp_element['parent_zp_art'])))
    								  )
    								  {
    								  		$shop_item['Действие / результат'] = 'change error: не определён город с артикулом ' . $zp_element['parent_zp_art'] . ' который задан в качестве нового родителя для этого района'; 
											return $shop_item;
    								  }
    								  
    								  
									// определим тид нового родительского города
									$parent_tids = taxonomy_node_get_terms_by_vocabulary($parent_nid, 1);
   									foreach($parent_tids as $parent_tid)
    								{
     									$parent_tid_name = $parent_tid->name;
     									$parent_tid = $parent_tid->tid;
    								}

    								// найдём всех потомков нового родительского города
    								// и среди них попробуем найти потомка с названием, равным новому назвыванию текущего района
    								// если найдётся, значит назначить заявленные новый артикул/название нельзя
									$parent_tid_children = taxonomy_get_children($parent_tid, 1, 'name'); // taxonomy_get_children($tid, $vid = 0, $key = 'tid');
									foreach($parent_tid_children as $child_name => $child_values)
									{
										if($child_name == $zp_element['новое_название'])
										{
											$shop_item['Действие / результат'] = 'change error: в новом городе в базе уже есть район с таким названием' . $zp_element['новое_название']; 
											return $shop_item;
										}
									}
									
									
									
									// если дошли до этого шага, значит можно менять терм родителя района на новый, терм нового города
									if(
										!db_query("UPDATE {term_hierarchy} SET parent = %d WHERE tid = %d", $parent_tid, $element_tid)
								  	  )
								  	  {
										$shop_item['Действие / результат'] = 'change error: ошибка при изменении терма родителя района на терм нового родительского города'; 
										return $shop_item;
	  							  	  }
	
	  							  	  
    							} // end of if($zp_element['parent_zp_art'] != $zp_element['parent_zp_old_art'])
    							
    							
    							
    							if($zp_element['zp_artikul'] != $zp_element['zp_old_artikul'])
    							{
									// если дошли до этого шага, значит можем менять артикул района на новый
									if(
										!db_query("UPDATE {content_field_zp_art_place} SET field_zp_art_place_value = '%s' WHERE nid = %d", $zp_element['zp_artikul'], $element_nid)
								  	  )
								  	  {
										$shop_item['Действие / результат'] = 'change error: ошибка при изменении артикула района на новый - ' . $zp_element['zp_artikul']; 
										return $shop_item;
	  							  	  }

    							} // end of if($zp_element['zp_artikul'] != $zp_element['zp_old_artikul'])								
								
								
								// если изменилось название, меняем название и соответствующего терма района
								// название самого района изменяется позже, вместе с остальными полями
								if($zp_element['новое_название'] != $zp_element['старое_название'])
								{
									if(
										!db_query("UPDATE {term_data} SET name = '%s' WHERE tid = %d", $zp_element['новое_название'], $element_tid)
								  	  )
								  	  {
										$shop_item['Действие / результат'] = 'change error: ошибка при изменении названия терма района на новое - ' . $zp_element['новое_название']; 
										return $shop_item;
	  							  	  }
	  							  	  
								}
								
								
								break; // end of case 'район':
								
								
								
								
								
							case 'магазин':
								
    							// если изменился артикул любым способом (хоть только номер, без изменения родителя, хоть с изменением родителя)
    							if($zp_element['zp_artikul'] != $zp_element['zp_old_artikul'])
    							{
    	
									// проверим, есть ли сейчас потомки (отделы) у этого (не изменённого ещё) магазина 
									// если артикул должен поменяться и при этом есть потомки, не давать изменять артикул и родительский район, так как при его изменении потомки магазина окажутся потерянными
    								if($element_tid_children = taxonomy_get_children($element_tid, 1, 'name')) // taxonomy_get_children($tid, $vid = 0, $key = 'tid');
									{
										$shop_item['Действие / результат'] = 'change error: в данном магазине содержатся подотделы, поэтому менять артикул нельзя, так как тогда эти подотделы окажутся потерянными. Сначала удалите или перенесите в другие магазины подотделы потомки, а потом уже изменяйте артикул (и родителя) этого магазина'; 
										return $shop_item;
									}
								
    								
    								// проверим, нет ли в базе элемента с таким артикулом, на который требуется поменять артикул данного магазина
    								if($existing_element_nid = db_result(db_query("SELECT nid from {content_field_zp_art_place} WHERE field_zp_art_place_value = '%s'", $zp_element['zp_new_artikul'])))
    								{
    									$shop_item['Действие / результат'] = 'change error: в базе уже есть элемент с таким артикулом ' . $zp_element['zp_new_artikul']; 
										return $shop_item;
    								}
								
    							} // end of if($zp_element['zp_artikul'] != $zp_element['zp_old_artikul'])
    							
    							
    							
    							// если у магазина не просто меняется номер внутри района, а меняется и родитель (район)
    							if($zp_element['parent_zp_art'] != $zp_element['parent_zp_old_art'])
    							{	
    								// проверим, нет ли в новом родительском районе потомки (магазины) с таким названием, как новое (если изменилось) название этого магазина
								
									// определим нид нового родительского района
									// и если нид неопределён, значит заданного нового родителя не существует в базе
									if(
										!($parent_nid = db_result(db_query("SELECT nid from {content_field_zp_art_place} WHERE field_zp_art_place_value = '%s'", $zp_element['parent_zp_art'])))
    								  )
    								  {
    								  		$shop_item['Действие / результат'] = 'change error: не определён район с артикулом ' . $zp_element['parent_zp_art'] . ' который задан в качестве нового родителя для этого магазина'; 
											return $shop_item;
    								  }
								
									// определим тид нового родительского района
									$parent_tids = taxonomy_node_get_terms_by_vocabulary($parent_nid, 1);
   									foreach($parent_tids as $parent_tid)
    								{
     									$parent_tid_name = $parent_tid->name;
     									$parent_tid = $parent_tid->tid;
    								}

    								// найдём всех потомков нового родительского района
    								// и среди них попробуем найти потомка с названием, равным новому назвыванию текущего магазина
    								// если найдётся, значит назначить заявленные новый артикул/название нельзя
									$parent_tid_children = taxonomy_get_children($parent_tid, 1, 'name'); // taxonomy_get_children($tid, $vid = 0, $key = 'tid');
									foreach($parent_tid_children as $child_name => $child_values)
									{
										if($child_name == $zp_element['новое_название'])
										{
											$shop_item['Действие / результат'] = 'change error: в новом районе в базе уже есть магазин с таким названием' . $zp_element['новое_название']; 
											return $shop_item;
										}
									}
									
									
									
									// если дошли до этого шага, значит можно менять терм родителя магазина на новый, терм нового района
									if(
										!db_query("UPDATE {term_hierarchy} SET parent = %d WHERE tid = %d", $parent_tid, $element_tid)
								  	  )
								  	  {
										$shop_item['Действие / результат'] = 'change error: ошибка при изменении терма родителя магазина на терм нового родительского района'; 
										return $shop_item;
	  							  	  }
	
	  							  	  
    							} // end of if($zp_element['parent_zp_art'] != $zp_element['parent_zp_old_art'])
    							
    							
    							
    							if($zp_element['zp_artikul'] != $zp_element['zp_old_artikul'])
    							{
									// если дошли до этого шага, значит можем менять артикул магазина на новый
									if(
										!db_query("UPDATE {content_field_zp_art_place} SET field_zp_art_place_value = '%s' WHERE nid = %d", $zp_element['zp_artikul'], $element_nid)
								  	  )
								  	  {
										$shop_item['Действие / результат'] = 'change error: ошибка при изменении артикула магазина на новый ' . $zp_element['zp_artikul']; 
										return $shop_item;
	  							  	  }

    							} // end of if($zp_element['zp_artikul'] != $zp_element['zp_old_artikul'])								
								
								
								// если изменилось название, меняем название и соответствующего терма магазина
								// название самого магазина изменяется позже, вместе с остальными полями
								if($zp_element['новое_название'] != $zp_element['старое_название'])
								{
									if(
										!db_query("UPDATE {term_data} SET name = '%s' WHERE tid = %d", $zp_element['новое_название'], $element_tid)
								  	  )
								  	  {
										$shop_item['Действие / результат'] = 'change error: ошибка при изменении названия терма магазина на на новое ' . $zp_element['новое_название']; 
										return $shop_item;
	  							  	  }
	  							  	  
								}
								
								
								break; // end of case 'магазин':
								
								
								
								
								
								
								
								
							case 'подотдел':

    							// если хоть как-то изменился артикул (с изменением родителя или просто с изменением номера внутри прежнего родителя)
    							if($zp_element['zp_artikul'] != $zp_element['zp_old_artikul'])
    							{
    								
    								// проверим, нет ли в базе элемента с таким артикулом, на который требуется поменять артикул данного подотдела
    								if($existing_element_nid = db_result(db_query("SELECT nid from {content_field_zp_art_place} WHERE field_zp_art_place_value = '%s'", $zp_element['zp_new_artikul'])))
    								{
    									$shop_item['Действие / результат'] = 'change error: в базе уже есть элемент с таким артикулом ' . $zp_element['zp_new_artikul']; 
										return $shop_item;
    								}
    							
    							
    								// найдём всех потомков текущего подотдела
    								// если потомки есть, значит нельзя изменять артикул и родительский подотдел, так как при его изменении потомки подотдела окажутся потерянными
									if($element_tid_children = taxonomy_get_children($element_tid, 1, 'name')) // taxonomy_get_children($tid, $vid = 0, $key = 'tid');
									{
										$shop_item['Действие / результат'] = 'change error: в данном отделе содержатся подотделы или подгруппы, поэтому менять артикул нельзя, так как тогда эти элементы окажутся потерянными. Сначала удалите или перенесите в другие отделы подотделы потомки, а потом уже изменяйте артикул'; 
										return $shop_item;
									}
    							}
    							
    							
    							
    							// если изменился родитель подотдела
    							if($zp_element['parent_zp_art'] != $zp_element['parent_zp_old_art'])
    							{

									// определим нид нового родительского подотдела
									// и если нид неопределён, значит заданного нового родителя не существует в базе
									if(
										!($parent_nid = db_result(db_query("SELECT nid from {content_field_zp_art_place} WHERE field_zp_art_place_value = '%s'", $zp_element['parent_zp_art'])))
    								  )
    								  {
    								  		$shop_item['Действие / результат'] = 'change error: не определён элемент с артикулом ' . $zp_element['parent_zp_art'] . ' который задан в качестве нового родителя для этого подотдела'; 
											return $shop_item;
    								  }

								
									// определим тид нового родительского отдела
									$parent_tids = taxonomy_node_get_terms_by_vocabulary($parent_nid, 1);
   									foreach($parent_tids as $parent_tid)
    								{
     									$parent_tid_name = $parent_tid->name;
     									$parent_tid = $parent_tid->tid;
    								}

    								// найдём всех потомков нового родительского подотдела
    								// и среди них попробуем найти потомка с названием равным новому назвыванию текущего подотдела
    								// если найдётся, значит назначить заявленные новый артикул/название нельзя
									$parent_tid_children = taxonomy_get_children($parent_tid, 1, 'name'); // taxonomy_get_children($tid, $vid = 0, $key = 'tid');
									foreach($parent_tid_children as $child_name => $child_values)
									{
										if($child_name == $zp_element['новое_название'])
										{
											$shop_item['Действие / результат'] = 'change error: в новом отделе в базе уже есть подотдел с названием ' . $zp_element['новое_название']; 
											return $shop_item;
										}
									}
									
									
									// если дошли до этого шага, значит можем менять связи
									// меняем связь: терм родителя подотдела на терм нового родительского подотдела
									if(
										!db_query("UPDATE {term_hierarchy} SET parent = %d WHERE tid = %d", $parent_tid, $element_tid)
								  	  )
								  	  {
										$shop_item['Действие / результат'] = 'change error: ошибка при изменении терма родителя подотдела на терм нового родительского подотдела'; 
										return $shop_item;
	  							  	  }
	  							  	  
										
    							} // end of if($zp_element['parent_zp_art'] != $zp_element['parent_zp_old_art'])
    								
    							
    							
    							if($zp_element['zp_artikul'] != $zp_element['zp_old_artikul'])
    							{
								
									// если дошли до этого шага, значит можем менять артикул
									if(
										!db_query("UPDATE {content_field_zp_art_place} SET field_zp_art_place_value = '%s' WHERE nid = %d", $zp_element['zp_artikul'], $element_nid)
								  	  )
								  	  {
										$shop_item['Действие / результат'] = 'change error: ошибка при изменении родителя (артикула подотдела) подотдела на новый ' . $zp_element['zp_artikul']; 
										return $shop_item;
	  							  	  }
									

								} // end of if($zp_element['zp_artikul'] != $zp_element['zp_old_artikul'])
								
								
								
								
								// если изменилось название, меняем название соответствующего терма подотдела
								// название самого отдела изменяется позже, вместе с остальными полями
								if($zp_element['новое_название'] != $zp_element['старое_название'])
								{
									if(
										!db_query("UPDATE {term_data} SET name = '%s' WHERE tid = %d", $zp_element['новое_название'], $element_tid)
								  	  )
								  	  {
										$shop_item['Действие / результат'] = 'change error: ошибка при изменении названия терма подотдела на на новое ' . $zp_element['новое_название']; 
										return $shop_item;
	  							  	  }
	  							  	  
								} // end of if($zp_element['новое_название'] != $zp_element['старое_название'])
								

								break; // end of case 'подотдел':
								
								
								
								
								
							case 'подгруппа':
							
								// проверим есть ли сейчас потомки у этой (не изменённой ещё) подгруппы 
								// если есть, не давать изменять артикул и название подгруппы, так как при его изменении потомки группы окажутся потерянными
									
								// определим текущий (старый) тид этой подгруппы
								// для этого
									
								// определим тид текущего (старого) родительского отдела
								$parent_tids = taxonomy_node_get_terms_by_vocabulary($parent_nid, 1);
   								foreach($parent_tids as $parent_tid)
    							{
     								$parent_tid_name = $parent_tid->name;
     								$parent_tid = $parent_tid->tid;
    							}

    							// найдём всех потомков текущего (старого) родительского отдела, у которых нет своих детей, т.е., найдём все подгруппы родительского отдела, если он их имеет
    							// и среди них найдём потомка с названием текущей подгруппы и возьмём его тид
								$parent_tid_children = taxonomy_get_children($parent_tid, 1, 'name'); // taxonomy_get_children($tid, $vid = 0, $key = 'tid');
								$current_podgruppa_tid = FALSE;
								foreach($parent_tid_children as $child_name => $child_values)
								{
									if(taxonomy_get_children($child_values->tid, 1, 'name'))
								  		continue; // если потомок имеет своих потомков, значит это не подгруппа, а подотдел-потомок, а нам нужна группа!
									
									  		
									if($child_name == $zp_element['старое_название'])
									{
										$current_podgruppa_tid = $child_values->tid;
										$current_podgruppa_tid_name = $child_values->name;
										break;
									}
								}
										
								
								// если в текущем (старом) родительском отделе нет такой подгруппы (исходной, неизменённой), которой мы хотим изменить артикул
								if(!$current_podgruppa_tid)
								{
									$shop_item['Действие / результат'] = 'change error: в данном отделе в базе нет подгруппы с названием ' . $zp_element['старое_название'] . ', у которой вы пытаетесь изменить артикул'; 
									return $shop_item;
								}
									
									
								// --------------------------------------------------------------------------------------	
								
								// если родительский отдел изменился
								if($zp_element['parent_zp_art'] != $zp_element['parent_zp_old_art'])
								{
									
									
									// если тид текущей подгруппы имеет хоть одна нода (этой нодой может быть только товар), то значит подгруппа имеет потомков, значит её изменять нельзя
									if($child_nid = db_result(db_query("SELECT nid from {term_node} WHERE tid = %d", $current_podgruppa_tid)))
									{
										$shop_item['Действие / результат'] = 'change error: в данной подгруппе с названием ' . $zp_element['старое_название'] . 'содержатся товары, поэтому изменение артикула невозможно. Сначала освободите подгруппу от товаров. Вместо изменения артикула подгруппы можно сначала создать новую подгруппу с новым артикулом, затем перенести в неё товары из этой группы (сделать родителем товаров новую созданную группу), а потом удалить старую подгруппу, освобождённую от товаров'; 
										return $shop_item;
									}
									
									// если дошли до этого шага, значит в подгруппе нет товаров, значит можно менять артикул и, если необходимо, название
									//$zp_element['старое_название'], $zp_element['новое_название'] 
									
									// проверим, нет ли в указанном (с помощью нового артикула) новом родителе этой подгруппы подгруппы с таким же (новым, если оно меняется у подгруппы) названием
									// если есть, то значит мы не можем перенести (и, если нужно, переименовать) текущую подгруппу в новый подотдел, так как там уже есть подгруппа с таким названием
									
									// определим нид нового родительского отдела
									// и если нид неопределён, значит заданного нового родителя не существует в базе
									if(
										!($new_parent_nid = db_result(db_query("SELECT nid from {content_field_zp_art_place} WHERE field_zp_art_place_value = '%s'", $zp_element['parent_zp_art'])))
    								  )
    								  {
    								  		$shop_item['Действие / результат'] = 'change error: не определён подотдел с артикулом ' . $zp_element['parent_zp_art'] . ' который задан в качестве нового родителя для этой подгруппы'; 
											return $shop_item;
    								  }
									
			
									// определим тид нового родительского отдела
									$new_parent_tids = taxonomy_node_get_terms_by_vocabulary($new_parent_nid, 1);
   									foreach($new_parent_tids as $new_parent_tid)
    								{
     									$new_parent_tid_name = $new_parent_tid->name;
     									$new_parent_tid = $new_parent_tid->tid;
    								}

    								// найдём всех потомков нового родительского отдела, у которых нет своих детей, т.е., найдём все подгруппы родительского отдела, если он их имеет
    								// и среди них найдём потомка с названием текущей подгруппы и возьмём его тид
									$new_parent_tid_children = taxonomy_get_children($new_parent_tid, 1, 'name'); // taxonomy_get_children($tid, $vid = 0, $key = 'tid');
									$existing_podgruppa_tid = FALSE;
									foreach($new_parent_tid_children as $child_name => $child_values)
									{
										if(taxonomy_get_children($child_values->tid, 1, 'name'))
									  		continue; // если потомок имеет своих потомков, значит это не подгруппа, а подотдел-потомок, а нам нужна группа!
									
									  		
										if($child_name == $zp_element['новое_название'])
										{
											$existing_podgruppa_tid = $child_values->tid;
											$existing_podgruppa_tid_name = $child_values->name;
											break;
										}
									}
										
								
									// если в текущем (старом) родительском отделе нет такой подгруппы (исходной, неизменённой), которой мы хотим изменить артикул
									if($existing_podgruppa_tid)
									{
										$shop_item['Действие / результат'] = 'change error: в новом отделе, в который вы хотите перенести эту подгруппу, уже есть подгруппа с таким названием ' . $zp_element['новое_название']; 
										return $shop_item;
									}
									
									// теперь ясно, что можно произвести изменение артикула (родителя) и, если нужно, названия подгруппы
									// что и делаем
									// фактически, меняем только связь по термам (что и указываает на артикул родителя) и, если нужно, название
									// $current_podgruppa_tid
									// $new_parent_tid
									
									// меняем родителя подгруппы на нового
									if(
										!db_query("UPDATE {term_hierarchy} SET parent = %d WHERE tid = %d", $new_parent_tid, $current_podgruppa_tid)
								  	  )
								  	  {
										$shop_item['Действие / результат'] = 'change error: ошибка при изменении родителя (артикула) подгруппы на на новый ' . $zp_element['parent_zp_art']; 
										return $shop_item;
	  							  	  }
	  							  	  
	  							  	 // если название подгруппы изменилось, меняем его в базе
	  							  	 if($zp_element['старое_название'] != $zp_element['новое_название'])
	  							  	 {
	  							  	 	if(
											!db_query("UPDATE {term_data} SET name = '%s' WHERE tid = %d", $zp_element['новое_название'], $current_podgruppa_tid)
								  	  	  )
								  	  	  {
											$shop_item['Действие / результат'] = 'change error: ошибка при изменении названия подгруппы на на новое ' . $zp_element['новое_название']; 
											return $shop_item;
	  							  	  	  }
	  							  	 }

								} // end of if($zp_element['parent_zp_art'] != $zp_element['parent_zp_old_art']) // если родительский отдел изменился
								
								// --------------------------------------------------------------------------------------	
								
								else if($zp_element['старое_название'] != $zp_element['новое_название'])
								{
									// если у подгруппы есть потомки (товары), то название подгруппы менять нельзя, так как тогда случится путаница и сбой по связям
									// если так, то сначала надо либо очистить подгруппу от товаров и тогда менять название
									// либо создать новую подгруппу с таким же родителем, но с новым названием, перенести в неё товары из этой группы, а затем эту группу удалить
									// если тид текущей подгруппы имеет хоть одна нода (этой нодой может быть только товар), то значит подгруппа имеет потомков, значит её изменять нельзя
									
									if($child_nid = db_result(db_query("SELECT nid from {term_node} WHERE tid = %d", $current_podgruppa_tid)))
									{
										$shop_item['Действие / результат'] = 'change error: в данной подгруппе с названием ' . $zp_element['старое_название'] . 'содержатся товары, поэтому изменение артикула невозможно. Сначала освободите подгруппу от товаров. Вместо изменения артикула подгруппы можно сначала создать новую подгруппу с новым артикулом, затем перенести в неё товары из этой группы (сделать родителем товаров новую созданную группу), а потом удалить старую подгруппу, освобождённую от товаров'; 
										return $shop_item;
									}
									
									
									// меняем название терма подгруппы
									if(
										!db_query("UPDATE {term_data} SET name = '%s' WHERE tid = %d", $zp_element['новое_название'], $current_podgruppa_tid)
								  	  )
								  	  {
										$shop_item['Действие / результат'] = 'change error: ошибка при изменении названия подгруппы на на новое ' . $zp_element['новое_название']; 
										return $shop_item;
	  							  	  }

								}
								
								break; // end of case 'подгруппа':
								
								
								
								
							case 'товар':
																
								// если родительский отдел изменился
								if($zp_element['parent_zp_art'] != $zp_element['parent_zp_old_art'])
								{
									
									// выясним нет ли в базе уже такого артикула, на который нужно изменить артикул текущего элемента
									if($existing_artikul = db_result(db_query("SELECT nid from {uc_products} WHERE model = '%s'", $zp_element['zp_artikul'])))
									{
										$shop_item['Действие / результат'] = 'change error: нельзя заменить артикул товара, товар с артикулом ' . $zp_element['zp_artikul'] . ' уже существует в базе'; 
										return $shop_item;
									}
									
								
									// определим нид нового родительского отдела
									// и если нид неопределён, значит заданного нового родителя не существует в базе
									if(
										!($parent_nid = db_result(db_query("SELECT nid from {content_field_zp_art_place} WHERE field_zp_art_place_value = '%s'", $zp_element['parent_zp_art'])))
    								  )
    								  {
    								  		$shop_item['Действие / результат'] = 'change error: не определён подотдел с артикулом ' . $zp_element['parent_zp_art'] . ' который задан в качестве нового родителя для этого товара'; 
											return $shop_item;
    								  }
								
									// определим тид нового родительского отдела
									$parent_tids = taxonomy_node_get_terms_by_vocabulary($parent_nid, 1);
   									foreach($parent_tids as $parent_tid)
    								{
     									$parent_tid_name = $parent_tid->name;
     									$parent_tid = $parent_tid->tid;
    								}
								
									// найдём всех потомков нового родительского отдела, у которых нет своих детей, т.е., найдём все подгруппы родительского отдела, если он их имеет
									$parent_tid_children = taxonomy_get_children($parent_tid, 1, 'name'); // taxonomy_get_children($tid, $vid = 0, $key = 'tid');
									$podgruppa_tid = FALSE;
									foreach($parent_tid_children as $child_name => $child_values)
									{
										if(taxonomy_get_children($child_values->tid, 1, 'name'))
									  		continue; // если потомок имеет своих потомков, значит это не подгруппа, а подотдел-потомок, а нам нужна группа!
									
										if($child_name == $zp_new_artikuls['Подгруппа / тип элемента'])
										{
											$podgruppa_tid = $child_values->tid;
											$podgruppa_tid_name = $child_values->name;
											break;
										}
									}
								
								
									// если в родительском отделе нет группы с называнием, на которое требуется изменить подгруппу данного товара
									if(!$podgruppa_tid)
									{
										$shop_item['Действие / результат'] = 'change error: нельзя изменить артикул товара, так как в новом родительском отделе не задана группа ' . $zp_new_artikuls['Подгруппа / тип элемента']; 
										return $shop_item;
									}
								
								
								
									// меняем артикул товара на новый 
									if(
										!db_query("UPDATE {uc_products} SET model = '%s' WHERE nid = %d", $zp_element['zp_artikul'], $element_nid)
								  	  )
								  	  {
										$shop_item['Действие / результат'] = 'change error: ошибка при изменении артикула товара на новый ' . $zp_element['zp_artikul']; 
										return $shop_item;
	  							  	  }
									
    							
    								// меняем терм родителя товара на терм нового родителя - подгруппы $podgruppa_tid
									if(
										!db_query("UPDATE {term_node} SET parent = %d WHERE tid = %d", $podgruppa_tid, $element_tid)
								  	  )
								  	  {
										$shop_item['Действие / результат'] = 'change error: ошибка при изменении родителя товара с новым артикулом ' . $zp_element['zp_artikul'] . ' на подгруппу ' . $podgruppa_tid_name; 
										return $shop_item;
	  							  	  }
	  							  	
								} // end of if($zp_element['parent_zp_art'] != $zp_element['parent_zp_old_art'])
								else // если родительский отдел не изменился
								{
									if ($zp_old_artikuls['Товар / родительский подотдел'] != $zp_new_artikuls['Товар / родительский подотдел']) 
									{
										// выясним нет ли в текущем отделе в базе уже такого артикула, на который нужно изменить артикул текущего элемента
										if($existing_artikul = db_result(db_query("SELECT nid from {uc_products} WHERE model = '%s'", $zp_element['zp_artikul'])))
										{
											$shop_item['Действие / результат'] = 'change error: нельзя заменить артикул товара (номер товара в своём отделе), товар с артикулом ' . $zp_element['zp_artikul'] . ' уже существует в базе'; 
											return $shop_item;
										}
										
										// меняем артикул товара на новый 
										if(
											!db_query("UPDATE {uc_products} SET model = '%s' WHERE nid = %d", $zp_element['zp_artikul'], $element_nid)
								  	  	  )
								  	  	  {
											$shop_item['Действие / результат'] = 'change error: ошибка при изменении артикула товара (номера товара в своём отделе) на новый ' . $zp_element['zp_artikul']; 
											return $shop_item;
	  							  	      }

									 } // end of if ($zp_old_artikuls['Товар / родительский подотдел'] != $zp_new_artikuls['Товар / родительский подотдел']) 
									
									 
									 
									 
									 if ($zp_old_artikuls['Подгруппа / тип элемента'] != $zp_new_artikuls['Подгруппа / тип элемента']) 
									 {
									 	
									 	// определим нид нового родительского отдела
										$parent_nid = db_result(db_query("SELECT nid from {content_field_zp_art_place} WHERE field_zp_art_place_value = '%s'", $zp_element['parent_zp_art']));
								
										// определим тид нового родительского отдела
										$parent_tids = taxonomy_node_get_terms_by_vocabulary($parent_nid, 1);
   										foreach($parent_tids as $parent_tid)
    									{
     										$parent_tid_name = $parent_tid->name;
     										$parent_tid = $parent_tid->tid;
    									}
								
										// найдём всех потомков нового родительского отдела, у которых нет своих детей, т.е., найдём все подгруппы родительского отдела, если он их имеет
										$parent_tid_children = taxonomy_get_children($parent_tid, 1, 'name'); // taxonomy_get_children($tid, $vid = 0, $key = 'tid');
										$podgruppa_tid = FALSE;
										foreach($parent_tid_children as $child_name => $child_values)
										{
											if(taxonomy_get_children($child_values->tid, 1, 'name'))
									  			continue; // если потомок имеет своих потомков, значит это не подгруппа, а подотдел-потомок, а нам нужна группа!
									
											if($child_name == $zp_new_artikuls['Подгруппа / тип элемента'])
											{
												$podgruppa_tid = $child_values->tid;
												$podgruppa_tid_name = $child_values->name;
												break;
											}
										}
								
								
										// если в новом родительском отделе нет группы с называнием, на которое требуется изменить подгруппу данного товара
										if(!$podgruppa_tid)
										{
											$shop_item['Действие / результат'] = 'change error: нельзя изменить подгруппу товара на ' . $zp_new_artikuls['Подгруппа / тип элемента'] . ', так как в родительском отделе не задана такая группа '; 
											return $shop_item;
										}
								
								
   							
    									// меняем терм родителя товара на терм нового родителя - подгруппы $podgruppa_tid
										if(
											!db_query("UPDATE {term_node} SET parent = %d WHERE tid = %d", $podgruppa_tid, $element_tid)
								  	  	  )
								  	  	  {
											$shop_item['Действие / результат'] = 'change error: ошибка при изменении подгруппы товара на ' . $zp_new_artikuls['Подгруппа / тип элемента']; 
											return $shop_item;
	  							  	  	  }
									 	
									 } // end of if ($zp_old_artikuls['Подгруппа / тип элемента'] != $zp_new_artikuls['Подгруппа / тип элемента']) 
									 
										
								} // end of else // если родительский отдел не изменился
								
								break; // end of case 'товар':
								
								
								
							default:
								break;
								 
					   } // end of switch($zp_element['type']) // перебор типов элемента для изменения артикула, подгруппы, называния для некоторых типов
					
					   
					   
					
					   
					// после обработки данных по артикулам помещаем в поля номеров в артикуле сохранённые строки с историей, 
					// убирая маркер изменения ### с начала строки (что значит, что при следующей итерации это поле изменяться не будет)
					foreach ($new_value_with_history as $key => $value)
					{
						//echo '-key = ' . $key . ', old $shop_item[key] = ' . $shop_item[$key] . '<br>';
						// после внесения в базу, сохраняем в поле с названием полную историю изменения названия, лишь убрав из ней первые три символа ### (если они там были)
	 					// перед этим восстанвливаем первоначальный вид кавчек, если они были
						$shop_item[$key] = zp_restore_quotes($new_value_with_history[$key]); // восстанавливаем полное значение поля, если оно имело историю (убирая признак изменения элемента, если он стоял вначале строки.... остальные разделители версий и сами версии названия остаются)
	 					//echo '+key = ' . $key . ', new $shop_item[key] = ' . $shop_item[$key] . '<br>';
					}	   
					   
					
					
					
					
					
					
					
					
					// если изменился артикул, производим необходимые изменения по логотипам и количеству товара...
					
					if($zp_element['zp_artikul'] != $zp_element['zp_old_artikul'])
					{
						// если в поле с логотипом не указан артикул элемента, с которого нужно копировать логотипы,
						// то по умолчанию название логотипа магазина и подотдела формируется на основе зп-артикула
						// (если только в поле с логотипом в таблице не указан артикул элемента, с которого нужно копировать логотипы)
						// и должно быть пересчитано в случае, если изменится зп-артикул
					
						if($zp_element['type'] == 'магазин' OR $zp_element['type'] == 'подотдел')
						{
							// для того, чтобы переименовать логотип, нужно, чтобы в поле 'Логотип' вначале стояли маркеры ### на изменение
							// если не стоят, добавим, а затем добавим это поле в список полей на изменение $shop_item_changed
							$logo_feild = $shop_item['Логотип'];
				
							// уберём управляющие символы из поля, если они там есть, и возьмём последнее значение
							$markers = FALSE;
							if($logo_feild[0] . $logo_feild[1] . $logo_feild[2] != '###') // управляющие символы в начале строки
		 					{
								$shop_item_changed['Логотип'] = '###' . $shop_item['Логотип'];
			 				}

						}
					

						
						// а также нужно изменить артикул и в таблице с количеством товара
						// иначе оно там остаётся старым, и количество товара перестаёт отслеживаться
						
						// для того, чтобы обновить артикул в таблице с количеством товара, нужно, чтобы в поле 'Кол-во' вначале стояли маркеры ### на изменение
						// если не стоят, добавим, а затем добавим это поле в список полей на изменение $shop_item_changed
						$kol_vo = $shop_item['Кол-во'];
						
						// уберём управляющие символы из поля, если они там есть, и возьмём последнее значение
						$markers = FALSE;
						if($kol_vo[0] . $kol_vo[1] . $kol_vo[2] != '###') // управляющие символы в начале строки
		 				{
							$shop_item_changed['Кол-во'] = '###' . $shop_item['Кол-во'];
		 				}
					
					} // end of if($zp_element['zp_artikul'] != $zp_element['zp_old_artikul']) // если изменился артикул, производим необходимые изменения по логотипам и количеству товара...
					
					
					
					
					
					
				
				// ----------------------------------------------------------------------------------------------------------------
				
					   
	   			// конец предварительного определения исходных (и новых) значений артикула, связей и названий картинок, связанных с изменением названием или с изменением артикула
					   
				} // end of if($artikul_changes_exists) // если какой-то из номеров артикула изменился
				
				
				
				
				
					
					// если название файлов картинок формируется на основе названия элемента или zp-артикула
					// и при этом название и/или zp-артикул были изменены, необходимо изменить и названия картинок (если они есть у элемента)
					
					// для этого просто добавляем маркер ### необходимости изменения базы, на основе которой должны формироваться названия картинок
					// сразу перед значением поля 'На основе чего формируется название картинок', если там этот маркер и так уже не стоит
					
					// таким образом, будет дана команда переименовать картинки в новые значения

					
					

					// если картинки формируются на основе названия и название изменено
					// или если картинки формируются на основе зп-артикула и зп-артикул изменён
					// значит необходимо переименовать и картинки
					
					echo '>Штрих-код производителя = ' . $shop_item['Штрих-код производителя'] . '<br>';
					
					if
					(
						($zp_element['source_of_pics'] == 'название' AND $zp_element['старое_название'] != $zp_element['новое_название']) 
						OR ($zp_element['source_of_pics'] == 'зп-артикул' AND $zp_element['zp_artikul'] != $zp_element['zp_old_artikul'])
						OR ($zp_element['source_of_pics'] == 'ш-произв' AND $shop_item['Штрих-код производителя'][0].$shop_item['Штрих-код производителя'][1].$shop_item['Штрих-код производителя'][2] == '###')
					)
					{
						echo 'Нужно менять название картинок <br>';
						
						
						//print '<PRE>';
						//print_r($shop_item_changed);
						//print '</PRE>';
						
						// если в поле со значением базы, на основе которой формируются названия картинок, уже не стоят маркеры изменения ###
						// значит это поле не добавлено и в список изменяемых $shop_item_changed
						
						// значит добавляем маркеры вначало значения поля и затем добавляем это изменённое поле в список изменяемых $shop_item_changed
						if($zp_element['source_of_pics_markers'] != 'start')
						{
							$shop_item_changed['На основе чего формируется название картинок'] = '###' . $shop_item['На основе чего формируется название картинок'];
						}
						
						echo 'xxxxxxxxxxxxxxxx';
						
						//print '<PRE>';
						//print_r($shop_item_changed);
						//print '</PRE>';
						
						
						
						// а если маркеры и так уже в начале значения поля есть, значит и так название картинок будет пересчитываться
						// и само значение этого поля уже добавлено в список изменяемых $shop_item_changed
					}
					
					
					
					
					
				
				
				
				
				
				
				// проверим нужно ли изменять поле Другие атрибуты товара
				// и зададим начальные данные по атрибутам (разберём строку в поле на переменные в массиве)
				// если строка атрибутов задана неправильно, выходим с ошибкой
				
		
				$value = zp_correct_quotes($shop_item['Другие атрибуты товара']);
				$key = 'Другие атрибуты товара'; 
				
				
				if($zp_element['type'] == 'товар' AND $value[0] . $value[1] . $value[2] == '###') // управляющие символы в начале строки
		 		{
					$value = explode('###', $value);
		   	
					foreach($value as $k => $val)
					{
						if($k == 0 OR $k == 1)
		      		  		$new_value_with_history[$key] = $new_value_with_history[$key] . $val;
		    			else  
		      		  		$new_value_with_history[$key] = $new_value_with_history[$key] . '###' . $val;  
					} 
			
					$zp_element['другие_атрибуты_товара'] = $value[1];
					
					//echo '0 zp_element[другие_атрибуты_товара] = ' . $zp_element['другие_атрибуты_товара'] . '<br>';
					
					//if(!$zp_element['другие_атрибуты_товара'] OR $zp_element['другие_атрибуты_товара'] == 'Нет' OR $zp_element['другие_атрибуты_товара'] == 'нет' OR $zp_element['другие_атрибуты_товара'] == '0' OR $zp_element['другие_атрибуты_товара'] == 0 OR $zp_element['другие_атрибуты_товара'] == ' ')
					if(!$zp_element['другие_атрибуты_товара'] OR $zp_element['другие_атрибуты_товара'] == 'Нет' OR $zp_element['другие_атрибуты_товара'] == 'нет' OR $zp_element['другие_атрибуты_товара'] == '0' OR $zp_element['другие_атрибуты_товара'] == ' ')
					{
						//echo '1 zp_element[другие_атрибуты_товара] = ' . $zp_element['другие_атрибуты_товара'] . '<br>';
						$zp_element['другие_атрибуты_товара'] = 'нет';
					}
					else 
					{
						//echo '2 zp_element[другие_атрибуты_товара] = ' . $zp_element['другие_атрибуты_товара'] . '<br>';
						
						// проверим, правильно ли задана строка с атрибутами
						// и разберём исходную строку в массив

     	 
     					//$string = 'text***Цвет***Описание атрибута[Красный^^^0---Зелёный^^^3,40]select***Размер[24^^^1.20---43^^^5.21]';

						if(strpos($zp_element['другие_атрибуты_товара'], ']') === FALSE)
 							$error_format = 1;
 
						$str = explode(']', $zp_element['другие_атрибуты_товара']);

						$count = 0;
						foreach($str as $atr)
						{
							if(!$atr)
	 							continue;
		 
							$xxx = array();
	
							if(strpos($atr, '[') === FALSE)
								$error_format = 1;
 
							$atr = explode('[', $atr);
							//$atr_name_type = $atr[0];
	
							if(strpos($atr[0], '***') === FALSE)
								$error_format = 1;
	
							$atr_name_type = explode('***', $atr[0]);
			
							$atr_type = $atr_name_type[0];
			
							if($atr_type != 'text' AND $atr_type != 'select' AND $atr_type != 'radio')
							{
								$shop_item['Действие / результат'] = 'new error: Неверный формат строки с атрибутами ' . $zp_element['другие_атрибуты_товара'] . '. Тип атрибута может быть только text, select, radio, а задан -' . $atr_type . '-'; 
								return $shop_item;
							}     
			
							$atr_name = $atr_name_type[1];
							$atr_descr = $atr_name_type[2];
	
							if(strpos($atr[1], '---') === FALSE)
								$error_format = 1;
		
							$atr = explode('---', $atr[1]);
			
							$count_options = 0;
							foreach($atr as $options)
							{
								$count_options++;
				
								if(strpos($options, '^^^') === FALSE)
									$error_format = 1;
		
								$option = explode('^^^', $options);
				
				
								// $option[0] - название опции
								// $option[1] - добавка к стоимости, грн
				
								// если в числе содержится не точка, а запятая, меняем запятую на точку
								if(strpos($option[1], ',') !== FALSE)
									$option[1] = str_replace(',', '.', $option[1]);
				
								// Стоимость первой опции в атрибуте должна быть нулевой, тогда цена будет правильно отображаться для пользователя
								// иначе отображаться будет по умолчанию нулевая цена при выбранной опции с ненулевой добавочной ценой
								if($count_options == 1 AND ($option[1] != 0 AND $option[1] != '0.0' AND $option[1] != '0.00' AND $option[1] != '00.00' AND $option[1] != '00.0' AND $option[1] != '' AND $option[1] != ' '))
								{
									$shop_item['Действие / результат'] = 'new error: Неверный формат строки с атрибутами ' . $zp_element['другие_атрибуты_товара'] . '. Стоимость первой опции -' . $option[0] . '- в атрибуте -' . $atr_name . '- должна быть нулевой!'; 
									return $shop_item;
								}
		
								$xxx[$option[0]] = $option[1];
							}
			
							$attributes[$count]['descr'] = $atr_descr;
							$attributes[$count]['type'] = $atr_type;
							$attributes[$count]['name'] = $atr_name;
							$attributes[$count]['options'] = $xxx;
	
							$count++;
						}

						if($error_format == 1)
						{
							$shop_item['Действие / результат'] = 'change error: Неверный формат строки с атрибутами ' . $zp_element['другие_атрибуты_товара']; 
							return $shop_item;
	   					}
	   	
	   					$zp_element['другие_атрибуты_товара'] = $attributes;
	   					
					}
					
	
		 		} // end of if($zp_element['type'] == 'товар' AND $value[0] . $value[1] . $value[2] == '###')
		 		 	// end of проверим нужно ли изменять поле Другие атрибуты товара
					// и зададим начальные данные по атрибутам (разберём строку в поле на переменные в массиве)
					// если строка атрибутов задана неправильно, выходим с ошибкой
	 			
	 			
	 			
	
				
				
				
			
				
	
   	
    
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				// если в полях Логотип (оно используется для подотдела и магазина) или с источником названия картинок в таблице 
				// задан артикул элемента, с которого нужно брать картинки для показа на странице
				
//-------------------------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------------------------

				
				// определим содержимое полей "На основе чего формируется название картинок", "Кол-во картинок"  и "Логотип"
				// и должны ли они изменяться
				
		 		
				$value = zp_correct_quotes($shop_item['На основе чего формируется название картинок']);
				$key = 'На основе чего формируется название картинок'; 
				$pics_changes_exists = 0;
				
				if($value[0] . $value[1] . $value[2] == '###') // управляющие символы в начале строки
		 		{
					$value = explode('###', $value);
		   	
					foreach($value as $k => $val)
					{
						if($k == 0 OR $k == 1)
		      		  		$new_value_with_history[$key] = $new_value_with_history[$key] . $val;
		    			else  
		      		  		$new_value_with_history[$key] = $new_value_with_history[$key] . '###' . $val;  
					} 
			
					//$value_old = $value[2];
					$value = $value[1];
						
					$pics_changes_exists = 1;  // значит какой-то из номеров артикула изменился
		 		}
		 		else if(strpos($value, '###') !== FALSE) // управляющие символы в середине строки
		 		{
		 			$value = explode('###', $value);
		   	
					foreach($value as $k => $val)
					{
						if($k == 0)
	      	 		 	 	$new_value_with_history[$key] = $new_value_with_history[$key] . $val;
	    				else  
	      	 		 	 	$new_value_with_history[$key] = $new_value_with_history[$key] . '###' . $val;  
					} 
			
					//$value_old = $value[1];
					$value = $value[0];
					//$value_old = $value;
					
					//echo ' hist --- key = ' . $key . ', new value = ' . $value . ', old value = ' . $value_old . '<br>';
	 			}
	 			
	 			$zp_element['source_of_pics'] = $value;

		 		// после обработки данных по артикулам помещаем в поля номеров в артикуле сохранённые строки с историей, 
				// убирая маркер изменения ### с начала строки (что значит, что при следующей итерации это поле изменяться не будет)
		 		//$shop_item[$key] = zp_restore_quotes($new_value_with_history[$key]);
		 			
				

		 		//---------------
		 		
		 		
		 		
				$value = zp_correct_quotes($shop_item['Кол-во картинок']);
				$key = 'Кол-во картинок'; 
				$pics_amount_changes_exists = 0;
				
				if($value[0] . $value[1] . $value[2] == '###') // управляющие символы в начале строки
		 		{
					$value = explode('###', $value);
		   	
					foreach($value as $k => $val)
					{
						if($k == 0 OR $k == 1)
		      		  		$new_value_with_history[$key] = $new_value_with_history[$key] . $val;
		    			else  
		      		  		$new_value_with_history[$key] = $new_value_with_history[$key] . '###' . $val;  
					} 
			
					//$value_old = $value[2];
					$value = $value[1];
						
					$pics_amount_changes_exists = 1;  // значит какой-то из номеров артикула изменился
		 		}
		 		else if(strpos($value, '###') !== FALSE) // управляющие символы в середине строки
		 		{
		 			$value = explode('###', $value);
		   	
					foreach($value as $k => $val)
					{
						if($k == 0)
	      	 		 	 	$new_value_with_history[$key] = $new_value_with_history[$key] . $val;
	    				else  
	      	 		 	 	$new_value_with_history[$key] = $new_value_with_history[$key] . '###' . $val;  
					} 
			
					//$value_old = $value[1];
					$value = $value[0]; // это значение не используется... используется только история в этом поле
					//$value_old = $value;
					
					//echo ' hist --- key = ' . $key . ', new value = ' . $value . ', old value = ' . $value_old . '<br>';
	 			}
	 			
	 			//$pics_amount = $value; // это значение всё равно не используется. Из этого нам нужна только история изменений поля с количеством картинок

		 		// после обработки данных по артикулам помещаем в поля номеров в артикуле сохранённые строки с историей, 
				// убирая маркер изменения ### с начала строки (что значит, что при следующей итерации это поле изменяться не будет)
		 		//$shop_item[$key] = zp_restore_quotes($new_value_with_history[$key]);
		 		
		 		
		 		
		 		//---------------
		 		
		 		
				
				$value = zp_correct_quotes($shop_item['Логотип']);
				$key = 'Логотип'; 
				$changes_exists = 0;
				
				if($value[0] . $value[1] . $value[2] == '###') // управляющие символы в начале строки
		 		{
					$value = explode('###', $value);
		   	
					foreach($value as $k => $val)
					{
						if($k == 0 OR $k == 1)
		      		  		$new_value_with_history[$key] = $new_value_with_history[$key] . $val;
		    			else  
		      		  		$new_value_with_history[$key] = $new_value_with_history[$key] . '###' . $val;  
					} 
			
					//$value_old = $value[2];
					$value = $value[1];
						
					$logo_changes_exists = 1;  // значит какой-то из номеров артикула изменился
		 		}
		 		else if(strpos($value, '###') !== FALSE) // управляющие символы в середине строки
		 		{
		 			$value = explode('###', $value);
		   	
					foreach($value as $k => $val)
					{
						if($k == 0)
	      	 		 	 	$new_value_with_history[$key] = $new_value_with_history[$key] . $val;
	    				else  
	      	 		 	 	$new_value_with_history[$key] = $new_value_with_history[$key] . '###' . $val;  
					} 
			
					//$value_old = $value[1];
					$value = $value[0];
					//$value_old = $value;
					
					//echo ' hist --- key = ' . $key . ', new value = ' . $value . ', old value = ' . $value_old . '<br>';
	 			}
	 			
	 			$zp_element['logo'] = $value;
	 			
	 			// после обработки данных по артикулам помещаем в поля номеров в артикуле сохранённые строки с историей, 
				// убирая маркер изменения ### с начала строки (что значит, что при следующей итерации это поле изменяться не будет)
		 		//$shop_item[$key] = zp_restore_quotes($new_value_with_history[$key]);
		 		
		 		
		 		
		 		
		 		
		 		//--------------------------------------------------------
	

		 			
		 		// first pics - проверка существования элемента, указаннаного источником картинок
		 		
		 		// если задано обновление поля 'На основе чего формируется название картинок'
				// и в этом поле указан артикул 
				
				// уточняем этот артикул
				// и проверяем, существует ли такой элемент
				if($pics_changes_exists == 1)
				{ 
				 if(strpos($zp_element['source_of_pics'], 'copy *z') !== FALSE)
				  {
					
					// определим артикул элемента-источника
	
  	 				$artikul_of_pic_source = explode("copy *", $zp_element['source_of_pics']);
  	 				$zp_element['artikul_of_pic_source'] = $artikul_of_pic_source[1];
  	 	
  	 	
  	 				// если задано использование картинок из другого элемента, проверим, существует ли этот другой элемент
  	 				// заметим, что соответствие типов не проверяется, это должен делать сам менеджер
  	 	
  	 				// данные об артикулах содержатся в разных таблицах для разных типов данных
  	 	
			  	 	if($zp_element['type'] == 'товар')
  	 				{
 						if( 
							!db_result(db_query("SELECT nid from {uc_products} WHERE model = '%s'", $zp_element['artikul_of_pic_source']))
	  	  	  			  )
	  	  	  			  {
							$shop_item['Действие / результат'] = 'change error: в базе отсутствует товар с артикулом ' . $zp_element['artikul_of_pic_source'] . ', из которого должны браться логотипы для текущего элемента'; 
							return $shop_item;
	   	  	  			  }
  	 				}
  	 				else 
  	 				{
  	 					if( 
							!db_result(db_query("SELECT nid from {content_field_zp_art_place} WHERE field_zp_art_place_value = '%s'", $zp_element['artikul_of_pic_source']))
	  	  	  			  )
	  	  	  			  {
							$shop_item['Действие / результат'] = 'change error: в базе отсутствует элемент с артикулом ' . $zp_element['artikul_of_pic_source'] . ', из которого должны браться логотипы для текущего элемента'; 
							return $shop_item;
	   	  	  			  }
  	 				}
				
				  } // end of if(strpos($zp_element['source_of_pics'], 'copy *z') !== FALSE)
				
				} // end of if($pics_changes_exists == 1)
				
				
		 		
				//---------------
				
		 		
		 		
				// first logo - проверка существования элемента, указаннаного источником логотипов
				
				// если задано обновление поля, на основе которого формируется название логотипов
				// и текущий элемент - магазин или подотдел (только они могут иметь логотипы)
				// и в поле 'Логотип' указан артикул 
				
				// уточняем этот артикул
				// и проверяем, существует ли такой элемент
				if($logo_changes_exists == 1 AND ($zp_element['type'] == 'магазин' OR $zp_element['type'] == 'подотдел'))
				{
				 if(strpos($zp_element['logo'], 'copy *z') !== FALSE)
				  {
				  	
  	 				$artikul_of_logo_source = explode("copy *", $zp_element['logo']);
  	 				$zp_element['artikul_of_logo_source'] = $artikul_of_logo_source[1];
  	 	
  	 				// проверим, а существует ли такой товар с указанным артикулом
  	 				// заметим, что не выполняется проверка на то, является этот элемент магазином или подотделом (которые имеют логотипы)
  	 				// это должен контролировать сам менеджер
  	 	
 					if( 
						!db_result(db_query("SELECT nid from {content_field_zp_art_place} WHERE field_zp_art_place_value = '%s'", $zp_element['artikul_of_logo_source']))
	  	  			  )
	  	  			  {
						$shop_item['Действие / результат'] = 'change error: в базе отсутствует элемент с артикулом ' . $zp_element['artikul_of_logo_source'] . ', из которого должны браться логотипы для текущего элемента'; 
			 			return $shop_item;
	   	  			  }
				  }

				} // end of if($logo_changes_exists == 1)


				
				
				//--------------------------------------------------------
				
				
				
				
				// second pics - внесение данных об источнике картинок, если он задан
				
				// если задано обновление поля 'На основе чего формируется название картинок'
				// и в этом поле указан артикул 
				
				// на этом этапе известно, что элемент-источник картинок существует

				// убираем данные о картинках из элемента
				// и добавляем запись об этом артикуле в специальную таблицу
				if($pics_changes_exists == 1)
				{ 
					
				 echo 'source_of_pics >>>>>>>>>>>>> ' . $zp_element['source_of_pics'] . '<br>';
					
				 if(strpos($zp_element['source_of_pics'], 'copy *z') !== FALSE)
				  {

					// чтобы убрать данные о картинках, достаточно в поля, подготовленные к обработке (изменению)
					// в рабочем массиве $shop_item_changed добавить (или изменить, если такое поле уже есть в этом массиве)
					// в него поле 'Кол-во картинок' со значением '0' (ноль картинок) и инструкцией к обновлению "###"
					// С такой инструкцией дальнейшая программа удалит все картинки из этого элемента, 
					// а затем запишет в таблицу изменённое поле с историей
					$shop_item_changed['Кол-во картинок'] = '###' . '0' . '###' . $new_value_with_history['Кол-во картинок'];
					
					// добавляем в базу запись об артикуле элемента, с которого нужно копировать данные о картинках
					
					// если запись УЖЕ существует, там может быть записана ссылка на другой элемент (а не на элемент, указанный сейчас в таблице как источник картинок)
					// так что если запись существует, обновляем её, а если нет, создаём новую
					

					if( 
						db_result(db_query("SELECT nid from {content_field_source_of_pics} WHERE nid = %d", $node->nid))
		  			  )
		  			  {
						if( 
							!db_query("UPDATE {content_field_source_of_pics} SET field_source_of_pics_value = '%s' WHERE nid = %d", $zp_element['artikul_of_pic_source'], $node->nid)
		  			  	  )
		  			  	  {
							$shop_item['Действие / результат'] = 'change error: ошибка при обновлении поля со ссылкой на источник картинок в базе со значением артикула элемента-источника ' . $zp_element['artikul_of_pic_source']; 
							return $shop_item;
		  			  	  }
		  			  }
		  			  else 
		  			  {
		  			  	if( 
							!db_query("INSERT INTO {content_field_source_of_pics} (field_source_of_pics_value, nid, vid) VALUES ('%s', %d, %d)", $zp_element['artikul_of_pic_source'], $node->nid, $node->vid)
		  			  	  )
		  			  	  {
							$shop_item['Действие / результат'] = 'change error: ошибка при добавлении поля со ссылкой на источник картинок в базе со значением артикула элемента-источника ' . $zp_element['artikul_of_pic_source']; 
							return $shop_item;
		  			  	  }
		  			  }

					
				  }
				  else  // иначе (в качестве источника лого устанавливается не другой элемент)... 
				  {
					
					// если в базе уже есть такая запись об использовании картинок другого элемента этим элементом
					// удаляем её
					
					if( // если ранее было задано копирование картинок из другого элемента, удалить эту запись из базы
			
			 			db_result(db_query("SELECT nid from {content_field_source_of_pics} WHERE nid = %d", $node->nid))
		  			  )
		  			  {
						if( 
			 				!(db_query('DELETE FROM {content_field_source_of_pics} WHERE nid = %d', $node->nid))
		  	  			  )
		  	  			  {
		  					$shop_item['Действие / результат'] = 'change error: ошибка при удалении старой записи об источнике картинок'; 
							return $shop_item;
		      			  }

		  			  } // end of if( // если ранее было задано копирование картинок из другого элемента, удалить эту запись из базы
		  			  
		  			  
				   } // end of else  // иначе (в качестве источника лого устанавливается не другой элемент)... 
				   
				   
				} // end of if($pics_changes_exists == 1)
				
				
				
				
				//---------------
				
				
				
				
				// second logo - внесение данных об источнике логотипов, если источник задан
				
				// если задано обновление поля, на основе которого формируется название логотипов
				// и текущий элемент - магазин или подотдел (только они могут иметь логотипы)
				// и в поле 'Логотип' указан артикул 
				
				// на этом этапе известно, что элемент с указанным артикулом существует
				// значит заносим информацию о нём в базу и даём указание дальнейшей части этой функции удалить старые картинки
				if($logo_changes_exists == 1 AND ($zp_element['type'] == 'магазин' OR $zp_element['type'] == 'подотдел'))
				{
				 if(strpos($zp_element['logo'], 'copy *z') !== FALSE)
				  {

					// чтобы убрать данные о логотипе, достаточно в поля, подготовленные к обработке (изменению)
					// в рабочем массиве $shop_item_changed добавить (или изменить, если такое поле уже есть в этом массиве)
					// в него поле 'Логотип' со значением 'нет' и инструкцией к обновлению "###"
					// а затем запишет в таблицу изменённое поле с историей
					$shop_item_changed['Логотип'] = '###' . 'нет' . '###' . $new_value_with_history['Логотип'];

					// добавляем в базу запись об артикуле элемента, с которого нужно копировать данные о логотипе
					
				
					if( 
						db_result(db_query("SELECT nid from {content_field_source_of_logo} WHERE nid = %d", $node->nid))
		  			  )
		  			  {
						if( 
							!db_query("UPDATE {content_field_source_of_logo} SET field_source_of_logo_value = '%s' WHERE nid = %d", $zp_element['artikul_of_logo_source'], $node->nid)
		  			  	  )
		  			  	  {
							$shop_item['Действие / результат'] = 'change error: ошибка при обновлении поля со ссылкой на источник логотипов в базе со значением артикула элемента-источника ' . $zp_element['artikul_of_logo_source']; 
							return $shop_item;
		  			  	  }
		  			  }
		  			  else 
		  			  {
		  			  	if( 
							!db_query("INSERT INTO {content_field_source_of_logo} (field_source_of_logo_value, nid, vid) VALUES ('%s', %d, %d)", $zp_element['artikul_of_logo_source'], $node->nid, $node->vid)
		  			  	  )
		  			  	  {
							$shop_item['Действие / результат'] = 'change error: ошибка при добавлении поля со ссылкой на источник логотипов в базе со значением артикула элемента-источника ' . $zp_element['artikul_of_logo_source']; 
							return $shop_item;
		  			  	  }
		  			  }
		  			  

  	 			  }
				  else // иначе (в качестве источника лого устанавливается не другой элемент)... 
				  {
					// если в базе уже есть такая запись об использовании логотипов другого элемента этим элементом
					// удаляем её
					
					if( // если ранее было задано копирование картинок из другого элемента, удалить эту запись из базы
			 			db_result(db_query("SELECT nid from {content_field_source_of_logo} WHERE nid = %d", $node->nid))
		  			  )
		  			  {
						if( 
			 				!(db_query('DELETE FROM {content_field_source_of_logo} WHERE nid = %d', $node->nid))
		  	 			  )
		  	 			  {
		  					$shop_item['Действие / результат'] = 'change error: ошибка при удалении старой записи об источнике картинок логотипов'; 
							return $shop_item;
		      			  }

		  			  } // end of if( // если ранее было задано копирование картинок из другого элемента, удалить эту запись из базы
		  			  
				   } // end of else // иначе (в качестве источника лого устанавливается не другой элемент)... 
				   
				} // end of if($logo_changes_exists == 1)


				
				
				
				
				
				
//-----------------------------------------------------------------------------------------------------------------------------------------				
//-----------------------------------------------------------------------------------------------------------------------------------------				
				
				










				
				
				
				
				
				

	// -------------------------------------------------------------------------------------
	// теперь последовательно изменяем остальные поля, которые нужно изменить

	
				
	// отметим факт изменения элемента, изменив дату изменения и юзера для ноды и её ревизии	

	global $user;
	$node->uid = $user->uid;
						 
	if(
		!db_query("UPDATE {node} SET uid = %d, changed = %d WHERE nid = %d AND vid = %d", $node->uid, time(), $node->nid, $node->vid)
			OR
		!db_query("UPDATE {node_revisions} SET uid = %d, timestamp = %d WHERE nid = %d AND vid = %d", $node->uid, time(), $node->nid, $node->vid)
	  )
	  {
		$shop_item['Действие / результат'] = 'change error: ошибка при обновлении времени изменения элемента и идентификатора пользователя, производящего изменения' . $key . 'в базе на значение ' . $value; 
		return $shop_item;
	  }
			
	
	  
	foreach($shop_item_changed as $key => $value)
	{
		echo '<br> 0 shop_item_changed as key => value' . $key . ' => ' . $value . '<br>';
		switch($key)
		{
			
		
		case 'Название': 
			echo 'Название';
		 	
			break;
		 
		case 'На основе чего формируется название картинок':
			
			echo 'На основе чего формируется название картинок';
			break;
		
		}
	}
	  
	
	
	// последовательно изменяем в элементе все поля, которые требуют изменения, в зависимости от названия поля			
	foreach($shop_item_changed as $key => $value)
	{
		
		
		
		echo '<br> 1 shop_item_changed as key => value' . $key . ' => ' . $value . '<br>';
		
		
		// исправим лишние кавычки, если есть
		$value = zp_correct_quotes($value);

			
		// для начала извлечём из значения поля ту часть, которая должна быть записана как новое значение
		// и сохраним всю историю изменений, удалив признак изменения для записи результирубщей таблицы
		$new_value_with_history = FALSE;
		if($value[0] . $value[1] . $value[2] == '###') // управляющие символы в начале строки
		 {
			$value = explode('###', $value);
		  	
			foreach($value as $k => $val)
			{
				if($k == 0 OR $k == 1)
		 		  $new_value_with_history = $new_value_with_history . $val;
				else  
		 		  $new_value_with_history = $new_value_with_history . '###' . $val;  
			} 
			
			$value = $value[1];
		}
		 		
		
		echo '<br> 2 Поле к изменению = ' . $key . ', новое значение = ' . $value . '<br>';
		// -------------------------------------------------------------------
		
	

		
		// перебираем значения полей, вернее, выбираем какое поле обрабатывается на очередной итерации	
		// в данном случае поля, которые касаются в основном разных элементов	
		switch($key) 
		{
			
			
			case 'Подгруппа / тип элемента': 
			
				echo '<br> >>>>Подгруппа / тип элемента' . $value . '<br>'; 
				
				if(
					!db_query("UPDATE {content_field_place_type} SET field_place_type_value = '%s' WHERE nid = %d AND vid = %d", $value, $node->nid, $node->vid)
				  )
				  {
				  	$shop_item['Действие / результат'] = 'change error: ошибка при изменении поля -' . $key . '- в базе на значение ' . $value; 
						return $shop_item;
				  }
			
				break;
			

				
				
				
			
			
			case 'Название': 
			
			
				// изменяем значение поля название в двух таблицах, содержащих название
				if(
					!db_query("UPDATE {node} SET title = '%s' WHERE nid = %d AND vid = %d", $value, $node->nid, $node->vid)
				       OR
				    !db_query("UPDATE {node_revisions} SET title = '%s' WHERE nid = %d AND vid = %d", $value, $node->nid, $node->vid)
				  )
				  {
				  	$shop_item['Действие / результат'] = 'change error: ошибка при изменении поля -' . $key . '- в базе на значение ' . $value; 
						return $shop_item;
				  }

				echo '<br> 32 Поле к изменению = ' . $key . ', новое значение = ' . $value . '<br>';
				  
				break;
			
				
				
				
				
				
				
			case 'Описание': 

				// изменяем значение поля Описание в двух таблицах, содержащих название
				// а заодно меняем время изменения ноды и пользователя (для истории)
				// способ изменения Описания зависит от типа элемента (данные заносятся в разные таблицы)
				switch($zp_element['type'])
				{
					case 'страна':
					case 'населённый пункт': // обычно город
					case 'район':
					case 'магазин':
					case 'подотдел':
						
						if(
							!db_query("UPDATE {content_field_description} SET field_description_value = '%s' WHERE nid = %d AND vid = %d", $value, $node->nid, $node->vid)
						  )
						  {
				  			$shop_item['Действие / результат'] = 'change error: ошибка при изменении поля' . $key . 'в базе на значение ' . $value; 
							return $shop_item;
				  		  }

						break;
						
						
						
					case 'товар':
						
						
						/*
						// сформируем название поля с описанием в базе из названия типа товара
						//$descr_field_name = explode('product_', $node->type); 
						//$descr_field_name = $descr_field_name[1];
						//$descr_field_name = 'field_p_' . $descr_field_name .'_descr_value';

						if(
							!db_query("UPDATE {content_type_" . $node->type . "} SET " . $descr_field_name . " = '%s' WHERE nid = %d AND vid = %d", $value, $node->nid, $node->vid)
						  )
						  {
				  			$shop_item['Действие / результат'] = 'change error: ошибка при изменении поля' . $key . 'в базе на значение ' . $value; 
							return $shop_item;
				  		  }						
						*/
				  		  
				  		 //внесём описание продукта (для всех типов продуктов теперь храним описание в одной таблице - для сокращения количества таблиц)
			
						if( 
							!db_query("UPDATE {content_field_product_descr} SET field_product_descr_value = '%s' WHERE nid = %d AND vid = %d", $value, $node->nid, $node->vid)
			  			  )
			  			  {
							$shop_item['Действие / результат'] = 'change error: ошибка при изменении описания продукта на значение -' . $zp_element['описание_элемента'] . '- '; 
							return $shop_item;
			  			  } 
				  		  
				  		  
						break;
					
						
						
					default:
						break;
				}		
				
				break;
				
				
				
				
				
				
						
			case 'Адрес': 
			
				echo '<br>адрес ============ ' . $value . '<br>';
				echo 'node->nid = ' . $node->nid . ', node->vid = ' . $node->vid . '<br>';

				switch($zp_element['type'])
				{
					case 'страна':
					case 'подгруппа':
					case 'товар':
						// страна, подотдел, подгруппа и товар не имеют адреса, поэтому пропускаем это поле
						break;
								
					case 'населённый пункт': // обычно город
					case 'район':
					case 'магазин':
					case 'подотдел':	

						echo '<br>адрес ============ ' . $value . '<br>';	
						echo 'node->nid = ' . $node->nid . ', node->vid = ' . $node->vid . '<br>';			

						
						//print '<PRE>';
						//print_r($xxx);
						//print '</PRE>';
						
						if(
							!($address_nid = db_result(db_query("SELECT vid FROM {content_field_place_address} WHERE nid = %d", $node->nid)))
						  )
						  {
				  			if( // если адрес не был задан изначально, попытаться его внести
						  		!db_query("INSERT INTO {content_field_place_address} (field_place_address_value, nid, vid) VALUES ('%s', %d, %d)", $value, $node->nid, $node->vid)
						      )
						      {
						  		$shop_item['Действие / результат'] = 'change error: ошибка при добавлении поля -' . $key . '- в базе на значение ' . $value; 
								return $shop_item;
						      }
				  		  }
				  		else
				  		  { 
				  		    if( // если адрес был задан изначально, изменить его
						  		!db_query("UPDATE {content_field_place_address} SET field_place_address_value = '%s' WHERE nid = %d AND vid = %d", $value, $node->nid, $node->vid)
						      )
						      {
						  		$shop_item['Действие / результат'] = 'change error: ошибка при изменении поля -' . $key . '- в базе на значение ' . $value; 
								return $shop_item;
						      }
				  		  }
						break;						

						
						
					default:
						break;
				}
				
				break; // end of case 'Адрес': 
			
				
				
				
				
				
				
				
			case 'Кол-во картинок':
				
				switch($zp_element['type']) // получим данные о заданных в базе картинках
				{
					
					case 'страна':
					case 'населённый пункт': // обычно город
					case 'район':
					case 'магазин':
					case 'подотдел':						

					    $files = db_query("SELECT delta, field_place_img_fid FROM {content_field_place_img} WHERE vid = %d AND nid = %d", $node->vid, $node->nid);
					    
					    $db_count = 0;
						while($file = db_fetch_object($files))
						{
			    			$file_pics[$count]['fid'] = $file->field_place_img_fid;
			    			$file_pics[$count]['delta'] = $file->delta;
			    			$db_count++;
			    		}
				
					    break;
					    
					    
					case 'товар':
						
						// сформируем название поля с описанием в базе из названия типа товара
						//$type_of_product = explode('product_', $node->type); 
						//$type_of_product = $type_of_product[1];
					    //$files = db_query("SELECT delta, field_p_" . $type_of_product . "_img_fid FROM {content_field_p_" . $type_of_product . "_img} WHERE vid = %d AND nid = %d", $node->vid, $node->nid);
					    
					    $files = db_query("SELECT delta, field_product_img_fid FROM {content_field_product_img} WHERE vid = %d AND nid = %d", $node->vid, $node->nid);
					    
					    // выясним, сколько у элемента уже картинок	    
						$db_count = 0;
						while($file = db_fetch_object($files))
						{
			    			$file_pics[$count]['fid'] = $file->field_product_img_fid;
			    			$file_pics[$count]['delta'] = $file->delta;
			    			$db_count++;
			    		}
					    
					    break;
					    
					    
					case 'подгруппа': // у подгруппы нет картинок
					default:
						// если в таблице не задано, как формируется картинка, прекращаем обработку этого элемента с грозным сообщением :)
						$shop_item['Действие / результат'] = 'change error: неправильный тип элемента ' .$zp_element['type'] . ' при изменении количества картинок'; 
						return $shop_item;
						
				} // end of switch($zp_element['type']) // получим данные о заданных в базе картинках
				
				if(!$db_count)
				  $db_count = 0;
				
				
			    
			    // если количество картинок в базе равно новому числу в таблице, пропускаем изменение
			    if($value == $db_count) 
					break; 
				

							
				// если необходимо увеличить количество картинок, увеличиваем
				if($value > $db_count) 
				{
					// определим, как формируется название картинок

					
					// определим базу для формирования названий картинок
					
					switch($zp_element['source_of_pics']) // На основе чего формируется название картинок
	    			{
						case 'название':
							if(!$zp_element['новое_название'])
							{
								$shop_item['Действие / результат'] = 'change error: не задано название элемента, а на его основе должны формироваться названия картинок'; 
								return $shop_item;
							}
							
							$pic_name_base = $zp_element['новое_название']; //$shop_item['Название'];
							break;
			
							
							
						case 'зп-артикул':
							if(!$zp_element['zp_artikul'])
							{
								$shop_item['Действие / результат'] = 'change error: не задан внутренний артикул-зп элемента, а на его основе должны формироваться названия картинок'; 
								return $shop_item;
							}
							
							$pic_name_base = $zp_element['zp_artikul'];
							break;

							
							
						case 'ш-произв':

							if(!$shop_item['Штрих-код производителя'])
							{
								$shop_item['Действие / результат'] = 'change error: не задан штрих-код производителя, а на его основе должны формироваться названия картинок'; 
								return $shop_item;
							}
							
							$val = zp_correct_quotes($shop_item['Штрих-код производителя']);

							if($val[0] . $val[1] . $val[2] == '###')
		 					{
								$val = explode('###', $val);
								$val = $val[1];
		 					}
		 					else if(strpos($val, '###') !== FALSE)
		 					{
		 						$val = explode('###', $val);
								$val = $val[0];
		 					}
							
							// убираем лишнее промежуточное действие
		 					//$zp_element['штрих_код_произв']	= $val;				
							//$pic_name_base = $zp_element['штрих_код_произв'];
							
							$pic_name_base = $val;
							break;

							
							
						case 'арт-произв':
							
							if(!$shop_item['Арт. Произв'])
							{
								$shop_item['Действие / результат'] = 'change error: не задан артикул производителя, а на его основе должны формироваться названия картинок'; 
								return $shop_item;
							}
							
							$val = zp_correct_quotes($shop_item['Арт. Произв']);

							if($val[0] . $val[1] . $val[2] == '###')
		 					{
								$val = explode('###', $val);
								$val = $val[1];
		 					}
		 					else if(strpos($val, '###') !== FALSE)
		 					{
		 						$val = explode('###', $val);
								$val = $val[0];
		 					}
							
							// убираем лишнее промежуточное действие
		 					//$zp_element['артикул_произв']	= $val;				
							//$pic_name_base = $shop_item['Арт. Произв'];
							
							$pic_name_base = $val;
							break;
		
							
							
							
						case 'ш-поставщ':
							
							if(!$shop_item['Штрих-код поставщика'])
							{
								$shop_item['Действие / результат'] = 'change error: не задан штрих-код поставщика, а на его основе должны формироваться названия картинок'; 
								return $shop_item;
							}
							
							$val = zp_correct_quotes($shop_item['Штрих-код поставщика']);

							if($val[0] . $val[1] . $val[2] == '###')
		 					{
								$val = explode('###', $val);
								$val = $val[1];
		 					}
		 					else if(strpos($val, '###') !== FALSE)
		 					{
		 						$val = explode('###', $val);
								$val = $val[0];
		 					}
							
							// убираем лишнее промежуточное действие
		 					//$zp_element['штрих_код_поставщ'] = $val;				
							//$pic_name_base = $shop_item['Штрих-код поставщика'];
							
							$pic_name_base = $val;
							break;
			
							
							
						case 'арт-поставщ':
							
							if(!$shop_item['Арт. Поставщ'])
							{
								$shop_item['Действие / результат'] = 'change error: не задан артикул поставщика, а на его основе должны формироваться названия картинок'; 
								return $shop_item;
							}
							
							$val = zp_correct_quotes($shop_item['Арт. Поставщ']);

							if($val[0] . $val[1] . $val[2] == '###')
		 					{
								$val = explode('###', $val);
								$val = $val[1];
		 					}
		 					else if(strpos($val, '###') !== FALSE)
		 					{
		 						$val = explode('###', $val);
								$val = $val[0];
		 					}
							
							// убираем лишнее промежуточное действие
		 					//$zp_element['артикул_поставщ'] = $val;				
							//$pic_name_base = $shop_item['Арт. Поставщ'];
							
							$pic_name_base = $val;
							break;
							
							
			
						case 'ш-магазина':
							
							if(!$shop_item['Штрих-код магазина'])
							{
								$shop_item['Действие / результат'] = 'change error: не задан штрих-код магазина, а на его основе должны формироваться названия картинок'; 
								return $shop_item;
							}
							
							$val = zp_correct_quotes($shop_item['Штрих-код магазина']);

							if($val[0] . $val[1] . $val[2] == '###')
		 					{
								$val = explode('###', $val);
								$val = $val[1];
		 					}
		 					else if(strpos($val, '###') !== FALSE)
		 					{
		 						$val = explode('###', $val);
								$val = $val[0];
		 					}
							
							// убираем лишнее промежуточное действие
		 					//$zp_element['штрих_код_магазина'] = $val;				
							//$pic_name_base = $shop_item['Штрих-код магазина'];
							
							$pic_name_base = $val;
							break;
			
							
							
						case 'арт-магазина':
							
							if(!$shop_item['Арт. Магазина'])
							{
								$shop_item['Действие / результат'] = 'change error: не задан артикул магазина, а на его основе должны формироваться названия картинок'; 
								return $shop_item;
							}
							
							$val = zp_correct_quotes($shop_item['Арт. Магазина']);

							if($val[0] . $val[1] . $val[2] == '###')
		 					{
								$val = explode('###', $val);
								$val = $val[1];
		 					}
		 					else if(strpos($val, '###') !== FALSE)
		 					{
		 						$val = explode('###', $val);
								$val = $val[0];
		 					}
							
							// убираем лишнее промежуточное действие
		 					//$zp_element['артикул_магазина'] = $val;				
							//$pic_name_base = $shop_item['Арт. Магазина'];
							
							$pic_name_base = $val;
							break;
				
							
							
						default:
							//if(strpos($zp_element['source_of_pics'], 'copy *z') !== FALSE) // если строка содержит указание на то, что картинки должны использоваться из другого товара
								//break 2;  // значит пропускаем это поле и переходим к следующему
								 		 // или тут 3 должно стоять??????

							// иначе..
							
							// если в таблице не задано, как формируется картинка, прекращаем обработку этого элемента с грозным сообщением :)
							$shop_item['Действие / результат'] = 'change error: не задано, как формируется название картинок для поля -' . $key . '- и его нового значения ' . $value; 
							return $shop_item;
				
	    			} // end of switch($shop_item['На основе чего формируется название картинок'])
					
	    			
	    			
	    			// если количество картинок надо будет уменьшать (следующая проверка условвия), то и название картинок нам ни к чему
					// поэтому вычисляем название картинок только в этом варианте
					

	    			// транслитерируем базу для формирования названия картинок
	    			// на случай, если база содержит кириллицу
	    			$pic_name_base = translit_no_spaces($pic_name_base);
	    			
	    			echo 'pic_name_base >>>>>>>>>>>>>>>> ' . $pic_name_base . '<br>';
	    			echo 'value >>>>>>>>>>>>>>>> ' . $value . '<br>';
	    			
					for($f_count = $db_count + 1; $f_count <= $value; $f_count++) // добавляем такое количество картинок, которое необхоимо добавить к заданному в базе до заданного в таблице
					{
						
						echo 'count <<<<<<<<<< ' . $f_count . '<br>';

						$fid = db_next_id('{files}_fid');
	    				$delta = $f_count - 1; // т.к. дельта начинается с нуля, а нумерация картинок с еденицы
	    	
	    				$filename = $pic_name_base . '-p' . $f_count . '.jpg';
	    				$filepath = 'files/' . $zp_element['pics_path'] . '/' . $filename;
	    				$filemime = 'image/jpeg';
	    				$filesize = '';
	    	
						$file_title = '';
						$file_alt = '';
			
	    				switch($zp_element['type'])
	    				{
	    					case 'страна':
							case 'населённый пункт':	
	 						case 'район':
	 						case 'магазин':
	 						case 'подотдел':

	 							db_query("INSERT INTO {files} (fid, nid, filename, filepath, filemime, filesize) VALUES (%d, %d, '%s', '%s', '%s', %d)", $fid, $node->nid, $filename, $filepath, $filemime, $filesize);
	 							db_query("INSERT INTO {content_field_place_img} (vid, delta, nid, field_place_img_fid, field_place_img_title, field_place_img_alt) VALUES (%d, %d, %d, %d, '%s', '%s')", $node->vid, $delta, $node->nid, $fid, $file_title, $file_alt);
	    						break;
	    				
	    					case 'товар':
	    						
	    						// для того, чтобы заносить инфу о картинках в разные таблицы и поля для разных типов продуктов
	    						// сформируем название таблицы и поля в базе из названия типа товара
								//$type_of_product = explode('product_', $node->type); 
								//$type_of_product = $type_of_product[1];
								//$type_of_product = 'content_field_p_' . $type_of_product .'_img';
								
								db_query("INSERT INTO {files} (fid, nid, filename, filepath, filemime, filesize) VALUES (%d, %d, '%s', '%s', '%s', %d)", $fid, $node->nid, $filename, $filepath, $filemime, $filesize);
	    						//db_query("INSERT INTO {content_field_p_" . $type_of_product . "_img} (vid, delta, nid, field_p_" . $type_of_product . "_img_fid, field_p_" . $type_of_product  . "_img_title, field_p_" . $type_of_product . "_img_alt) VALUES (%d, %d, %d, %d, '%s', '%s')", $node->vid, $delta, $node->nid, $fid, $file_title, $file_alt);
	    						db_query("INSERT INTO {content_field_product_img} (vid, delta, nid, field_product_img_fid, field_product_img_title, field_product_img_alt) VALUES (%d, %d, %d, %d, '%s', '%s')", $node->vid, $delta, $node->nid, $fid, $file_title, $file_alt);
					    		break;
	    				
	    					default:
    							// если в таблице не задано, как формируется картинка, прекращаем обработку этого элемента с грозным сообщением :)
								$shop_item['Действие / результат'] = 'change error: неправильный тип элемента ' .$zp_element['type'] . ' при изменении количества картинок'; 
								return $shop_item;
    					
	    				} // end of switch($zp_element['type'])
	    				
	    				
	    				// сбросим (удалим) старую картинку imagecache, если она есть
	    				imagecache_image_flush($filepath);
	    				
	    				
	    				
		
					} // end of for($f_count = $db_count + 1; $f_count <= $value; $f_count++) // добавляем такое количество картинок, которое необхоимо добавить к заданному в базе до заданного в таблице
						
				} // end of if($value > $db_count)  // если необходимо увеличить количество картинок, увеличиваем
				

				
				
				// если необходимо увеличить количество картинок, увеличиваем
				if($value < $db_count) 
				{
					
					
					for($f_count = $db_count; $f_count > $value; $f_count--) // удаляем такое количество картинок, которое необхоимо удалить из заданного в базе до заданного в таблице
					{

	    				$delta = $f_count - 1; // т.к. дельта начинается с нуля, а нумерация картинок с еденицы
	    	
	    				switch($zp_element['type'])
	    				{
	    					case 'страна':
							case 'населённый пункт':	
	 						case 'район':
	 						case 'магазин':
	 						case 'подотдел':
	 							
	 							$fid = db_query("SELECT field_place_img_fid FROM {content_field_place_img} WHERE vid = %d AND nid = %d AND delta = %d", $node->vid, $node->nid, $delta);
	 							
	 							db_query('DELETE FROM {content_field_place_img} WHERE vid = %d AND nid = %d AND delta = %d', $node->vid, $node->nid, $delta);
	 							db_query('DELETE FROM {files} WHERE fid = %d', $fid);
	 							
	    						break;
	    				
	    					case 'товар':
	    						
	    						// для того, чтобы заносить инфу о картинках в разные таблицы и поля для разных типов продуктов
	    						// сформируем название таблицы и поля в базе из названия типа товара
								//$type_of_product = explode('product_', $node->type); 
								//$type_of_product = $type_of_product[1];
								//$type_of_product = 'content_field_p_' . $type_of_product .'_img';
								
								//$fid = db_query("SELECT field_p_" . $type_of_product . "_img_fid FROM {content_field_p_" . $type_of_product . "_img} WHERE vid = %d AND delta = %d AND nid = %d", $node->vid, $delta, $node->nid);
								
								$fid = db_query("SELECT field_product_img_fid FROM {content_field_product_img} WHERE vid = %d AND delta = %d AND nid = %d", $node->vid, $delta, $node->nid);
								
								
								//db_query('DELETE FROM {content_field_p_' . $type_of_product . '_img} WHERE vid = %d AND delta = %d AND nid = %d', $node->vid, $delta, $node->nid);
								db_query('DELETE FROM {content_field_product_img} WHERE vid = %d AND delta = %d AND nid = %d', $node->vid, $delta, $node->nid);
								
								db_query('DELETE FROM {files} WHERE fid = %d', $fid);
								
					    		break;
	    				
	    					default:
    							$shop_item['Действие / результат'] = 'change error: неправильный тип элемента ' . $zp_element['type'] . ' при изменении количества картинок'; 
								return $shop_item;
    					
	    				} // end of switch($zp_element['type'])
		
					} // end of for($f_count = $db_count; $f_count > $value; $f_count--) // удаляем такое количество картинок, которое необхоимо удалить из заданного в базе до заданного в таблице
						
				} // end of if($value < $db_count)  // если необходимо уменьшать количество картинок, уменьшаем
								
				
				break; // end of case 'Кол-во картинок':
				
				
				
				
				
				
			case 'На основе чего формируется название картинок':
				
				// если в этом поле помещён артикул элемента, картинки которого должны использоваться
				// то изменять название карнинок не нужно - в другом условии этого switch будут удалены все картинки из этого элемента (кол-во задано в ноль)
				if(strpos($value, 'copy *z') !== FALSE)
				 break;
				
				
				echo '<br> 4 Поле к изменению = ' . $key . ', новое значение = ' . $value . '<br>';
				
				// если в таблице задан артикул элемента, с которого нужно копировать картинки
				// то изменение названия картинок не производится, так как они просто все удаляются из базы для этого элемента
				// а вместо этого в базу записывается артикул элемента, с которого нужно копировать картинки
				
				
				
				
				
				
				
				// если же в таблице задано что-то другое (а не артикул элемента, с которого нужно копировать картинки),
				// то удаляем из таблицы запись об артикуле элемента, с которого нужно копировать картинки
				// и далее производим изменение названий картинок
				
				
				
				
				// определим, на основе чего формируется новое название картинок
				switch($zp_element['type'])
				{
					case 'страна':
					case 'населённый пункт':	
	 				case 'район':
	 				case 'магазин':
	 				case 'подотдел':
	 					
	 					echo '<br> 5 Поле к изменению = ' . $key . ', новое значение = ' . $value . '<br>';
						// -------------------------------------------------------------------
		
						
				
	 					switch($value)
	 					{
	 						case 'название':
	 							$pic_name_base = $zp_element['новое_название']; //$shop_item['Название'];
	 							break;
	 						
	 							
	 						case 'зп-артикул':
	 							$pic_name_base = $zp_element['zp_artikul'];
	 							break;
	 							
	 						default:
	 							
	 							//if(strpos($value, 'copy *z') !== FALSE) // если строка содержит указание на то, что картинки должны использоваться из другого товара
									//break 3;  // значит пропускаем это поле и переходим к следующему
								 		 // или тут 2 или 4 должно стоять??????

								// иначе..

								$shop_item['Действие / результат'] = 'change error: не может формироваться название картинки на основе ' . $value . ' для типа ' . $zp_element['type'] . ' при изменении названия картинок'; 
								return $shop_item;
	 					}
	 					
	 					
	 					echo 'pic_name_base = ' . $pic_name_base;
	 					

	 					break;
	 					
	 					
	 					
	 					
	 					
					case 'товар':

						switch($value) // На основе чего формируется название картинок
	 					{
	 						case 'название':
								if(!$zp_element['новое_название'])
								{
									$shop_item['Действие / результат'] = 'change error: не задано название элемента, а на его основе должны формироваться названия картинок'; 
									return $shop_item;
								}
							
								$pic_name_base = $zp_element['новое_название']; //$shop_item['Название'];
								break;
			
							
							
							case 'зп-артикул':
								if(!$zp_element['zp_artikul'])
								{
									$shop_item['Действие / результат'] = 'change error: не задан внутренний артикул-зп элемента, а на его основе должны формироваться названия картинок'; 
									return $shop_item;
								}
							
								$pic_name_base = $zp_element['zp_artikul'];
								break;

							
							
							case 'ш-произв':

								if(!$shop_item['Штрих-код производителя'])
								{
									$shop_item['Действие / результат'] = 'change error: не задан штрих-код производителя, а на его основе должны формироваться названия картинок'; 
									return $shop_item;
								}
							
								$val = zp_correct_quotes($shop_item['Штрих-код производителя']);

								if($val[0] . $val[1] . $val[2] == '###')
		 						{
									$val = explode('###', $val);
									$val = $val[1];
			 					}
			 					else if(strpos($val, '###') !== FALSE)
			 					{
		 							$val = explode('###', $val);
									$val = $val[0];
		 						}
							
								// убираем лишнее промежуточное действие
		 						//$zp_element['штрих_код_произв']	= $val;				
								//$pic_name_base = $zp_element['штрих_код_произв'];
								
								$pic_name_base = $val;
								break;

							
							
							case 'арт-произв':
							
								if(!$shop_item['Арт. Произв'])
								{
									$shop_item['Действие / результат'] = 'change error: не задан артикул производителя, а на его основе должны формироваться названия картинок'; 
									return $shop_item;
								}
								
								$val = zp_correct_quotes($shop_item['Арт. Произв']);

								if($val[0] . $val[1] . $val[2] == '###')
			 					{
									$val = explode('###', $val);
									$val = $val[1];
		 						}
		 						else if(strpos($val, '###') !== FALSE)
		 						{
		 							$val = explode('###', $val);
									$val = $val[0];
			 					}
							
								// убираем лишнее промежуточное действие
			 					//$zp_element['артикул_произв']	= $val;				
								//$pic_name_base = $shop_item['Арт. Произв'];
							
								$pic_name_base = $val;
								break;
		
							
							
							
							case 'ш-поставщ':
								
								if(!$shop_item['Штрих-код поставщика'])
								{
									$shop_item['Действие / результат'] = 'change error: не задан штрих-код поставщика, а на его основе должны формироваться названия картинок'; 
									return $shop_item;
								}
							
								$val = zp_correct_quotes($shop_item['Штрих-код поставщика']);
	
								if($val[0] . $val[1] . $val[2] == '###')
			 					{
									$val = explode('###', $val);
									$val = $val[1];
		 						}
		 						else if(strpos($value, '###') !== FALSE)
			 					{
			 						$val = explode('###', $val);
									$val = $val[0];
		 						}
							
								// убираем лишнее промежуточное действие
		 						//$zp_element['штрих_код_поставщ'] = $val;				
								//$pic_name_base = $shop_item['Штрих-код поставщика'];
							
								$pic_name_base = $val;
								break;
			
							
							
							case 'арт-поставщ':
								
								if(!$shop_item['Арт. Поставщ'])
								{
									$shop_item['Действие / результат'] = 'change error: не задан артикул поставщика, а на его основе должны формироваться названия картинок'; 
									return $shop_item;
								}
							
								$val = zp_correct_quotes($shop_item['Арт. Поставщ']);

								if($val[0] . $val[1] . $val[2] == '###')
			 					{
									$val = explode('###', $val);
									$val = $val[1];
		 						}
		 						else if(strpos($val, '###') !== FALSE)
		 						{
		 							$val = explode('###', $val);
									$val = $val[0];
			 					}
							
								// убираем лишнее промежуточное действие
			 					//$zp_element['артикул_поставщ'] = $val;				
								//$pic_name_base = $shop_item['Арт. Поставщ'];
							
								$pic_name_base = $val;
								break;
							
							
			
							case 'ш-магазина':
							
								if(!$shop_item['Штрих-код магазина'])
								{
									$shop_item['Действие / результат'] = 'change error: не задан штрих-код магазина, а на его основе должны формироваться названия картинок'; 
									return $shop_item;
								}
							
								$val = zp_correct_quotes($shop_item['Штрих-код магазина']);

								if($val[0] . $val[1] . $val[2] == '###')
		 						{
									$val = explode('###', $val);
									$val = $val[1];
			 					}
		 						else if(strpos($val, '###') !== FALSE)
		 						{
		 							$val = explode('###', $val);
									$val = $val[0];
		 						}
							
								// убираем лишнее промежуточное действие
			 					//$zp_element['штрих_код_магазина'] = $val;				
								//$pic_name_base = $shop_item['Штрих-код магазина'];
							
								$pic_name_base = $val;
								break;
			
							
							
							case 'арт-магазина':
							
								if(!$shop_item['Арт. Магазина'])
								{
									$shop_item['Действие / результат'] = 'change error: не задан артикул магазина, а на его основе должны формироваться названия картинок'; 
									return $shop_item;
								}
							
								$val = zp_correct_quotes($shop_item['Арт. Магазина']);

								if($val[0] . $val[1] . $val[2] == '###')
		 						{
									$val = explode('###', $val);
									$val = $val[1];
			 					}
			 					else if(strpos($val, '###') !== FALSE)
			 					{
		 							$val = explode('###', $val);
									$val = $val[0];
		 						}
							
								// убираем лишнее промежуточное действие
		 						//$zp_element['артикул_магазина'] = $val;				
								//$pic_name_base = $shop_item['Арт. Магазина'];
							
								$pic_name_base = $val;
								break;

							
										
	 							
	 						default:

	 							//if(strpos($value, 'copy *z') !== FALSE) // если строка содержит указание на то, что картинки должны использоваться из другого товара
									//break 3;  // значит пропускаем это поле и переходим к следующему
								 		      // или тут 4 должно стоять??????
								// иначе..
	 							
	 							// если в таблице не задано, как формируется картинка, прекращаем обработку этого элемента с грозным сообщением :)
								$shop_item['Действие / результат'] = 'change error: не может формироваться название картинки на основе ' . $value . ' для типа ' . $zp_element['type'] . ' при изменении названия картинок'; 
								return $shop_item;
	 						}	
							break;
	    				

						
						
	    			default:
						break; // других типов и не может быть, все неправильные типы отсеиваются вначале функции
						
				} // end of switch($zp_element['type']) // конец выора типа для определения названия картинок для разных типов
				
				
				
				// транслитерируем базу названия картинок для формирования названия картинок
	    		// на случай, если база содержит кириллицу
	    		$pic_name_base = translit_no_spaces($pic_name_base);
				
	    		
	    		
				// проверим, задано ли полученное значение базы для названия картинки
				if(!$pic_name_base OR $pic_name_base == '' OR $pic_name_base == '')
				{
					$shop_item['Действие / результат'] = 'change error: не задано значение поля, на основе которого должно быть сформировано название картинок при изменении названия картинок'; 
					return $shop_item;
				}
				
				
				
				echo '<br> pic_name_base = ' . $pic_name_base;
	 					
	 			
				
				
					
				// теперь получим данные о картинках, заданных в базе для разных типов элементов
				
				switch($zp_element['type']) // получим данные о заданных в базе картинках
				{
					
					case 'страна':
					case 'населённый пункт': // обычно город
					case 'район':
					case 'магазин':
					case 'подотдел':						

					    $files = db_query("SELECT delta, field_place_img_fid FROM {content_field_place_img} WHERE vid = %d AND nid = %d", $node->vid, $node->nid);

					    // выясним, сколько у элемента картинок и заполним массив данных по картинкам	    
						$db_count = 0;
						while($file = db_fetch_object($files))
						{
			    			$file_pics[$db_count]['fid'] = $file->field_place_img_fid;
			    			$file_pics[$db_count]['delta'] = $file->delta;
			    			$db_count++;
			    		}
					    
					    break;
					    
					    
					case 'товар':
						
						// сформируем название поля с описанием в базе из названия типа товара
						//$type_of_product = explode('product_', $node->type); 
						//$type_of_product = $type_of_product[1];

					    //$files = db_query("SELECT delta, field_p_" . $type_of_product . "_img_fid FROM {content_field_p_" . $type_of_product . "_img} WHERE vid = %d AND nid = %d", $node->vid, $node->nid);
					    
					    $files = db_query("SELECT delta, field_product_img_fid FROM {content_field_product_img} WHERE vid = %d AND nid = %d", $node->vid, $node->nid);
					    
					    // выясним, сколько у элемента картинок и заполним массив данных по картинкам	    
						$db_count = 0;
						while($file = db_fetch_object($files))
						{
			    			$file_pics[$db_count]['fid'] = $file->field_product_img_fid;
			    			$file_pics[$db_count]['delta'] = $file->delta;
			    			$db_count++;
			    		}
			    
					    break;
					    
					    
					case 'подгруппа': // у подгруппы нет картинок
					default:
						// если в таблице не задано, как формируется картинка, прекращаем обработку этого элемента с грозным сообщением :)
						$shop_item['Действие / результат'] = 'change error: неправильный тип элемента ' . $zp_element['type'] . ' при изменении количества картинок'; 
						return $shop_item;
						
				} // end of switch($zp_element['type']) // получим данные о заданных в базе картинках
				
				//print '<PRE>';
				//print_r($files);
				//print '</PRE>';

				//print '<PRE>';
				//print_r($file_pics);
				//print '</PRE>';
				
			    echo '<br> db_count = ' . $db_count;
			    
			    
			    // если для данного элемента не задана ни одна картинка или произошла ошибка при чтении данных о картинках
			    if(!$file_pics[0]['fid'] OR $file_pics[0]['fid'] == '' OR $file_pics[0]['fid'] == ' ') 
				  break; // выходим из изменения названия картинок

				  
				// теперь произведём изменение названия имеющихся в базе картинок
				for($f_count = 1; $f_count <= $db_count; $f_count++) 
				 {

	    			//$delta = $f_count - 1; // т.к. дельта начинается с нуля, а нумерация картинок с еденицы
	    			
	    			// найдём старое название файла, чтобы переименовать потом сам файл
	 				$old_filepath = db_result(db_query("SELECT filepath FROM {files} WHERE fid = %d", $file_pics[$f_count - 1]['fid']));

	    	
	    			$filename = $pic_name_base . '-p' . $f_count . '.jpg';
	    			$filepath = 'files/' . $zp_element['pics_path'] . '/' . $filename;
	    			
	    			echo '<br>filename =' . $filename;
	    			echo '<br>filepath =' . $filepath;
	    			echo "zp_element[pics_path]" . $zp_element['pics_path'];
	    			//return;
	    			
	    			switch($zp_element['type'])
	    			{
	    				case 'страна':
						case 'населённый пункт':	
	 					case 'район':
	 					case 'магазин':
	 					case 'подотдел':
	 					case 'товар':
	 							
	 						echo "<br>file_pics[f_count - 1]['fid'] = " . $file_pics[$f_count - 1]['fid'];
	 						//return;

	 						
	 					  	if
	 					  	(
								!db_query("UPDATE {files} SET filename = '%s', filepath = '%s' WHERE fid = %d", $filename, $filepath , $file_pics[$f_count - 1]['fid'])
							)
							{
				  				$shop_item['Действие / результат'] = 'change error: ошибка при изменении в базе названий фалов картинок'; 
								return $shop_item;
				  		  	}		
				  		  	
	    					break;

	    				
	    				default:
    						// если в таблице не задано, как формируется картинка, прекращаем обработку этого элемента с грозным сообщением :)
							$shop_item['Действие / результат'] = 'change error: неправильный тип элемента ' . $zp_element['type'] . ' при изменении названия картинок'; 
							return $shop_item;
    					
	    			} // end of switch($zp_element['type'])
	    			
	    			
	    			// переиименовываем файл на диске
	    			//rename("/tmp/tmp_file.txt", "/home/user/login/docs/my_file.txt");
	    			//$zp_server_directory = 'D:\\WebServers\\home\\zapokupkami.com\\www\\zp_import_data\\';
	    			// files/country_img/Rass-p1.jpg
	    			rename($old_filepath, $filepath);
	    			
	    			
	    			
	    			
	    			
	    			// сбросим (удалим) старую картинку imagecache, если она есть
	    			imagecache_image_flush($filepath);
	    			
	    			
		
				} // end of // for($f_count = 1; $f_count <= $db_count; $f_count++)  // теперь произведём изменение названия имеющихся в базе картинок
				
				// Clear the cache so an anonymous poster can see the node being added or updated.
  				//cache_clear_all();		
  				//zp_clear_cache_drupal();
  		
				echo '<br>end of changing filename';
				//return;
				
				break;	// end of case 'На основе чего формируется название картинок':	
				
				
				
				
				
				
				
				
				
				
			case 'Логотип':	// есть или нет картинки логотипа для магазина или отдела
				
				switch($zp_element['type'])
				{

					case 'магазин':
	 				case 'подотдел':
					
						// выясним, задан ли логотип в базе для этого элемента
						$db_fid = db_result(db_query("SELECT field_place_logo_fid FROM {content_field_place_logo} WHERE vid = %d AND nid = %d", $node->vid, $node->nid));
						
						// если в базе не задан логотип и в таблице не задан логотип или ничего вообще не указано
						// значит никаких изменений не производится - переходим к следующему полю
						
						if(($db_fid === FALSE OR $db_fid == 0 OR $db_fid == '' OR $db_fid == ' ') AND ($value == 'нет' OR $value == '' OR $value == ' '))
							continue; 
						
						
							
						// если в базе задан логотип и в таблице задан логотип
						// значит никаких изменений не производится - переходим к следующему полю
						
						// или как вариант, пересчитываем название логотипа, предполагая, что изменился zp-артикул, на основе которого формируется название логотипа
						
						if(($db_fid !== FALSE AND $db_fid != 0 AND $db_fid != '' AND $db_fid != ' ') AND $value == 'есть')
						{
							
							// найдём старое название файла, чтобы переименовать потом сам файл
			 				$old_filepath = db_result(db_query("SELECT filepath FROM {files} WHERE fid = %d", $db_fid));
	
							//continue; 
							$logo_name_base = translit_no_spaces($zp_element['zp_artikul']);
	    					$filename_logo = $logo_name_base . '-logo' . '.jpg';
	    					$filepath_logo = 'files/' . $zp_element['pics_path'] . '/' . $filename_logo;
	    					
	    					// вносим изменения по названию логотипа в таблицу files
							if(
	    						!db_query("UPDATE {files} SET filename = '%s', filepath = '%s' WHERE fid = %d", $filename_logo, $filepath_logo, $db_fid)
							  )
							  {
							  	break;
							  }
							else
							  {
								// переиименовываем файл на диске
	    						//rename("/tmp/tmp_file.txt", "/home/user/login/docs/my_file.txt");
	    						//$zp_server_directory = 'D:\\WebServers\\home\\zapokupkami.com\\www\\zp_import_data\\';
	    						// files/country_img/Rass-p1.jpg
	    						rename($old_filepath, $filepath);
							  }
							  
							  
							  
							  
							  
							  
							  
							// сбросим (удалим) старую картинку imagecache, если она есть
	    					imagecache_image_flush($filepath_logo);
	    					
	    					
							
							break; 
						}	
						
						// иначе изменяем данные в базе
						
						// если в базе не задан логотип, а в таблице задан
						// добавляем логотип в базе
						if(($db_fid === FALSE OR $db_fid == 0 OR $db_fid == '' OR $db_fid == ' ') AND $value == 'есть')
						{
							$logo_name_base = translit_no_spaces($zp_element['zp_artikul']);

	    					$fid_logo = db_next_id('{files}_fid');
	    					$filename_logo = $logo_name_base . '-logo' . '.jpg';
	    					$filepath_logo = 'files/' . $zp_element['pics_path'] . '/' . $filename_logo;
							$file_title_logo = '';
							$file_alt_logo = '';
	    	
	    					$filemime = 'image/jpeg';
	    					$filesize = '';
	    					
	    					// вносим данные о файле с логотипом в таблицу files
	    					db_query("INSERT INTO {files} (fid, nid, filename, filepath, filemime, filesize) VALUES (%d, %d, '%s', '%s', '%s', %d)", $fid_logo, $node->nid, $filename_logo, $filepath_logo, $filemime, $filesize);
	    					
	    					if($db_fid === FALSE) // если вообще нет в базе записи о логотипе для текущего элемента
	    					{
	    						// вносим в таблицу с данными об обычном логотипе новую запись
	    						if(
	    							!db_query("INSERT INTO {content_field_place_logo} (vid, nid,"
	    											   . " field_place_logo_fid, field_place_logo_title, field_place_logo_alt)"
	    											   . " VALUES (%d, %d, %d, '%s', '%s')", 
	    											   $node->vid, $node->nid, 
	    											   $fid_logo, $file_title_logo, $file_alt_logo)
	    						  )
	    						  {
	    						  	$shop_item['Действие / результат'] = 'change error: ошибка при добавлении к элементу логотипа'; 
									return $shop_item;
	    						  	
	    						  }
	    											   
	    					} // end of if($db_fid === FALSE) // если вообще нет в базе записи о логотипе для текущего элемента
	    					else // иначе запись в базе есть, но fid = 0 или не задан 
	    					{
	    						// тогда не вносим новую запись в таблицу, а корректируем имеющуюся
	    						if
	 					  		(
									!db_query("UPDATE {content_field_place_logo} SET field_place_logo_fid = %d WHERE vid = %d AND nid = %d", $fid_logo, $node->vid, $node->nid)
								)
								{
				  					$shop_item['Действие / результат'] = 'change error: ошибка при добавлении к элементу логотипа'; 
									return $shop_item;
				  		  		}
				  		  		
	    					} // end of else // иначе запись в базе есть, но fid = 0 или не задан 
	    					
	    					
	    					
	    					
	    					
	    					// сбросим (удалим) старую картинку imagecache, если она есть
	    					imagecache_image_flush($filepath_logo);
	    					
	    					
	    					break; //  изменения внесены, переходим к следующему полю
						

						} // end of if(($db_fid === FALSE OR $db_fid == 0 OR $db_fid == '' OR $db_fid == ' ') AND $value == 'есть') 
						  // если в базе не задан логотип, а в таблице задан // добавляем логотип в базе
						
						
						  
						  
						// если в базе задан логотип, а в таблице не задан
						// убираем логотип из базы
						if(($db_fid !== FALSE AND $db_fid != 0 AND $db_fid != '' AND $db_fid != ' ') AND ($value == 'нет' OR $value == '' OR $value == ' '))
						{
							if 
							(
								!db_query('DELETE FROM {files} WHERE fid = %d', $db_fid)
								   OR						
								!db_query('DELETE FROM {content_field_place_logo} WHERE vid = %d AND nid = %d AND field_place_logo_fid = %d', $node->vid, $node->nid, $db_fid)
							)
							{
								$shop_item['Действие / результат'] = 'change error: ошибка при удалении логотипа элемента'; 
									return $shop_item;
							}

	    					break; //  изменения внесены, переходим к следующему полю

						} // end of if(($db_fid !== FALSE AND $db_fid != 0 AND $db_fid != '' AND $db_fid != ' ') AND ($value == 'нет' OR $value == '' OR $value == ' ')) 
						  // если в базе задан логотип, а в таблице не задан
						  // убираем логотип из базы
						
						break; // end of // case 'магазин':
	 									 // case 'подотдел':
						

	    											   
	 				default:
	    				// логотип может иметь только магазин или подотдел, все остальные элементы - нет
						//$shop_item['Действие / результат'] = 'change error: неправильный тип элемента ' . $zp_element['type'] . ', который не может иметь или не иметь логотип'; 
						//return $shop_item;
						break;
	    											   
				} // end of switch($zp_element['type'])
			
				
				// Clear the cache so an anonymous poster can see the node being added or updated.
  				//cache_clear_all();		
  				//zp_clear_cache_drupal();
				
				break; // end of case 'Логотип':	// есть или нет картинки логотипа для магазина или отдела
					
				

				
				

			case 'Коэффициент доставки':
				
				// если в числе содержится не точка, а запятая, меняем запятую на точку
				if(strpos($value, ',') !== FALSE)
					$value = str_replace(',', '.', $value);

				
	    		if
	 			(
					!db_query("UPDATE {content_field_d_factor} SET field_d_factor_value = %f WHERE vid = %d AND nid = %d", $value, $node->vid, $node->nid)
				)
				{
					$shop_item['Действие / результат'] = 'change error: ошибка при изменении фактора доставки элемента'; 
					return $shop_item;
				}
				
				break;					
				
				
				
				
				
				
			case 'Коэффициент минимальной суммы покупки (корзины)':
				
				echo '>>>>>>>>>>>>>>>>>>>>Коэффициент минимальной суммы покупки (корзины) <br>';
				echo 'value = ' . $value . ', node->vid =  ' . $node->vid . ', $node->nid' . $node->nid;
				
				// если в числе содержится не точка, а запятая, меняем запятую на точку
				if(strpos($value, ',') !== FALSE)
					$value = str_replace(',', '.', $value);
				
	    		if
	 			(
					!db_query("UPDATE {content_field_cart_min_sum_f} SET field_cart_min_sum_f_value = %f WHERE vid = %d AND nid = %d", $value, $node->vid, $node->nid)
				)
				{
					$shop_item['Действие / результат'] = 'change error: ошибка при изменении Коэффициента минимальной суммы покупки (корзины)'; 
					return $shop_item;
				}
				
				break;	

			
	
				
			default:    // или любое другое поле, указанное в таблице, но (пока) не определённое в программе
				break;	
											
		} // end of switch($key) // перебираем значения полей, вернее, выбираем какое поле обрабатывается на очередной итерации
		
		
		
		
		
		
		// изменяем данные, которые касаются только товара
		switch($zp_element['type'])
		{
			case 'товар': 
			
				switch($key)
				{
					
					case 'Бренд':

						if(
							!db_result(db_query("SELECT vid FROM {content_field_zp_brand_nolink} WHERE nid = %d", $node->nid))
				  		  )
				  		  {
				  			if( // если значение не было задано изначально, попытаться его внести
								!db_query("INSERT INTO {content_field_zp_brand_nolink} (field_zp_brand_nolink_value, nid, vid) VALUES ('%s', %d, %d)", $value, $node->nid, $node->vid)
					  		  )
					  		  {
								$shop_item['Действие / результат'] = 'change error: ошибка при изменении в базе поля -' . $key . '- на значение ' . $value; 
								return $shop_item;
					  	  	  }
				  		  }
				  		else
				  		  { 
				    		if( 
								!db_query("UPDATE {content_field_zp_brand_nolink} SET field_zp_brand_nolink_value = '%s' WHERE nid = %d AND vid = %d", $value, $node->nid, $node->vid)
					  		  )
					  		  {
								$shop_item['Действие / результат'] = 'change error: ошибка при изменении поля -' . $key . '- в базе на значение ' . $value; 
								return $shop_item;
					  		  }
				  		  }
				
				
						break;	

				
						
						
					case 'Штрих-код производителя':
				
						if(
							!db_result(db_query("SELECT vid FROM {content_field_zp_bar_proizv} WHERE nid = %d", $node->nid))
				  		  )
				  		  {
				  			if( // если значение не было задано изначально, попытаться его внести
								!db_query("INSERT INTO {content_field_zp_bar_proizv} (field_zp_bar_proizv_value, nid, vid) VALUES ('%s', %d, %d)", $value, $node->nid, $node->vid)
					  		  )
					  		  {
								$shop_item['Действие / результат'] = 'change error: ошибка при изменении в базе поля -' . $key . '- на значение ' . $value; 
								return $shop_item;
					  	  	  }
				  		  }
				  		else
				  		  { 
				    		if( 
								!db_query("UPDATE {content_field_zp_bar_proizv} SET field_zp_bar_proizv_value = '%s' WHERE nid = %d AND vid = %d", $value, $node->nid, $node->vid)
					  		  )
					  		  {
								$shop_item['Действие / результат'] = 'change error: ошибка при изменении поля -' . $key . '- в базе на значение ' . $value; 
								return $shop_item;
					  		  }
				  		  }

				
						break;
					
				
						
					case 'Арт. Произв':
						
						if(
							!db_result(db_query("SELECT vid FROM {content_field_zp_art_proizv} WHERE nid = %d", $node->nid))
				  		  )
				  		  {
				  			if( // если значение не было задано изначально, попытаться его внести
								!db_query("INSERT INTO {content_field_zp_art_proizv} (field_zp_art_proizv_value, nid, vid) VALUES ('%s', %d, %d)", $value, $node->nid, $node->vid)
					  		  )
					  		  {
								$shop_item['Действие / результат'] = 'change error: ошибка при изменении в базе поля -' . $key . '- на значение ' . $value; 
								return $shop_item;
					  	  	  }
				  		  }
				  		else
				  		  { 
				    		if( 
								!db_query("UPDATE {content_field_zp_art_proizv} SET field_zp_art_proizv_value = '%s' WHERE nid = %d AND vid = %d", $value, $node->nid, $node->vid)
					  		  )
					  		  {
								$shop_item['Действие / результат'] = 'change error: ошибка при изменении поля -' . $key . '- в базе на значение ' . $value; 
								return $shop_item;
					  		  }
				  		  }
						
				
						break;
			
						
				
					case 'Штрих-код поставщика':
						
						if(
							!db_result(db_query("SELECT vid FROM {content_field_zp_bar_postav} WHERE nid = %d", $node->nid))
				  		  )
				  		  {
				  			if( // если значение не было задано изначально, попытаться его внести
								!db_query("INSERT INTO {content_field_zp_bar_postav} (field_zp_bar_postav_value, nid, vid) VALUES ('%s', %d, %d)", $value, $node->nid, $node->vid)
					  		  )
					  		  {
								$shop_item['Действие / результат'] = 'change error: ошибка при изменении в базе поля -' . $key . '- на значение ' . $value; 
								return $shop_item;
					  	  	  }
				  		  }
				  		else
				  		  { 
				    		if( 
								!db_query("UPDATE {content_field_zp_bar_postav} SET field_zp_bar_postav_value = '%s' WHERE nid = %d AND vid = %d", $value, $node->nid, $node->vid)
					  		  )
					  		  {
								$shop_item['Действие / результат'] = 'change error: ошибка при изменении поля -' . $key . '- в базе на значение ' . $value; 
								return $shop_item;
					  		  }
				  		  }
						
						
						break;
						
						
				
					case 'Арт. Поставщ':
						
						if(
							!db_result(db_query("SELECT vid FROM {content_field_zp_art_postav} WHERE nid = %d", $node->nid))
				  		  )
				  		  {
				  			if( // если значение не было задано изначально, попытаться его внести
								!db_query("INSERT INTO {content_field_zp_art_postav} (field_zp_art_postav_value, nid, vid) VALUES ('%s', %d, %d)", $value, $node->nid, $node->vid)
					  		  )
					  		  {
								$shop_item['Действие / результат'] = 'change error: ошибка при изменении в базе поля -' . $key . '- на значение ' . $value; 
								return $shop_item;
					  	  	  }
				  		  }
				  		else
				  		  { 
				    		if( 
								!db_query("UPDATE {content_field_zp_art_postav} SET field_zp_art_postav_value = '%s' WHERE nid = %d AND vid = %d", $value, $node->nid, $node->vid)
					  		  )
					  		  {
								$shop_item['Действие / результат'] = 'change error: ошибка при изменении поля -' . $key . '- в базе на значение ' . $value; 
								return $shop_item;
					  		  }
				  		  }

				
						break;
						
						
				
					case 'Штрих-код магазина':

						if(
							!db_result(db_query("SELECT vid FROM {content_field_zp_bar_shop} WHERE nid = %d", $node->nid))
				  		  )
				  		  {
				  			if( // если значение не было задано изначально, попытаться его внести
								!db_query("INSERT INTO {content_field_zp_bar_shop} (field_zp_bar_shop_value, nid, vid) VALUES ('%s', %d, %d)", $value, $node->nid, $node->vid)
					  		  )
					  		  {
								$shop_item['Действие / результат'] = 'change error: ошибка при изменении в базе поля -' . $key . '- на значение ' . $value; 
								return $shop_item;
					  	  	  }
				  		  }
				  		else
				  		  { 
				    		if( 
								!db_query("UPDATE {content_field_zp_bar_shop} SET field_zp_bar_shop_value = '%s' WHERE nid = %d AND vid = %d", $value, $node->nid, $node->vid)
					  		  )
					  		  {
								$shop_item['Действие / результат'] = 'change error: ошибка при изменении поля -' . $key . '- в базе на значение ' . $value; 
								return $shop_item;
					  		  }
				  		  }

				
						break;

						
				
					case 'Арт. Магазина':
						
						if(
							!db_result(db_query("SELECT vid FROM {content_field_zp_art_shop} WHERE nid = %d", $node->nid))
				  		  )
				  		  {
				  			if( // если значение не было задано изначально, попытаться его внести
								!db_query("INSERT INTO {content_field_zp_art_shop} (field_zp_art_shop_value, nid, vid) VALUES ('%s', %d, %d)", $value, $node->nid, $node->vid)
					  		  )
					  		  {
								$shop_item['Действие / результат'] = 'change error: ошибка при изменении в базе поля -' . $key . '- на значение ' . $value; 
								return $shop_item;
					  	  	  }
				  		  }
				  		else
				  		  { 
				    		if( 
								!db_query("UPDATE {content_field_zp_art_shop} SET field_zp_art_shop_value = '%s' WHERE nid = %d AND vid = %d", $value, $node->nid, $node->vid)
					  		  )
					  		  {
								$shop_item['Действие / результат'] = 'change error: ошибка при изменении поля -' . $key . '- в базе на значение ' . $value; 
								return $shop_item;
					  		  }
				  		  }

				  		  
						break;
				
						
						
					case 'Продажная единица измерения':
				
						if
	 					(
							!db_query("UPDATE {content_field_sell_measure} SET field_sell_measure_value = '%s' WHERE vid = %d AND nid = %d", $value, $node->vid, $node->nid)
						)
						{
							$shop_item['Действие / результат'] = 'change error: ошибка при изменении продажной единицы измерения'; 
							return $shop_item;
						}
				
						break;	
				
				
					case 'Цена':
						
						// если в числе содержится не точка, а запятая, меняем запятую на точку
						if(strpos($value, ',') !== FALSE)
							$value = str_replace(',', '.', $value);
				
						if
	 					(
							!db_query("UPDATE {uc_products} SET sell_price = %f WHERE vid = %d AND nid = %d", $value, $node->vid, $node->nid)
						)
						{
							$shop_item['Действие / результат'] = 'change error: ошибка при изменении цены товара'; 
							return $shop_item;
						}
				
						break;
				
				
					case 'Вес/объём, значение':
						
						// если в числе содержится не точка, а запятая, меняем запятую на точку
						if(strpos($value, ',') !== FALSE)
							$value = str_replace(',', '.', $value);
				
						if
	 					(
							!db_query("UPDATE {uc_products} SET weight = %f WHERE vid = %d AND nid = %d", $value, $node->vid, $node->nid)
						)
						{
							$shop_item['Действие / результат'] = 'change error: ошибка при изменении веса/объёма товара'; 
							return $shop_item;
						}
				
						break;		
									
				
					case 'Вес/объём, мера':
				
						if
	 					(
							!db_query("UPDATE {uc_products} SET weight_units = '%s' WHERE vid = %d AND nid = %d", $value, $node->vid, $node->nid)
						)
						{
							$shop_item['Действие / результат'] = 'change error: ошибка при изменении меры веса/объёма товара'; 
							return $shop_item;
						}
				
						break;
					

						
					case 'Кол-во': 
					
						echo '<br>----Изменение количества товара, новое значение = ' . $value . ', node->nid = ' . $node->nid . '<br>';
					
						if // при изменении внутреннего артикула, необходимо изменить артикул и в таблице с количеством
	 					(
							!db_query("UPDATE {uc_product_stock} SET sku = '%s', stock = %d WHERE nid = %d", $zp_element['zp_artikul'], $value, $node->nid)
						)
						{
							$shop_item['Действие / результат'] = 'change error: ошибка при изменении количества товара товара на значение ' . $value; 
							return $shop_item;
						}
				
						break;
						
						

					case 'Уменьшать кол-во при продаже': 
					
						if
	 					(
							!db_query("UPDATE {uc_product_stock} SET active = %d WHERE nid = %d AND sku = '%s'", $value, $node->nid, $zp_element['zp_artikul'])
						)
						{
							$shop_item['Действие / результат'] = 'change error: ошибка при изменении поля ' . $key . ' на значение ' . $value; 
							return $shop_item;
						}
				
						break;
						
						
						
					case 'Кол-во, ниже которого не продавать': 
					
						if
	 					(
							!db_query("UPDATE {uc_product_stock} SET threshold = %d WHERE nid = %d AND sku = '%s'", $value, $node->nid, $zp_element['zp_artikul'])
						)
						{
							$shop_item['Действие / результат'] = 'change error: ошибка при изменении поля ' . $key . ' на значение ' . $value; 
							return $shop_item;
						}
				
						break;
						
						
					
						
						
					case 'Другие атрибуты товара':
						
						// если для товара были заданы атрибуты, предварительно удаляем их
						// все, кроме атрибута -Ваши пожелания к товару (укажите)- и его опции -Нет-
						
						// Определим aid атрибута -Ваши пожелания к товару (укажите)- 
						// и oid опции -Нет- атрибута -Ваши пожелания к товару (укажите)-
						
						// выясним aid атрибута "Ваши пожелания к товару (укажите)"
						if( 
							!($whish_aid = db_result(db_query("SELECT aid from {uc_attributes} WHERE name = '%s'", 'Ваши пожелания к товару (укажите)')))
	  	  	  	  		  )
	  	  	  	  		  {
					
								// если такого атрибута в базе нет, вносим его в базу
  	 							if( 
									!db_query("INSERT INTO {uc_attributes} (name, ordering, required, display, description) VALUES ('%s', %d, %d, %d, '%s')", 'Ваши пожелания к товару (укажите)', 10, 0, 0, 'Например, "Дата изготовления не позднее вчерашнего дня".') // 10 - ставим этот атрибут последним, если будут другие атрибуты
		  		 	  		  	  )
		  		  	  		  	  {
									$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. Ошибка при добавлении в базу нового атрибута -Ваши пожелания к товару (укажите)-'; 
									return $shop_item;
		  		  	   		  	  }
	  	  		
	  	  	  					// выясняем aid только что внесенного атрибута
	  	  	  					if( 
									!($whish_aid = db_result(db_query("SELECT aid from {uc_attributes} WHERE name = '%s' AND display = %d", 'Ваши пожелания к товару (укажите)', 0))) // 0 - текстовое поле
		  		  	  		  	  )
		  		  	  		  	  {
									$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. Ошибка при считывании aid только что добавленного в базу нового атрибута -Ваши пожелания к товару (укажите)-'; 
									return $shop_item;
		  		  	  		  	  }
	   	  	      		   } // end of if( !($aid = db_result(db_query("SELECT aid from {uc_attributes} WHERE name = '%s'", 'Ваши пожелания к товару (укажите)')))
	   	  	      
	   	  	      
				
						// выясним номер oid для опции "Нет" атрибута "Ваши пожелания к товару (укажите)"
						if( 
							!($whish_oid = db_result(db_query("SELECT oid from {uc_attribute_options} WHERE aid = %d AND name = '%s'", $whish_aid, 'Нет')))
	  	  	  	  		  )
	  	  	  	  		  {
	  	  	  	  				/*
	  	  	  	  				// если такая опция не определёна в системе, пропускаем добавление атрибута в элемент
								//$shop_item['Предупреждения'] = 'new warning: в базе не определён атрибут -Ваши пожелания к товару (укажите)-'; 
	  	  	  	  				$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. В базе не определёна опция -Нет- для атрибута -Ваши пожелания к товару (укажите)-'; 
								return $shop_item;
								*/

								// если такой опции нет в этом атрибуте в базе, вносим её в базу
  	 							if( 
									!db_query("INSERT INTO {uc_attribute_options} (aid, name, cost, price, weight, ordering) VALUES (%d, '%s', %f, %f, %d, %d)", $whish_aid, 'Нет', 0, 0, 0, 0)
		  		  	  			  )
		  		  	  			  {
									$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. Ошибка при добавлении в базу новой опции -Нет- атрибута -Ваши пожелания к товару (укажите)-'; 
									return $shop_item;
		  		  	  			  }
	  	  		
	  	  	  					// выясняем oid только что внесенной опции текущего атрибута
	  	  	  					if( 
									!($whish_oid = db_result(db_query("SELECT oid from {uc_attribute_options} WHERE aid = %d AND name = '%s'", $whish_aid, 'Нет')))
		  		  	  			  )
		  		  	  			  {
									$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. Ошибка при считывании oid только что добавленной в базу новой опции -Нет- атрибута -Ваши пожелания к товару (укажите)-'; 
									return $shop_item;
		  		  	  			  }
		  		  	  
		  		  	  
	   	  	      		  } // end of if( !($oid = db_result(db_query("SELECT oid from {uc_attribute_options} WHERE aid = %d AND name = '%s'", $aid, 'Нет')))
	   	  	      
						
						

	   	  	      		  
	   	  	      		  
	   	  	      		  
						
						// выясним, есть ли в базе какие-то атрибуты у этого элемента.. и удаляем все, если есть
						// все, кроме атрибута -Ваши пожелания к товару (укажите)-
						if( 
							db_query("SELECT aid from {uc_product_attributes} WHERE nid = %d AND aid <> %d", $node->nid, $whish_aid)
	  	  	  	  		  )
	  	  	  	  		  {
	  	  	  	  		  	if( 
			 					!(db_query("DELETE FROM {uc_product_attributes} WHERE nid = %d AND aid <> %d", $node->nid, $whish_aid))
		  	 			  	  )
		  	 			  	  {
		  						$shop_item['Действие / результат'] = 'change error: Возможно, не все данные по этому элементу изменены. Ошибка при удалении старых атрибутов элемента'; 
								return $shop_item;
		      			  	  }
	   	  	      		  }
				
	   	  	      		// выясним, есть ли в базе какие-то опции атрибутов у этого элемента.. и удаляем все, если есть
	   	  	      		// все, кроме опции -Нет- атрибута -Ваши пожелания к товару (укажите)-
						if( 
							db_query("SELECT oid from {uc_product_options} WHERE nid = %d AND oid <> %d", $node->nid, $whish_oid)
	  	  	  	  		  )
	  	  	  	  		  {
	  	  	  	  		  	if( 
			 					!(db_query("DELETE FROM {uc_product_options} WHERE nid = %d AND oid <> %d", $node->nid, $whish_oid))
		  	 			  	  )
		  	 			  	  {
		  						$shop_item['Действие / результат'] = 'change error: Возможно, не все данные по этому элементу изменены. Ошибка при удалении старых опций атрибутов элемента'; 
								return $shop_item;
		      			  	  }
	   	  	      		  } 
	   	  	      		  
	   	  	      		  
	   	  	      		  
	   	  	      		// внесём новые атрибуты
	 					
	   	  	      		// ранее строка с атрибутами была разобрана в переменные:
	 
     					// $attributes[$count]['type'] - тип атрибута (text, select, check, radio)
	 					// $attributes[$count]['name'] - имя атрибута
	 					// $attributes[$count]['descr'] - описание атрибута
	 					// $attributes[$count]['options'] - опции со значением суммы прибавки к цене
	 
						// и затем присвоена в переменную  $zp_element['другие_атрибуты_товара'] = $attributes
	 
	 					// формат и пример строки: 'select***Цвет***Описание атрибута[Красный^^^0---Зелёный^^^3,40]text***Размер[24^^^1.20---43^^^5.21]'

						echo 'zp_element[другие_атрибуты_товара] = ' . $zp_element['другие_атрибуты_товара'] . '<br>';
	 					
	 					if($zp_element['другие_атрибуты_товара'] != 'нет')
	 					{
							echo 'zp_element[другие_атрибуты_товара] = ' . $zp_element['другие_атрибуты_товара'] . '<br>';
	 						
	 						foreach($zp_element['другие_атрибуты_товара'] as $attribute) // перебираем указанные в таблице атрибуты товара
							{
								// выясним тип очередного атрибута в таблице
								switch($attribute['type'])
								{
									case 'text': 
										$attribute['type'] = 0;
										break;
				
									case 'select': 
										$attribute['type'] = 1;
										break;
					
									case 'radio': 
										$attribute['type'] = 2;
										break;
				
								}
			
								// выясним, определён ли в базе такой атрибут и выясним его aid 
								if( 
									!($aid = db_result(db_query("SELECT aid from {uc_attributes} WHERE name = '%s' AND display = %d", $attribute['name'], $attribute['type'])))
	  	  	  					  )
	  	  	  					  {
	  	  	  	
	  	  	  						// если такого атрибута в базе нет, вносим его в базу
  	 								if( 
										!db_query("INSERT INTO {uc_attributes} (name, ordering, required, display, description) VALUES ('%s', %d, %d, %d, '%s')", $attribute['name'], 0, 0, $attribute['type'], $attribute['descr'])
		  		  					  )
		  		  					  {
										$shop_item['Действие / результат'] = 'change error: Не все данные изменены по этому элементу. Ошибка при добавлении в базу нового атрибута -' . $attribute['name'] . '-'; 
										return $shop_item;
		  		  					  }
	  	  		
	  	  	  						// выясняем aid только что внесенного атрибута
	  	  	  						if( 
										!($aid = db_result(db_query("SELECT aid from {uc_attributes} WHERE name = '%s' AND display = %d", $attribute['name'], $attribute['type'])))
		  		  					  )
		  		  					  {
										$shop_item['Действие / результат'] = 'change error: Не все данные изменены по этому элементу. Ошибка при считывании aid только что добавленного в базу нового атрибута -' . $attribute['name'] . '-'; 
										return $shop_item;
		  		  					  }

	   	  	  					   } // end of // выясним, определён ли в базе такой атрибут и выясним его aid 
	   	  	  
	   	  	
	   	  	  
	   	  						// перебирвем все опции
	   	  						// выясним, определены ли в базе опции для этого атрибута, указанные в таблице
	   	  						// и выясним их oid
	   	  						$option_count = 0;
								foreach($attribute['options'] as $option_name => $add_price)
								{
									$option_count++;
				
									// выясним, определёна ли в базе такая опция у такого атрибута и выясним его oid 
									if( 
										!($oid = db_result(db_query("SELECT oid from {uc_attribute_options} WHERE name = '%s' AND aid = %d", $option_name, $aid)))
	  	  	  	  					  )
	  	  	  	  					  {
	  	  	  	
	  	  	  							// если такой опции нет в этом атрибуте в базе, вносим её в базу
	  	  	  							// задаём нулевые цены, так как это общие данные по опциям, а для каждого товара они будут задаваться свои
  	 									if( 
											!db_query("INSERT INTO {uc_attribute_options} (aid, name, cost, price, weight, ordering) VALUES (%d, '%s', %f, %f, %d, %d)", $aid, $option_name, 0, 0, 0, 0)
		  		  	  					  )
		  		  	  					  {
											$shop_item['Действие / результат'] = 'change error: Не все данные изменены по этому элементу. Ошибка при добавлении в базу новой опции -' . $option_name . '- атрибута -' . $attribute['name'] . '-'; 
											return $shop_item;
		  		  	  					  }
	  	  		
	  	  	  							// выясняем oid только что внесенной опции текущего атрибута
	  	  	  							if( 
											!($oid = db_result(db_query("SELECT oid from {uc_attribute_options} WHERE aid = %d AND name = '%s'", $aid, $option_name)))
		  		  	  					  )
		  		  	  					  {
											$shop_item['Действие / результат'] = 'change error: Не все данные изменены по этому элементу. Ошибка при считывании oid только что добавленной в базу новой опции -' . $option_name . '- атрибута -' . $attribute['name'] . '-'; 
											return $shop_item;
		  		  	  					  }
		  		  	  

		  		   					   } // end of // выясним, определёна ли в базе такая опция у такого атрибута и выясним его oid 	  
		  		  	  
	   	  	
	   	  								// как только определили первую опцию текущего атрибута, вносим атрибут в базу по текущему товару
	   	  								// (единожды вносим этот атрибут)
	   	  								// вносим в базу данные об этом атрибуте для этого товара
  	 				
	   	  								if($option_count == 1)
	   	  			 					  if( 
											 	!db_query("INSERT INTO {uc_product_attributes} (nid, aid, ordering, default_option, required, display) VALUES (%d, %d, %d, %d, %d, %d)", $node->nid, $aid, 0, $oid, 0, $attribute['type'])
		  	 		   					    )
		  	 		   						{
						 						$shop_item['Действие / результат'] = 'change error: Не все данные изменены по этому элементу. Ошибка при добавлении атрибута -' . $attribute['name'] . '- к этому товару'; 
						 						return $shop_item;
		  	 		   						}
		  	 		   
		  	 							// вносим в базу данные о текущей опции для этого товара
  	 									if( 
											!db_query("INSERT INTO {uc_product_options} (nid, oid, cost, price, weight, ordering) VALUES (%d, %d, %f, %f, %d, %d)", $node->nid, $oid, 0, $add_price, 0, $option_count-1) // $option_count-1 - это порядок отображения опций, как в таблице, начиная с нуля (поэтому вычитаем единицу)
		  		 	  					  )
		  		 	  					  {
					 						$shop_item['Действие / результат'] = 'change error: Не все данные изменены по этому элементу. Ошибка при добавлении опции -' . $option_name . '- атрибута -' . $attribute['name'] . '- к этому товару'; 
											return $shop_item;
		  		  	  					  }

	
								} // end of foreach($attribute['options'] as $option => $add_price)
		
							} // end of foreach($zp_element['другие_атрибуты_товара'] as $attribute) // перебираем указанные в таблице атрибуты товара
							
	 					} // end of if($zp_element['другие_атрибуты_товара'] != 'нет')
						
						break;
						
						
						
						
						
					case 'Атрибут Ваши пожелания (Нет)':
						
						

						// выясним aid атрибута "Ваши пожелания к товару (укажите)"
						if( 
							!($aid = db_result(db_query("SELECT aid from {uc_attributes} WHERE name = '%s'", 'Ваши пожелания к товару (укажите)')))
	  	  	  	  		  )
	  	  	  	  		  {
	  	  	  	  	
	  	  	  	  				/*
	  	  	  	  				// если такой атрибут не определён в системе, пропускаем добавление атрибута в элемент
								//$shop_item['Предупреждения'] = 'new warning: в базе не определён атрибут -Ваши пожелания к товару (укажите)-'; 
	  	  	  	  				$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. В базе не определён атрибут -Ваши пожелания к товару (укажите)-'; 
								return $shop_item;
								*/
					

					
								// если такого атрибута в базе нет, вносим его в базу
  	 							if( 
									!db_query("INSERT INTO {uc_attributes} (name, ordering, required, display, description) VALUES ('%s', %d, %d, %d, '%s')", 'Ваши пожелания к товару (укажите)', 10, 0, 0, 'Например, "Дата изготовления не позднее вчерашнего дня".') // 10 - ставим этот атрибут последним, если будут другие атрибуты
		  		 	  		  	  )
		  		  	  		  	  {
									$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. Ошибка при добавлении в базу нового атрибута -Ваши пожелания к товару (укажите)-'; 
									return $shop_item;
		  		  	   		  	  }
	  	  		
	  	  	  					// выясняем aid только что внесенного атрибута
	  	  	  					if( 
									!($aid = db_result(db_query("SELECT aid from {uc_attributes} WHERE name = '%s' AND display = %d", 'Ваши пожелания к товару (укажите)', 0))) // 0 - текстовое поле
		  		  	  		  	  )
		  		  	  		  	  {
									$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. Ошибка при считывании aid только что добавленного в базу нового атрибута -Ваши пожелания к товару (укажите)-'; 
									return $shop_item;
		  		  	  		  	  }
	   	  	      		   } // end of if( !($aid = db_result(db_query("SELECT aid from {uc_attributes} WHERE name = '%s'", 'Ваши пожелания к товару (укажите)')))
	   	  	      
	   	  	      
				
						// выясним номер oid для опции "Нет" атрибута "Ваши пожелания к товару (укажите)"
						if( 
							!($oid = db_result(db_query("SELECT oid from {uc_attribute_options} WHERE aid = %d AND name = '%s'", $aid, 'Нет')))
	  	  	  	  		  )
	  	  	  	  		  {
	  	  	  	  				/*
	  	  	  	  				// если такая опция не определёна в системе, пропускаем добавление атрибута в элемент
								//$shop_item['Предупреждения'] = 'new warning: в базе не определён атрибут -Ваши пожелания к товару (укажите)-'; 
	  	  	  	  				$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. В базе не определёна опция -Нет- для атрибута -Ваши пожелания к товару (укажите)-'; 
								return $shop_item;
								*/

								// если такой опции нет в этом атрибуте в базе, вносим её в базу
  	 							if( 
									!db_query("INSERT INTO {uc_attribute_options} (aid, name, cost, price, weight, ordering) VALUES (%d, '%s', %f, %f, %d, %d)", $aid, 'Нет', 0, 0, 0, 0)
		  		  	  			  )
		  		  	  			  {
									$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. Ошибка при добавлении в базу новой опции -Нет- атрибута -Ваши пожелания к товару (укажите)-'; 
									return $shop_item;
		  		  	  			  }
	  	  		
	  	  	  					// выясняем oid только что внесенной опции текущего атрибута
	  	  	  					if( 
									!($oid = db_result(db_query("SELECT oid from {uc_attribute_options} WHERE aid = %d AND name = '%s'", $aid, 'Нет')))
		  		  	  			  )
		  		  	  			  {
									$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. Ошибка при считывании oid только что добавленной в базу новой опции -Нет- атрибута -Ваши пожелания к товару (укажите)-'; 
									return $shop_item;
		  		  	  			  }
		  		  	  
		  		  	  
	   	  	      		  } // end of if( !($oid = db_result(db_query("SELECT oid from {uc_attribute_options} WHERE aid = %d AND name = '%s'", $aid, 'Нет')))
	   	  	      
	   	  	      
	   	  	      			  
						// если нужно добавить атрибут
						if($value == 'есть' OR $value == 1 OR $value == ' ' OR $value == '')
						{
							 
	   	  	      			// определим, не задан ли уже этот атрибут для этого элемента
	   	  	      			// и если нет, внесём его
	   	  	      			
	   	  	      			if( 
								!db_result(db_query("SELECT nid from {uc_product_attributes} WHERE aid = %d AND nid = %d", $aid, $node->nid))
	  	  	  	  			  )
	  	  	  	  			  {
	   	  	      
	   	  	    				// вносим в базу данные об этом атрибуте для этого элемента
  	 							if( 
									!db_query("INSERT INTO {uc_product_attributes} (nid, aid, ordering, default_option, required, display) VALUES (%d, %d, %d, %d, %d, %d)", $node->nid, $aid, 10, $oid, 0, 0) // ordering ставим 10, чтобы Поле с пожеланиями стояло последним после любых других атрибутов
		  		  			  	  )
		  		  			  	  {
									$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. Ошибка при добавлении атрибутв -Ваши пожелания к товару (укажите)-'; 
									return $shop_item;
		  		  			  	  }
		  		  			  
	  	  	  	  			  }
		  					
		  		  			  
		  		  			  
		  		  			// определим, не задана ли уже эта опция для этого атрибута для этого элемента
	   	  	      			// и если нет, внесём его  
		  		  			if( 
								!(db_result(db_query("SELECT nid from {uc_product_options} WHERE oid = %d AND nid = %d", $oid, $node->nid)))
	  	  	  	  			  )
	  	  	  	  			  {  
	   	  	      			
		  		  				// вносим в базу данные об опции (Нет) этого атрибуте для этого элемента
  	 							if( 
									!db_query("INSERT INTO {uc_product_options} (nid, oid, cost, price, weight, ordering) VALUES (%d, %d, %f, %f, %d, %d)", $node->nid, $oid, 0, 0, 0, 0)
		  		  			  	  )
		  		  			  	  {
									$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. Ошибка при добавлении атрибутв -Ваши пожелания к товару (укажите)-'; 
									return $shop_item;
		  		  			  	  }
	  	  	  	  			  }
		

						} // end of if($value == 'есть' OR $value == '1' OR $value == ' ' OR $value == '')
					
						else if($value == 'нет' OR $value == 0) 
						{
							
							
							// если нужно убрать атрибут
							// определим, не задан ли уже этот атрибут для этого элемента
	   	  	      			// и если задан, удалим его

	   	  	      			// если у элемента есть этот атрибут, удаляем его
	   	  	      			if( 
								db_result(db_query("SELECT nid from {uc_product_attributes} WHERE aid = %d AND nid = %d", $aid, $node->nid))
	  	  	  	  			  )
	  	  	  	  			  {
	  	  	  	  			  		if( 
			 							!(db_query('DELETE FROM {uc_product_attributes} WHERE nid = %d AND aid = %d', $node->nid, $aid))
		  	 			  	  		  )
		  	 			  	  		  {
		  								$shop_item['Действие / результат'] = 'change error: Возможно, не все данные по этому элементу изменены. Ошибка при удалении старых атрибутов элемента -Ваши пожелания к товару (укажите)-'; 
										return $shop_item;
		      			  	  		  }
		  		  			  
	  	  	  	  			  }
		  					
		  		  			  
		  		  			// если у элемента есть эта опция этого атрибута, удаляем её 
		  		  			if( 
								db_result(db_query("SELECT nid from {uc_product_options} WHERE oid = %d AND nid = %d", $oid, $node->nid))
	  	  	  	  			  )
	  	  	  	  			  {  
	  	  	  	  			  	
	  	  	  	  			  		if( 
			 							!(db_query('DELETE FROM {uc_product_options} WHERE nid = %d AND oid = %d', $node->nid, $oid))
		  	 			  	  		  )
		  	 			  	  		  {
		  								$shop_item['Действие / результат'] = 'change error: Возможно, не все данные по этому элементу изменены. Ошибка при удалении старой опции -Нет- атрибута -Ваши пожелания к товару (укажите)- этого элемента'; 
										return $shop_item;
		      			  	  	  	  }

	  	  	  	  			  }

						} // end of else if($value == 'нет' OR $value == '0')  // если нужно убрать атрибут

						
						break;

	   	  	      		  
	   	  	      		  
				
				
					default:
						break;
				}

				break;
					
				
			default:
				break;
						
		} // end of switch($zp_element['type']) // изменяем данные, которые касаются только товара
		

		
		
		
				
						

    
		
		
		
		// -------------------------------------------------------------------		
		// после внесения в базу изменённого значения сохраняем в поле с названием полную историю изменения названия, лишь убрав из ней первые три символа ### (если они там были)
		
		// перед этим восстанвливаем первоначальный вид кавчек, если они были
		$value = zp_restore_quotes($value); 
		$new_value_with_history = zp_restore_quotes($new_value_with_history);
		
		if($new_value_with_history)
			$shop_item[$key] = $new_value_with_history; // восстанавливаем полное значение поля, если оно имело историю (убирая признак изменения элемента, если он стоял вначале строки.... остальные разделители версий и сами версии названия остаются)
		else 
			$shop_item[$key] = $value;
			
				
	echo '<br> 7!';
	
	} // end of foreach($shop_item_changed as $key => $value) // последовательно перебираем и изменяем в элементе все поля, которые требуют изменения, в зависимости от названия поля			
	
	
	echo '<br> 8!';
	
	
	
	
	
				// если для элемента был задан алиас pathauto, удаляем его
				// для того, чтобы заново его затем пересчитать (пересчитывается в функции, которая вызывающет эту функцию сразу для всех обработанных элементов)
				switch($zp_element['type'])
				{

					case 'страна':
					case 'населённый пункт': // обычно город
					case 'район':
					case 'магазин':
					case 'подотдел':
					case 'товар':
						
						//db_query("DELETE FROM {url_alias}  WHERE src = '%s'", 'node/'.$nid);
						//db_query("DELETE FROM {url_alias}  WHERE src = '%s'", 'node/'.$nid.'/feed');
				
						if( 
			 				db_result(db_query("SELECT pid from {url_alias} WHERE scr = '%s'", 'node/' . $node->nid))
		  			  	  )
		  			  	  {
							if( 
			 					!(db_query("DELETE FROM {url_alias} WHERE scr = '%s'", 'node/' . $node->nid))
			 					  OR
			 					!(db_query("DELETE FROM {url_alias} WHERE scr = '%s'", 'node/' . $node->nid . '/feed'))
		  	  			  	  )
		  	  			  	  {
		  						$shop_item['Действие / результат'] = 'Change error: Возможно, не все данные изменены. Ошибка при удалении алиасов pathauto'; 
								return $shop_item;
		      			  	  }

		  			  	  } 
						
						break;
						
						
	  		  
					default: 
						break;
				}
	
	
	
	
	
	
	
	
	
	// временно, чтобы задача постоянно оставалась одной и той же		
	$shop_item['Действие / результат'] = ''; 
	
	return $shop_item;

}  // конец функции изменения элемента














// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// функция добавления нового элемента в магазин (отдела, подгруппы, товара и т.д.)-------

function zp_item_new($shop_item)
{
	global $user;
	
	// сбрасываем флаг необходимости добавления элемента в базу	
	// в дальнейшем сюда могут добавляться какие-то комментарии
	$shop_item['Действие / результат'] = '';
	
	
	
				


					
					
			    // Проверим, задано ли название элемента
			    
			    $value = zp_correct_quotes($shop_item['Название']);
				if(!$value OR $value == '' OR $value == ' ')	    
				{
					$shop_item['Действие / результат'] = 'new error: не задано название элемента' ; // сбрасываем флаг необходимости добавления элемента в базу	
						return $shop_item;
				}
				
				
				// теперь можно создатиь новый объект типа нода, в который будем заносить некоторые необходимые данные по элементу
				$node = new stdClass();
				// и вспомогательный объект $zp_element для прочих данных по элементу
				$zp_element = array();
				
			    // если в значении этого поля (позже таким образом будут проверяться и остальные поля) первые три символа в поле равны '###', 
			    // значит поле может содержать несколько версий и историю изменений... 
			    // уберём эти символы и используем только первое за этими символами значение (остальные отбрасываем)
			    
			    // также эти три сомвола могут содержаться внутри строки - это несколько версий (история изменения) значения этого поля
			    // тогда берём только первую (от начала строки) версию и считаем её текущей
			    
			    // после внесения в базу, сохраняем в поле с названием полную историю изменения значения этого поля, лишь убрав из ней первые три символа ### (если они там были)
			    
		 		
			    $new_value_with_history = FALSE;
				if($value[0] . $value[1] . $value[2] == '###') // управляющие символы в начале строки
		 		{
					$value = explode('###', $value);
		   	
					foreach($value as $key => $val)
					{
						if($key == 0 OR $key == 1)
		      	 		  $new_value_with_history = $new_value_with_history . $val;
		    			else  
		      	 		  $new_value_with_history = $new_value_with_history . '###' . $val;  
					} 
			
					$value = $value[1];
		 		}
		 		else if(strpos($value, '###') !== FALSE) // управляющие символы в середине строки
		 		{
		 			$value = explode('###', $value);
		   	
					foreach($value as $key => $val)
					{
						if($key == 0)
		      	 		  $new_value_with_history = $new_value_with_history . $val;
		    			else  
		      	 		  $new_value_with_history = $new_value_with_history . '###' . $val;  
					} 
			
					$value = $value[0];
		 		}
				
		 		$node->title = $value; // присваиваем значение поля (или последнюю версию из этого поля) рабочей переменной
				$zp_element['новое_название'] = $node->title;
				
				
				// после внесения в базу, сохраняем в поле с названием полную историю изменения названия, лишь убрав из ней первые три символа ### (если они там были)
				if($new_value_with_history)
		 			$shop_item['Название'] = $new_value_with_history; // восстанавливаем полное значение поля, если оно имело историю (убирая признак изменения элемента, если он стоял вначале строки.... остальные разделители версий и сами версии названия остаются)
					
					

		 			
		 			
		 			
		 	    // Также проверим, задан ли тип или подгруппа элемента

			    $value = $shop_item['Подгруппа / тип элемента'];
				
			    // если создаваемый элемент - товар, но для него не задана подгруппа, не создаём элемент в базе
			    // и сообщаем об ошибке
			    if(strpos($shop_item['Тип записи'], 'товар***') !== FALSE AND (!$value OR $value == '' OR $value == ' '))
				{
					$shop_item['Действие / результат'] = 'new error: не задана родительская подгруппа для товара' ; 
						return $shop_item;
				}

			    // если в значении этого поля (позже таким образом будут проверяться и остальные поля) первые три символа в поле равны '###', 
			    // значит поле может содержать несколько версий и историю изменений... 
			    // уберём эти символы и используем только первое за этими символами значение (остальные отбрасываем)
			    
			    // также эти три сомвола могут содержаться внутри строки - это несколько версий (история изменения) значения этого поля
			    // тогда берём только первую (от начала строки) версию и считаем её текущей
			    
			    // после внесения в базу, сохраняем в поле с названием полную историю изменения значения этого поля, лишь убрав из ней первые три символа ### (если они там были)
		 
		 		
			    $new_value_with_history = FALSE;
				if($value[0] . $value[1] . $value[2] == '###') // управляющие символы в начале строки
		 		{
					$value = explode('###', $value);
		   	
					foreach($value as $key => $val)
					{
						if($key == 0 OR $key == 1)
		      	 		  $new_value_with_history = $new_value_with_history . $val;
		    			else  
		      	 		  $new_value_with_history = $new_value_with_history . '###' . $val;  
					} 
			
					$value = $value[1];
		 		}
		 		else if(strpos($value, '###') !== FALSE) // управляющие символы в середине строки
		 		{
		 			$value = explode('###', $value);
		   	
					foreach($value as $key => $val)
					{
						if($key == 0)
		      	 		  $new_value_with_history = $new_value_with_history . $val;
		    			else  
		      	 		  $new_value_with_history = $new_value_with_history . '###' . $val;  
					} 
			
					$value = $value[0];
		 		}
		 		
		 		// уберём в полученной строке дубликаты кавычек и кавычки по краям
		 		$value = zp_correct_quotes($value);

				$zp_element['подгруппа_или_тип_элемента'] = $value; // присваиваем значение поля (или последнюю версию из этого поля) рабочей переменной
				
				// после внесения в базу, сохраняем в поле с названием полную историю изменения типа или подгруппы, лишь убрав из ней первые три символа ### (если они там были)
				if($new_value_with_history)
		 			$shop_item['Подгруппа / тип элемента'] = $new_value_with_history; // восстанавливаем полное значение поля, если оно имело историю (убирая признак изменения элемента, если он стоял вначале строки.... остальные разделители версий и сами версии названия остаются)
					
					
					
		 			
		 			
		 			
		 			
		 			
		 			
					
				// проверим, задан ли артикул элемента
				// и затем определим первую часть данных 
			    
				
				//$value = $shop_item['Тип записи'];
				
				//echo 'shop_item[Тип записи] = ' . $shop_item['Тип записи'] . '<br>';
				
				// уберём в полученной строке дубликаты кавычек и кавычки по краям
				$zp_element['type'] = zp_correct_quotes($shop_item['Тип записи']);
				
				
				//echo  '000000000000000 zp_element[type] = ' . $zp_element['type'] . ', zp_element[type_of_type] = ' . $zp_element['type_of_type'] . '<br>';
				
				// если значение поля содержит тип (в формате "значение***тип"), выясняем этот тип
				$zp_element['type_of_type'] = strpos($zp_element['type'], '***');
  				if($zp_element['type_of_type'] !== false) 
  				{
  				  $zp_element['type_of_type'] = explode('***', $zp_element['type']);
				  $zp_element['type'] = $zp_element['type_of_type'][0];
				  $zp_element['type_of_type'] = $zp_element['type_of_type'][1];
				} 
				
				
				//echo  '000000000000000 zp_element[type] = ' . $zp_element['type'] . ', zp_element[type_of_type] = ' . $zp_element['type_of_type'] . '<br>';
				
				
				
//--------------------------------------------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------------------------------------------				
				
				
				
				
				
				
				// определяем артикулы и, соответственно, связи для разных типов элементов
				$artikul_changes_exists = 0;
				$new_value_with_history = array();
				
				// перебираем все поля из артикула и выясним новые и старые значения номеров артикула
				foreach ($shop_item as $key => $value)
				{
					// работаем только с полями артикула
					if($key != 'Страна' AND
					   $key != 'Город' AND
					   $key != 'Район' AND
					   $key != 'Магазин' AND
					   $key != 'Подотдел' AND
					   $key != 'Подгруппа / тип элемента' AND
					   $key != 'Товар / родительский подотдел'
					  )
					continue;
					
					
					// исправим лишние кавычки, если есть
					$value = zp_correct_quotes($value);

		
					if($value[0] . $value[1] . $value[2] == '###') // управляющие символы в начале строки
		 			{
						$value = explode('###', $value);
		   	
						foreach($value as $k => $val)
						{
							if($k == 0 OR $k == 1)
		      	 		  		$new_value_with_history[$key] = $new_value_with_history[$key] . $val;
		    				else  
		      	 		  		$new_value_with_history[$key] = $new_value_with_history[$key] . '###' . $val;  
						} 
			
						$value_old = $value[2];
						$value = $value[1];
						
						$artikul_changes_exists = 1;  // значит какой-то из номеров артикула изменился
		 			}
		 			else if(strpos($value, '###') !== FALSE) // управляющие символы в середине строки
		 			{
		 				$value = explode('###', $value);
		   	
						foreach($value as $k => $val)
						{
							if($k == 0)
		      	 		 	 	$new_value_with_history[$key] = $new_value_with_history[$key] . $val;
		    				else  
		      	 		 	 	$new_value_with_history[$key] = $new_value_with_history[$key] . '###' . $val;  
						} 
			
						//$value_old = $value[1];
						$value = $value[0];
						$value_old = $value;
						
						echo ' hist --- key = ' . $key . ', new value = ' . $value . ', old value = ' . $value_old . '<br>';
						
		 			}
		 			else 
		 			{
		 				$value_old = $value;
		 			}
		 		

		 			// уберём в полученной строке дубликаты кавычек и кавычки по краям
		 			// и сохраним в массив 
		 			$zp_new_artikuls[$key] = $value;
		 			$zp_old_artikuls[$key] = $value_old;
	 			
				} // end of foreach ($shop_item as $key => $value) // перебираем все поля из артикула  и выясним новые и старые значения номеров артикула
				
				
				
// ---------------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------------------------
				
				
				
				
				

				// в зависимости от типа записи зададим артикулы, тип ноды и прочие данные
				switch($zp_element['type'])
				{
					case 'страна':
				
						// если заданы не все составляющие артикула места (и, соответственно, местоположения места)
						// выходим из подпрограммы с указанием ошибки в поле "действие / результат"
						if(!$zp_new_artikuls['Страна'])
						 {
						 	$shop_item['Действие / результат'] = 'new error: не указан номер страны' ; 
							return $shop_item;
						 }

						// задаём внутренний zp артикул страны
						$zp_element['zp_artikul'] = 'z' . $zp_new_artikuls['Страна']; 
					 	
						// задаём zp номер страны
						$zp_element['zp_number'] = $zp_new_artikuls['Страна'];
						
						$node->type = 'c_country';						
						$zp_element['pics_path'] = 'country_img';
						break;
						
					case 'населённый пункт': // обычно город
					
						// если заданы не все составляющие артикула места (и, соответственно, местоположения места/города)
						// выходим из подпрограммы с указанием ошибки в поле "действие / результат"
						if(!$zp_new_artikuls['Страна'] OR !$zp_new_artikuls['Город'])
						 {
						 	$shop_item['Действие / результат'] = 'new error: не указаны какие-то из номеров местоположения для населённого пункта' ; 
							return $shop_item;
						 }
						 
						// задаём внутренний zp артикул населённого пункта (города)
						$zp_element['zp_artikul'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город']; 
						
						// определим артикул родителя
						$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна']; 
					 	
						// задаём номер населённого пункта (внутри его страны)
						$zp_element['zp_number'] = $zp_new_artikuls['Город'];
						
						$node->type = 'c_city';
						$zp_element['pics_path'] = 'city_img';
						break;
						
					case 'район':
	
						// если заданы не все составляющие артикула места (и, соответственно, местоположения места)
						// выходим из подпрограммы с указанием ошибки в поле "действие / результат"
						if(!$zp_new_artikuls['Страна'] OR !$zp_new_artikuls['Город'] OR !$zp_new_artikuls['Район'])
						 {
						 	$shop_item['Действие / результат'] = 'new error: не указаны какие-то из номеров местоположения для района' ; 
							return $shop_item;
						 }
						 
						// задаём внутренний zp артикул района
						$zp_element['zp_artikul'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район']; 
						
						// определим артикул родителя
						$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город']; 
						
						// задаём номер района (внутри населённого пункта, города)
						$zp_element['zp_number'] = $zp_new_artikuls['Район'];

						$node->type = 'c_rajon';
						$zp_element['pics_path'] = 'rajon_img';
						break;
						
					case 'магазин':
						
						// если заданы не все составляющие артикула места (и, соответственно, местоположения места)
						// выходим из подпрограммы с указанием ошибки в поле "действие / результат"
						if(!$zp_new_artikuls['Страна'] OR !$zp_new_artikuls['Город'] OR !$zp_new_artikuls['Район'] OR !$zp_new_artikuls['Магазин'])
						 {
						 	$shop_item['Действие / результат'] = 'new error: не указаны какие-то из номеров местоположения для магазина' ; // сбрасываем флаг необходимости добавления элемента в базу	
							return $shop_item;
						 }
						 
						// задаём внутренний zp артикул магазина
						$zp_element['zp_artikul'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин']; 
						
						// определим артикул родителя
						$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район']; 
						
						// задаём номер магазина (внутри внутри района)
						$zp_element['zp_number'] = $zp_new_artikuls['Магазин'];

						$node->type = 'c_shop';
						$zp_element['pics_path'] = 'shop_img';
						break;
						
					case 'подотдел':
						
						// если заданы не все составляющие артикула места (и, соответственно, местоположения места)
						// выходим из подпрограммы с указанием ошибки в поле "действие / результат"
						if(!$zp_new_artikuls['Страна'] OR !$zp_new_artikuls['Город'] OR !$zp_new_artikuls['Район'] OR !$zp_new_artikuls['Магазин'] OR !$zp_new_artikuls['Подотдел'] OR !$zp_new_artikuls['Товар / родительский подотдел'])
						 {
						 	$shop_item['Действие / результат'] = 'new error: не указаны какие-то из номеров местоположения для подотдела' ; // сбрасываем флаг необходимости добавления элемента в базу	
							return $shop_item;
						 }
						 
						// задаём внутренний zp артикул подотдела
						$zp_element['zp_artikul'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин'] . $zp_new_artikuls['Подотдел']; 
						
						// определим артикул родителя
						if($zp_new_artikuls['Товар / родительский подотдел'] == '000')
							$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин']; 
						else
							$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин'] . $zp_new_artikuls['Товар / родительский подотдел']; 
							
							
						// задаём номер подотдела (внутри магазина)
						$zp_element['zp_number'] = $zp_new_artikuls['Подотдел'];
						
						$zp_element['родительский подотдел'] = $zp_new_artikuls['Товар / родительский подотдел']; // проверить, где используется эта переменная и нужна ли она вообще
						
						$node->type = 'c_department';
						$zp_element['pics_path'] = 'dept_img';
						break;
						
					case 'подгруппа':

						// Хотя артикул группы и не сохраняется в ноде, он необходим для организации связей и указания его местоположения
						// Поэтому если заданы не все составляющие артикула (и, соответственно, местоположения группы)
						// выходим из подпрограммы с указанием ошибки в поле "действие / результат"
						if(!$zp_new_artikuls['Страна'] OR !$zp_new_artikuls['Город'] OR !$zp_new_artikuls['Район'] OR !$zp_new_artikuls['Магазин'] OR !$zp_new_artikuls['Подотдел'])
						 {
						 	$shop_item['Действие / результат'] = 'new error: не заданы какие-то из номеров местоположения и товара для формирования внутреннего артикула zp'; // сбрасываем флаг необходимости добавления элемента в базу	
							return $shop_item;
						 }
						
						// определим артикул родителя
						$zp_element['parent_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин'] . $zp_new_artikuls['Подотдел']; 
						
						//$zp_element['type'] = 'подгруппа'; // этот элемент - продукт
						break;
						
					case 'товар':

						// если заданы не все составляющие артикула (и, соответственно, местоположения товара)
						// выходим из подпрограммы с указанием ошибки в поле "действие / результат"
						if(!$zp_new_artikuls['Страна'] OR !$zp_new_artikuls['Город'] OR !$zp_new_artikuls['Район'] OR !$zp_new_artikuls['Магазин'] OR !$zp_new_artikuls['Подотдел'] OR !$zp_new_artikuls['Подгруппа / тип элемента'] OR !$zp_new_artikuls['Товар / родительский подотдел'])
						 {
						 	$shop_item['Действие / результат'] = 'new error: не заданы какие-то из номеров местоположения и товара для формирования внутреннего артикула zp'; // сбрасываем флаг необходимости добавления элемента в базу	
							return $shop_item;
						 }
						// задаём внутренний zp артикул товара, он же - главный идентификатор товара SKU (model в базе uc)
						$zp_element['zp_artikul'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин'] . $zp_new_artikuls['Подотдел'] . $zp_new_artikuls['Товар / родительский подотдел']; 
						$node->model = $zp_element['zp_artikul'];
						// определим артикул родителя
						$zp_element['parent_otdel_zp_art'] = 'z' . $zp_new_artikuls['Страна'] . $zp_new_artikuls['Город'] . $zp_new_artikuls['Район'] . $zp_new_artikuls['Магазин'] . $zp_new_artikuls['Подотдел'];
						// в зависимости от типа товара (который указан через *** от слова "товар") зададим типа ноды для товара
						switch($zp_element['type_of_type'])
						{
							case 'продукты':
								$node->type = 'product_food';
								$zp_element['pics_path'] = 'p_food_img';								
								break;	
							case 'вещи':
								$node->type = 'product_clothes';
								$zp_element['pics_path'] = 'p_clothes_img';
								break;
									
							default:
								// иначе тип товара не определён в системе
								$shop_item['Действие / результат'] = 'new error: тип продукта не определён в системе' . $zp_element['type_of_type'] . ' не определён в системе'; // сбрасываем флаг необходимости добавления элемента в базу	
								return $shop_item;
								//break;
								
						} // end of в зависимости от типа товара (который указан через *** от слова "товар") зададим типа ноды для товара
						break;
						
					default:
						// иначе тип элемента не определён в системе
						$shop_item['Действие / результат'] = 'new error: тип элемента ' . $value . ' не определён в системе'; // сбрасываем флаг необходимости добавления элемента в базу	
						return $shop_item;
						//break;
						
				} // end of switch($zp_element['type']) // в зависимости от типа записи зададим артикулы, тип ноды и прочие данные

				
				
				
				
				
				
				
	// Проверим, не присутствует ли уже в базе элемента с внутренним артикулом таким же, как у этого (создаваемого) элемента
	
	if($shop_item['Тип записи'] != 'подгруппа')
	{
	  //$new_zp_artikul = 'z' . $shop_item['Страна'] . $shop_item['Город'] . $shop_item['Район'] . $shop_item['Магазин'] . $shop_item['Подотдел'] . $shop_item['Товар / родительский подотдел'];
	  
	  if(strpos($shop_item['Тип записи'], 'товар') !== false)
	    $existing_nid_with_such_zp_zrtikul = db_result(db_query("SELECT nid from {uc_products} WHERE model = '%s'", $zp_element['zp_artikul']));
	  else   
	    $existing_nid_with_such_zp_zrtikul = db_result(db_query("SELECT nid from {content_field_zp_art_place} WHERE field_zp_art_place_value = '%s'", $zp_element['zp_artikul']));
	  
	  if($existing_nid_with_such_zp_zrtikul)
	  {
	    $exisiting_name = db_result(db_query("SELECT title  from {node} WHERE nid = %d", $existing_nid_with_such_zp_zrtikul));
	  	$shop_item['Действие / результат'] = 'new error: в базе уже присутствует элемента с артикулом ' . $zp_element['zp_artikul'] . ' и называется ' . $exisiting_name; 
	    
	  	echo 'new error: в базе уже присутствует элемента с артикулом ' . $zp_element['zp_artikul'] . ' и называется ' . $exisiting_name; 
	  	
	  	return $shop_item;
	  }
	}
	
				
				
				
				
				
 
					
					
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	// Проверим, всё ли в порядке с заданными связями - присутствуют ли родители, 
	// не существует ли уже у заданного родителя элементов с таким же названием, как у вводимого элемента и т.д.
	switch($zp_element['type'])
	 {
		case 'страна':
			// проверим, не введен ли уже терм страны с таким названием
			$check_countries = taxonomy_get_term_by_name($node->title);
        	$zp_element['term_is_dublicate'] = 0;
        	foreach ($check_countries as $check_country) 
        	  {
          		if ($check_country->vid == 1) 
          		 {
            		$parent_tid = db_result(db_query("SELECT parent from {term_hierarchy} WHERE tid = %d", $check_country->tid));
          		 	if($parent_tid == 0) // если найден терм с таким же именем, с таким же номером словаря, да ещё у него и тид родителя = 0 (корень)
          		 	 $zp_element['term_is_dublicate'] = 1; // значит найдено совпадение - в базе уже имеется страна с таким названием, которое мы хотим внести
          		 }
        	  }
        	  
        	if($zp_element['term_is_dublicate'])
        	{
        	 $shop_item['Действие / результат'] = 'new error: терм с названием страна ' . $node->title . ' уже присутствует в базе (и именно в категории страна)'; 
						 return $shop_item;
        	}
        	
			break;
	 		 
	 	case 'населённый пункт':	
	 	case 'район':
	 	case 'магазин':
	 	case 'подотдел':
	 	case 'подгруппа':
	 		$parent_nid = db_result(db_query("SELECT nid from {content_field_zp_art_place} WHERE field_zp_art_place_value = '%s'", $zp_element['parent_zp_art']));
 			
	 		echo 'parent_nid = ' . $parent_nid;
	 		
	 		if(!$parent_nid) // если в базе нет ноды с таким артикулом, который указан как родительский
    		{
    			$shop_item['Действие / результат'] = 'new error: в базе нет элемента (с артикулом ' . $zp_element['parent_zp_art'] . '), заданного как родитель для этого элемента'; 
				  return $shop_item;
    		}
	 		
	 		$parent_tids = taxonomy_node_get_terms_by_vocabulary($parent_nid, 1); // вообще предполагается, что для каждой ноды может быть задан только один терм из словаря с каталогом. Поэтому дальнейший перебор - просто техническое ухищрение, чтобы вытащить данные из объекта, возвращаемого этой функцией
   			foreach($parent_tids as $parent_tid)
    		{
      			$zp_element['parent_tid_name'] = $parent_tid->name;
		      	$zp_element['parent_tid'] = $parent_tid->tid;
    		}
    		
    		echo 'parent_tid =' . $zp_element['parent_tid'];
    		
    		if(!$zp_element['parent_tid']) // если в базе не задан терм для ноды с таким артикулом, который указан как родительский
    		{
    			$shop_item['Действие / результат'] = 'new error: в базе не задан терм для элемента (с артикулом ' . $zp_element['parent_zp_art'] . '), заданного как родитель для этого элемента'; 
				  return $shop_item;
    		}
    		
    		// проверим, нет ли уже у данного родителя терма с таким же именем, который мы хотим создать
    		$test_children_of_parent_tids = taxonomy_get_children($zp_element['parent_tid']);
    		
    		$zp_element['term_is_dublicate'] = 0;
   			foreach($test_children_of_parent_tids as $test_children_of_parent_tid)
    		{
      			if($test_children_of_parent_tid->name == $node->title)
      			{
		      	  $zp_element['term_is_dublicate'] = 1;
		      	  $zp_element['existing_term_tid'] = $test_children_of_parent_tid->tid;
		      	  break; // среди детей данном родителя найден терм с таким же именем, которое мы хотим создать как новый потомок данного родителя
      			}  
    		}
    		
    		if($zp_element['term_is_dublicate']) // если в базе уже есть терм с таким названием у указанного родителя
    		{
    			// вообще-то можно использовать уже существующий терм для вновь создаваемого элемента
    			// или создавать терм с добавлением частицы "_new" к названию терма
    			
  				// чтобы использовать эту возможность, необходимо не вызходить из функции тут, а продолжить её
  				// а похже в блоке внесения данных по связям раскомментировать часть кода, которая позволяет осуществить указанные возможности
  				
  				// пока же, по умолчанию, элемент не вносится, функция по этому элементу прерывается в этом месте с указанием ошибки
  				
    			
    			$shop_item['Действие / результат'] = 'new error: терм с названием ' . $node->title . ' для типа ' . $zp_element['type'] . ' уже присутствует в базе у указанного родителя'; 
				  return $shop_item;

    		} // end of if($flag_is_dublicat) // если в базе уже есть у терм с таким названием у указанного родителя

    		break;
    		
    		
    		
    	case 'товар':
	 		
    		// если в базе нет ноды с таким артикулом, который указан как родительский
	 		if(!($parent_otdel_nid = db_result(db_query("SELECT nid from {content_field_zp_art_place} WHERE field_zp_art_place_value = '%s'", $zp_element['parent_otdel_zp_art'])))) 
    		{
    			$shop_item['Действие / результат'] = 'new error: в базе нет подотдела (с артикулом ' . $zp_element['parent_otdel_zp_art'] . '), заданного как родитель для этого элемента'; 
				  return $shop_item;
    		}
	 		
	 		echo 'parent_otdel_zp_art = ' . $zp_element['parent_otdel_zp_art'] . '<br>';  
	 		echo 'parent_otdel_nid = ' . $parent_otdel_nid . '<br>';
	 		
	 		$parent_otdel_tids = taxonomy_node_get_terms_by_vocabulary($parent_otdel_nid, 1);
   			foreach($parent_otdel_tids as $parent_otdel_tid)
    		{
      			$zp_element['parent_otdel_tid_name'] = $parent_otdel_tid->name;
		      	$zp_element['parent_otdel_tid'] = $parent_otdel_tid->tid;
    		}
    		
    		echo 'parent_otdel_tid_name =' . $zp_element['parent_otdel_tid_name'] . '<br>';
    		echo 'parent_otdel_tid =' . $zp_element['parent_otdel_tid'] . '<br>';
    		
			// проверим, есть ли в базе указанная в таблице подгруппа (в указанном подотделе), к которой должен принаджежать данный товар
    		$parent_podgruppa_tids = taxonomy_get_children($zp_element['parent_otdel_tid']);
    		
    		echo 'zp_element["подгруппа_или_тип_элемента"] = ' . $zp_element['подгруппа_или_тип_элемента'] . '<br>';
    		
    		$zp_element['term_parent_exists'] = 0;
    		foreach($parent_podgruppa_tids as $parent_podgruppa_tid)
    		{
    			
    			echo '--parent_podgruppa_tid->name = ' . $parent_podgruppa_tid->name . '<br>';
    			
      			if($parent_podgruppa_tid->name == $zp_element['подгруппа_или_тип_элемента'])
      			{
		      	  $zp_element['parent_podgruppa_tid'] = $parent_podgruppa_tid->tid;
		      	  $zp_element['term_parent_exists'] = 1;
		      	  
		      	  echo '---parent_podgruppa_tid = ' . $zp_element['parent_podgruppa_tid'] . '<br>';
		      	  
		      	  break; // найдена подгруппа с указанным именем в заданном подотделе, это и будет родительским термом для товара
      			}  
    		}
    		
    		//echo '---flag_is_podruppa =' . $zp_element['term_parent_exists'] . '<br>';
    		
    		// если терм подгруппы не найден в базе в указанном отделе
    		if(!$zp_element['term_parent_exists'])
    		{
    			$shop_item['Действие / результат'] = 'new error: терм подгруппы с названием ' . $zp_element['подгруппа_или_тип_элемента'] . ' не определён в базе у указанного родителя'; 
				  return $shop_item;
    		}
    		
    		break; // end of case 'товар':
	 
	 } // end of switch($zp_element['type']) // следующий шаг создания и связывания категорий элемента
	
// конец проверки данных о связывании категорий ---------------------------------------------------------
	 

	
	
	
	
	




	
	

	
	

				
				
				
	
	
	
	
	
	
	
	
	
	
	// установим все поля по умолчанию, касающиеся стандартного элемента

    if($shop_item['Тип записи'] != 'подгруппа')
    {
  	
		// задём эти значения позже, после всех предварительных проверок
    	//$node->nid = db_next_id('{node}_nid');
    	//$node->vid = db_next_id('{node_revisions}_vid');
    
    	$node->uid = $user->uid;
    	
    	$node->created = time();
    	$node->changed = time();
    	
    	$node->status = 1;
    	$node->comment = 0;
    	$node->promote = 0;
    	$node->moderate = 0;
    	$node->sticky = 0;
    	$node->log = ''; // комментарий к созданной ноде, его тоже можно через таблицу внести
    	$node->body = ''; // по умолчанию, эти стандартные поля мы не используем, а вместо них используем специально заданные поля
    	$node->teaser = ''; // по умолчанию, эти стандартные поля мы не используем, а вместо них используем специально заданные поля
    	$node->format = 1; // надо выяснить, что это за параметр (указывается в таблице node_revisions)
    	
    	
	 	
    	
    	$zp_element['source_of_pics'] = 'зп-артикул'; 	// в базу в поле source_of_pics типа ноды записывается, как формируются картинки товара 
														// - либо  поле содержит значение в формате "copy *z1010101001001" (именно это должно быть записано в таблице, из которой производится загрузка данных) - при выводе страницы показываются картинки из другого товара
														// - либо указывается, на основе чего формируются названия файлов с картинками
														// по умолчанию, считаем, что название картинок формирую на основе внутреннего артикула зп
		$pic_amount = 0; // по умолчанию, количество картинок равно нулю. Так что если количество не задано, картинки задаваться не будут
		
    	$zp_element['logo'] = 'нет';
    	//$zp_element['address'] = '';

    	$zp_element['коэффициент_доставки'] = 1; // по умолчанию, коэффициент доставки равен 1 (не изменяется стоимость доставки)
    	$zp_element['коэффициент_минимальной_суммы_покупки_(корзины)'] = 1; // по умолчанию, коэффициент минимальной суммы корзины равен 1 (не изменяется минимальная сумма относительно стандартного значения)
    	
    	$zp_element['описание_элемента'] = ' ';
    	$zp_element['кол_во_картинок'] = 1;
    }
    
    // есои это товар
    if(strpos($shop_item['Тип записи'], 'товар') !== false)
    {
    	//$node->model = ''; 
    	$node->list_price = 0;
    	$node->cost = 0; 
    	$node->sell_price = 0; 
    	$node->weight = 0; 
    	$node->weight_units = 'кг';
    	$node->length = 0; 
    	$node->width = 0; 
    	$node->height = 0; 
    	$node->length_units = 'мм'; 
    	$node->pkg_qty = 1; // количество в наборе 
    	$node->default_qty = 1; // кол-во для добавления в корзину по учолчанию 
    	$node->unique_hash = ''; 
    	$node->ordering = 0;
    	$node->shippable = 1;
    	
    	

    	//$zp_element['штрих_код_произв'] = '';
    	//$zp_element['артикул_произв'] = '';
    	//$zp_element['штрих_код_поставщ'] = '';
    	//$zp_element['артикул_поставщ'] = '';
    	//$zp_element['штрих_код_магазина'] = '';
    	//$zp_element['артикул_магазина'] = '';
    	
    	//$zp_element['название_бренда'] = '';
    	
    	
    	
    	$zp_element['количество'] = 1;
    	$zp_element['уменьшать_количество_при_продаже'] = 0; // по умолчанию контроль количества выключен
    	$zp_element['количество_ниже_которого_не_продавать'] = 0; // по умолчанию порог минимального количества равен нулю
    	
    	$zp_element['опция_ваши_пожелания_(нет)'] = 'есть';


    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
	
    // перебираем все поля элемента и задаём некоторые исходные данные
	foreach ($shop_item as $field => $value)
	{
		//echo '1`````````````field = ' . $field . ', value = ' . $value . '<br>';
		
		// уберём в полученной строке дубликаты кавычек и кавычки по краям
		$value = zp_correct_quotes($value);

		// если первые три символа в поле '###', значит поле может содержать несколько версий и историю изменений... уберём эти символы и используем только первое за этими символами значение (остальные отбрасываем)
		$new_value_with_history = FALSE;
		if($value[0] . $value[1] . $value[2] == '###')
		 {
			$value = explode('###', $value);
		   	
			foreach($value as $key => $val)
			{
				if($key == 0 OR $key == 1)
		      	 $new_value_with_history[$field] = $new_value_with_history[$field] . $val;
		    	else  
		      	 $new_value_with_history[$field] = $new_value_with_history[$field] . '###' . $val;  
			} 
			
			$value = $value[1];
		 }
		 else if(strpos($value, '###') !== FALSE)
		 {
		 	$value = explode('###', $value);
		   	
			foreach($value as $key => $val)
			{
				if($key == 0)
		      	 $new_value_with_history[$field] = $new_value_with_history[$field] . $val;
		    	else  
		      	 $new_value_with_history[$field] = $new_value_with_history[$field] . '###' . $val;  
			} 
			
			$value = $value[0];
		 	
		 }
	
		
		 //echo '2`````````````field = ' . $field . ', value = ' . $value . '<br>';		
		 		
		 		
		// зададим необходимые значения для элемента в зависимости от значения его конкретных (ещё не внесённых ранее в этой функции) полей
		switch ($field)
		{

			case 'Описание':
				if($value AND $value != '' AND $value != ' ') // менять только в том случае, если в поле что-то задано
					$zp_element['описание_элемента'] = $value;
				break;
    	
			case 'Кол-во': 
				if($value AND $value != '' AND $value != ' ') // менять только в том случае, если в поле что-то задано
					$zp_element['количество'] = $value;
				break;

			case 'Уменьшать кол-во при продаже': 
				if($value AND $value != '' AND $value != ' ') // менять только в том случае, если в поле что-то задано
					$zp_element['уменьшать_количество_при_продаже'] = $value;
				break;
						
			case 'Кол-во, ниже которого не продавать': 
				if($value AND $value != '' AND $value != ' ') // менять только в том случае, если в поле что-то задано
					$zp_element['количество_ниже_которого_не_продавать'] = $value;
				break;

			case 'Цена':
				// если в числе содержится не точка, а запятая, меняем запятую на точку
				if(strpos($value, ',') !== FALSE)
					$value = str_replace(',', '.', $value);
					
				$node->sell_price = $value;
				break;
				
			case 'Вес/объём, значение':
				// если в числе содержится не точка, а запятая, меняем запятую на точку
				if(strpos($value, ',') !== FALSE)
					$value = str_replace(',', '.', $value);
					
				$node->weight = $value;
				break;					
				
			case 'Вес/объём, мера':
				$node->weight_units = $value;
				break;
			
			case 'Продажная единица измерения':
				$zp_element['продажная_единица_измерения'] = $value;
				break;	
				
				
				
				
				
			case 'Штрих-код производителя':
				if($value AND $value != '' AND $value != ' ') // менять только в том случае, если в поле что-то задано
					$zp_element['штрих_код_произв'] = $value;
				break;
					
			case 'Арт. Произв':
				if($value AND $value != '' AND $value != ' ') // менять только в том случае, если в поле что-то задано
					$zp_element['артикул_произв'] = $value;
				break;
			
			case 'Штрих-код поставщика':
				if($value AND $value != '' AND $value != ' ') // менять только в том случае, если в поле что-то задано
					$zp_element['штрих_код_поставщ'] = $value;
				break;
				
			case 'Арт. Поставщ':
				if($value AND $value != '' AND $value != ' ') // менять только в том случае, если в поле что-то задано
					$zp_element['артикул_поставщ'] = $value;
				break;
				
			case 'Штрих-код магазина':
				if($value AND $value != '' AND $value != ' ') // менять только в том случае, если в поле что-то задано
					$zp_element['штрих_код_магазина'] = $value;
				break;
				
			case 'Арт. Магазина':
				if($value AND $value != '' AND $value != ' ') // менять только в том случае, если в поле что-то задано
					$zp_element['артикул_магазина'] = $value;
				break;
			
			case 'Бренд':
				if($value AND $value != '' AND $value != ' ') // менять только в том случае, если в поле что-то задано
					$zp_element['название_бренда'] = $value;
				break;	
				
			case 'На основе чего формируется название картинок':
				if($value AND $value != '' AND $value != ' ') // менять только в том случае, если в поле что-то задано
					$zp_element['source_of_pics'] = $value;
				break;
				
				
				
				
			case 'Адрес':
				if($value != '' AND $value != ' ') // если в этом поле не пусто, то используем значение поля, иначе остаётся знаение по умолчанию "нет"
					$zp_element['address'] = $value;
				break;	
				
				
				
				
				
			case 'Кол-во картинок':
				if($value AND $value != '' AND $value != ' ') // менять только в том случае, если в поле что-то задано
					$zp_element['кол_во_картинок'] = $value;
				break;
				

			case 'Логотип':
				if($value != '' AND $value != ' ') // если в этом поле не пусто, то используем значение поля, иначе остаётся знаение по умолчанию "нет"
				  $zp_element['logo'] = $value;
				break;	

				
			case 'Коэффициент доставки':
				if($value !==FALSE AND $value != '' AND $value != ' ') 
				{
					// если в числе содержится не точка, а запятая, меняем запятую на точку
					if(strpos($value, ',') !== FALSE)
						$value = str_replace(',', '.', $value);

					$zp_element['коэффициент_доставки'] = $value;
				}	
				break;					

				
			case 'Коэффициент минимальной суммы покупки (корзины)':
				if($value !==FALSE AND $value != '' AND $value != ' ') 
				{
					// если в числе содержится не точка, а запятая, меняем запятую на точку
					if(strpos($value, ',') !== FALSE)
						$value = str_replace(',', '.', $value);
					
					$zp_element['коэффициент_минимальной_суммы_покупки_(корзины)'] = $value;
				}	
				break;
			
			
			case 'Атрибут Ваши пожелания (Нет)':
				if($value !== FALSE AND $value != '' AND $value != ' ' ) 
					$zp_element['атрибут_ваши_пожелания_(нет)'] = $value;
					
				break;
				
				
			case 'Другие атрибуты товара':
				if($value !==FALSE AND $value != '' AND $value != ' ' ) 
					$zp_element['другие_атрибуты_товара'] = $value;
					
				break;
						

			default:
				break;
			
		} // end of // зададим необходимые значения для элемента в зависимости от значения его конкретных полей

		// если поле содержало признако необходимости изменения ### в начале, то убираем этот признак в возвращаемом значении, так как изменение уже произведено
		if($new_value_with_history)
		 $shop_item[$field] = $new_value_with_history;
	    
	} // end of foreach ($shop_item as $field => $value) // перебираем все поля элемента
	


	//echo '<br>' . '-----название ' . $node->title . '<br>';
	
	//print '<PRE>';
	//print_r($node);
	//print_r($zp_element);
	//print '</PRE>';
    //return;
	
    
    
    
    
    
    
	// если задано использование картинок из другого элемента, проверим, существует ли этот другой элемент
	// и определим артикул элемента-источника
	
    if(strpos($zp_element['source_of_pics'], 'copy *z') !== FALSE)
  	 {   
  	 	
  	 	
  	 	// если задано копирование картинок из другого товара, записываем в это поле артикул этого другого товара 
  	 	
  	 	$artikul_of_source = explode("copy *", $zp_element['source_of_pics']);
  	 	$zp_element['artikul_of_pic_source'] = $artikul_of_source[1];
  	 	
  	 	
  	 	// проверим, а существует ли такой элемент с указанным артикулом
  	 	// заметим, что соответствие типов не проверяется, это должен делать сам менеджер
  	 	
  	 	// данные об артикулах содержатся в разных таблицах для разных типов данных
  	 	
  	 	if($zp_element['type'] == 'товар')
  	 	{
 			if( 
				!db_result(db_query("SELECT nid from {uc_products} WHERE model = '%s'", $zp_element['artikul_of_pic_source']))
	  	  	  )
	  	  	  {
				$shop_item['Действие / результат'] = 'new error: в базе отсутствует товар с артикулом ' . $zp_element['artikul_of_pic_source'] . ', из которого должны браться логотипы для текущего элемента'; 
				return $shop_item;
	   	  	  }
  	 	}
  	 	else 
  	 	{
  	 		if( 
				!db_result(db_query("SELECT nid from {content_field_zp_art_place} WHERE field_zp_art_place_value = '%s'", $zp_element['artikul_of_pic_source']))
	  	  	  )
	  	  	  {
				$shop_item['Действие / результат'] = 'new error: в базе отсутствует элемент с артикулом ' . $zp_element['artikul_of_pic_source'] . ', из которого должны браться логотипы для текущего элемента'; 
				return $shop_item;
	   	  	  }
  	 	}

    
  	 }
    
    
  	 
  	 
  	 
  	 
  	 
  	 
  	 
  	// если задано использование логотипов из другого элемента, проверим, существует ли этот другой элемент
	// и определим артикул элемента-источника
	     
    if($zp_element['type'] == 'магазин' OR $zp_element['type'] == 'подотдел')
    {
	  if(strpos($zp_element['logo'], 'copy *z') !== FALSE)
  	  {    
  	 	// если задано копирование картинок из другого товара, записываем в это поле артикул этого другого товара 
  	 	
  	 	$artikul_of_logo_source = explode("copy *", $zp_element['logo']);
  	 	$zp_element['artikul_of_logo_source'] = $artikul_of_logo_source[1];
  	 	
  	 	
  	 	// проверим, а существует ли такой товар с указанным артикулом
  	 	// заметим, что не выполняется проверка на то, является этот элемент магазином или подотделом (которые имеют логотипы)
  	 	// это должен контролировать сам менеджер
  	 	
 		if( 
			!db_result(db_query("SELECT nid from {content_field_zp_art_place} WHERE field_zp_art_place_value = '%s'", $zp_element['artikul_of_logo_source']))
	  	  )
	  	  {
			$shop_item['Действие / результат'] = 'new error: в базе отсутствует элемент с артикулом ' . $zp_element['artikul_of_logo_source'] . ', из которого должны браться логотипы для текущего элемента'; 
			return $shop_item;
	   	  }
 	   }
     }
  	 
  	 
     
     
     
     
     
     
     
     
     // если заданы "другие" атрибуты товара, проверим, правильно ли задана строка с атрибутами
     
     if($zp_element['type'] == 'товар' AND $zp_element['другие_атрибуты_товара'])
     {
     	 
     	//$string = 'text***Цвет***Описание атрибута[Красный^^^0---Зелёный^^^3,40]select***Размер[24^^^1.20---43^^^5.21]';
		
     	
		//if($zp_element['другие_атрибуты_товара'] != 'Нет' AND $zp_element['другие_атрибуты_товара'] != 'нет' AND $zp_element['другие_атрибуты_товара'] != '0' AND $zp_element['другие_атрибуты_товара'] != 0 AND $zp_element['другие_атрибуты_товара'] != ' ')
		if(!$zp_element['другие_атрибуты_товара'] OR $zp_element['другие_атрибуты_товара'] == 'Нет' OR $zp_element['другие_атрибуты_товара'] == 'нет' OR $zp_element['другие_атрибуты_товара'] == '0' OR $zp_element['другие_атрибуты_товара'] == ' ')
		{
     		$zp_element['другие_атрибуты_товара'] = 'нет';
		}
		else 
		{
			if(strpos($zp_element['другие_атрибуты_товара'], ']') === FALSE)
 				$error_format = 1;
 
			$str = explode(']', $zp_element['другие_атрибуты_товара']);
		

			$count = 0;
			foreach($str as $atr)
			{
				if(!$atr)
	 				continue;
	 
				$xxx = array();
	
				if(strpos($atr, '[') === FALSE)
					$error_format = 1;
 
				$atr = explode('[', $atr);
				//$atr_name_type = $atr[0];
	
				if(strpos($atr[0], '***') === FALSE)
					$error_format = 1;
	
				$atr_name_type = explode('***', $atr[0]);
			
				$atr_type = $atr_name_type[0];
			
				if($atr_type != 'text' AND $atr_type != 'select' AND $atr_type != 'radio')
				{
					$shop_item['Действие / результат'] = 'new error: Неверный формат строки с атрибутами ' . $zp_element['другие_атрибуты_товара'] . '. Тип атрибута может быть только text, select, radio, а задан -' . $atr_type . '-'; 
					return $shop_item;
				}     
			
				$atr_name = $atr_name_type[1];
				$atr_descr = $atr_name_type[2];
	
			
				if(strpos($atr[1], '---') === FALSE)
					$error_format = 1;
		
				$atr = explode('---', $atr[1]);
			
				$count_options = 0;
				foreach($atr as $options)
				{
					$count_options++;
					
					if(strpos($options, '^^^') === FALSE)
						$error_format = 1;
		
					$option = explode('^^^', $options);
				
				
					// $option[0] - название опции
					// $option[1] - добавка к стоимости, грн
				
					// если в числе содержится не точка, а запятая, меняем запятую на точку
					if(strpos($option[1], ',') !== FALSE)
						$option[1] = str_replace(',', '.', $option[1]);
				
					// Стоимость первой опции в атрибуте должна быть нулевой, тогда цена будет правильно отображаться для пользователя
					// иначе отображаться будет по умолчанию нулевая цена при выбранной опции с ненулевой добавочной ценой
					if($count_options == 1 AND ($option[1] != 0 AND $option[1] != '0.0' AND $option[1] != '0.00' AND $option[1] != '00.00' AND $option[1] != '00.0' AND $option[1] != '' AND $option[1] != ' '))
					{
						$shop_item['Действие / результат'] = 'new error: Неверный формат строки с атрибутами ' . $zp_element['другие_атрибуты_товара'] . '. Стоимость первой опции -' . $option[0] . '- в атрибуте -' . $atr_name . '- должна быть нулевой!'; 
						return $shop_item;
					}
		
					$xxx[$option[0]] = $option[1];
				}
			
				$attributes[$count]['descr'] = $atr_descr;
				$attributes[$count]['type'] = $atr_type;
				$attributes[$count]['name'] = $atr_name;
				$attributes[$count]['options'] = $xxx;
	
				$count++;
			}

			if($error_format == 1)
			{
				$shop_item['Действие / результат'] = 'new error: Неверный формат строки с атрибутами ' . $zp_element['другие_атрибуты_товара']; 
				return $shop_item;
	   		}
	   		
	   		$zp_element['другие_атрибуты_товара'] = $attributes;
	   		
		} // end of if($zp_element['другие_атрибуты_товара'] != 'Нет' AND $zp_element['другие_атрибуты_товара'] != 'нет' AND $zp_element['другие_атрибуты_товара'] != '0' AND $zp_element['другие_атрибуты_товара'] != 0 AND $zp_element['другие_атрибуты_товара'] != ' ')
		
   	
     } // end of if($zp_element['type'] == 'товар' AND $zp_element['другие_атрибуты_товара']) // если заданы "другие" атрибуты товара, проверим, правильно ли задана строка с атрибутами
     
     
    
  	 
     

					
     
     
     
    
    
    
    
    
    

    
    
//-------------------------------------------------------------------------------------------    
// теперь, после всех проверок, задаём новый нид и вид

	$node->nid = db_next_id('{node}_nid');
    $node->vid = db_next_id('{node_revisions}_vid');
    
    
    
    
    
    
    
    
    
    
    
    
// начинаем внесение данных в базу    
//-------------------------------------------------------------------------------------------------------------------------	

	
	// если это не подгруппа (для неё не создаётся ноды, а только категория)
	// подготовим остальные данные для создания простой ноды и все данные внесём в базу 
	if($zp_element['type'] != 'подгруппа')
	{
		// копируем некоторые строки из стандартной функции друпала по добавлению новой ноды
  		
		// Split off revisions data to another structure
  		$revisions_table_values = array('nid' => $node->nid, 'vid' => $node->vid,
                		    	 'title' => $node->title, 'body' => $node->body,
        		        	     'teaser' => $node->teaser, 'timestamp' => $node->changed,
                     			 'uid' => $node->uid, 'format' => $node->format);
  		$revisions_table_types = array('nid' => '%d', 'vid' => '%d',
                     			'title' => "'%s'", 'body' => "'%s'",
                     			'teaser' => "'%s'", 'timestamp' => '%d',
                     			'uid' => '%d', 'format' => '%d');

  		$revisions_table_values['log'] = $node->log;
  		$revisions_table_types['log'] = "'%s'";

  		$node_table_values = array('nid' => $node->nid, 'vid' => $node->vid,
        		            'title' => $node->title, 'type' => $node->type, 'uid' => $node->uid,
                		    'status' => $node->status, 'created' => $node->created,
                    		'changed' => $node->changed, 'comment' => $node->comment,
                    		'promote' => $node->promote, 'sticky' => $node->sticky);
  		$node_table_types = array('nid' => '%d', 'vid' => '%d',
                    		'title' => "'%s'", 'type' => "'%s'", 'uid' => '%d',
                    		'status' => '%d', 'created' => '%d',
                    		'changed' => '%d', 'comment' => '%d',
                    		'promote' => '%d', 'sticky' => '%d');

  		//Generate the node table query and the
  		//the node_revisions table query
  		$node_query = 'INSERT INTO {node} ('. implode(', ', array_keys($node_table_types)) .') VALUES ('. implode(', ', $node_table_types) .')';
  		$revisions_query = 'INSERT INTO {node_revisions} ('. implode(', ', array_keys($revisions_table_types)) .') VALUES ('. implode(', ', $revisions_table_types) .')';
  
  		
		/* *///пока закомментируем реальные действия с базой
  		
  		// Insert the node into the database:
  		db_query($node_query, $node_table_values);
  		db_query($revisions_query, $revisions_table_values);

  		// Call the node specific callback (if any):
    	//node_invoke($node, 'insert');
    	//node_invoke_nodeapi($node, 'insert');
  		// Update the node access table for this node.
		node_access_acquire_grants($node);
  		// Clear the cache so an anonymous poster can see the node being added or updated.
  		//cache_clear_all();		
  		
  		/**/
		
	}
	

	
	
	// теперь внесём в базу первую часть данных по элементу, в зависимости от типа элемента
	switch($zp_element['type'])
	 {
	 	case 'страна':
	 	case 'населённый пункт':
	 	case 'район':
	 	case 'магазин':
	 	case 'подотдел':
	 		
			  
	 		// zp номер местоположения, возможно, что его и не нужно сохранять - артикула достаточно
	 		// db_query("INSERT INTO {content_field_zp_localn_place} (vid, nid, field_zp_localn_place_value) VALUES (%d, %d, '%s')", $node->vid, $node->nid, $zp_element['zp_number']);	 		  
	 		// zp артикул местоположения
	 		
	 		db_query("INSERT INTO {content_field_zp_art_place} (vid, nid, field_zp_art_place_value) VALUES (%d, %d, '%s')", $node->vid, $node->nid, $zp_element['zp_artikul']);
	 		if($zp_element['описание_элемента'])
	 		  db_query("INSERT INTO {content_field_description} (vid, nid, field_description_value) VALUES (%d, %d, '%s')", $node->vid, $node->nid, $zp_element['описание_элемента']);
	 		if($zp_element['подгруппа_или_тип_элемента'])
			  db_query("INSERT INTO {content_field_place_type} (vid, nid, field_place_type_value) VALUES (%d, %d, '%s')", $node->vid, $node->nid, $zp_element['подгруппа_или_тип_элемента']);	 		  
			  
			
	 		break;
	 		
	 	case 'товар':	 		
			$node->unique_hash = md5($node->vid . $node->nid . $node->model . $node->list_price . $node->cost . $node->sell_price . $node->weight . $node->weight_units . $node->length . $node->width . $node->height . $node->length_units . $node->pkg_qty . $node->default_qty . $node->shippable . time());
  			
			db_query("INSERT INTO {uc_products} (vid, nid, model, list_price, cost, sell_price, weight, weight_units, length, width, height, length_units, pkg_qty, default_qty, unique_hash, ordering, shippable) VALUES (%d, %d, '%s', %f, %f, %f, %f, '%s', %f, %f, %f, '%s', %d, %d, '%s', %d, %d)",
   	 				$node->vid, $node->nid, $node->model, $node->list_price, $node->cost, $node->sell_price, $node->weight, $node->weight_units, $node->length, $node->width, $node->height, $node->length_units, $node->pkg_qty, $node->default_qty, $node->unique_hash, $node->ordering, $node->shippable
 	 				);	
 	 		
  			
  			
  			// мера расфасовки при продаже
  			db_query("INSERT INTO {content_field_sell_measure} (vid, nid, field_sell_measure_value) VALUES (%d, %d, '%s')", $node->vid, $node->nid, $zp_element['продажная_единица_измерения']);	 		  
  			
			// внесём данные по количеству и данным по контролю количества
  			db_query("INSERT INTO {uc_product_stock} (sku, nid, active, stock, threshold) VALUES ('%s', %d, %d, %d, %d)", $zp_element['zp_artikul'], $node->nid, $zp_element['уменьшать_количество_при_продаже'], $zp_element['количество'], $zp_element['количество_ниже_которого_не_продавать']);	 		    			

  			
  			
  			/*
  			
  			// закоментированные данные заменены внесением данных по разным таблицам для любых типов продуктов (в других местах функции), вместо описанного здесь внесения всех данных в одну таблицу, но для отдельных типов данных
  			
  			// сформируем название поля с описанием в базе из названия типа товара
			//$type_of_product = explode('product_', $node->type); 
			//$type_of_product = $type_of_product[1];

			//db_query("INSERT INTO {content_type_product_clothes} (vid, nid, field_p_clothes_descr_value, field_zp_art_proizv_value,  field_zp_art_postav_value, field_zp_bar_postav_value, field_zp_art_shop_value, field_zp_brand_link_nid, field_zp_brand_nolink_value, field_zp_bar_shop_value, field_source_of_pics_value) VALUES (%d, %d, '%s', '%s', '%s', '%s', '%s', %d, '%s', '%s', '%s')", $node->vid, $node->nid, $zp_element['описание_элемента'], $zp_element['артикул_произв'], $zp_element['артикул_поставщ'], $zp_element['штрих_код_поставщ'], $zp_element['артикул_магазина'], '', $zp_element['название_бренда'], $zp_element['штрих_код_магазина'], $zp_element['source_of_pics']); 
			//db_query("INSERT INTO {content_type_product_" . $type_of_product . "} (vid, nid, field_p_" . $type_of_product . "_descr_value, field_zp_art_proizv_value,  field_zp_art_postav_value, field_zp_bar_postav_value, field_zp_art_shop_value, field_zp_brand_link_nid, field_zp_brand_nolink_value, field_zp_bar_shop_value, field_source_of_pics_value) VALUES (%d, %d, '%s', '%s', '%s', '%s', '%s', %d, '%s', '%s', '%s')", $node->vid, $node->nid, $zp_element['описание_элемента'], $zp_element['артикул_произв'], $zp_element['артикул_поставщ'], $zp_element['штрих_код_поставщ'], $zp_element['артикул_магазина'], '', $zp_element['название_бренда'], $zp_element['штрих_код_магазина'], $zp_element['source_of_pics']); 
			
			*/

  			
			//внесём описание продукта (для всех типов продуктов теперь храним описание в одной таблице - для сокращения количества таблиц)
			
			if( 
				!db_query("INSERT INTO {content_field_product_descr} (field_product_descr_value, nid, vid) VALUES ('%s', %d, %d)", $zp_element['описание_элемента'], $node->nid, $node->vid)
			  )
			  {
				$shop_item['Действие / результат'] = 'change error: ошибка при добавлении поля -' . $key . '- в базе со значением ' . $zp_element['описание_элемента']; 
				return $shop_item;
			  }
  			
 	 		break; // end of case: 'товар'

 	 		
	 } // end of switch($zp_element['type']) // теперь внесём в базу первую часть данных по элементу, в зависимости от типа элемента
	


	 
	 
	 
	// внесём очередную порцию данных по товару
	if($zp_element['type'] == 'товар')		
	  foreach ($zp_element as $key => $value)
	  {
		 switch($key)
		 {
		 	
		 	case 'штрих_код_произв':
				
					if( // если артикул/код не был задан изначально, попытаться его внести
						!db_query("INSERT INTO {content_field_zp_bar_proizv} (field_zp_bar_proizv_value, nid, vid) VALUES ('%s', %d, %d)", $value, $node->nid, $node->vid)
					  )
					  {
						$shop_item['Действие / результат'] = 'change error: ошибка при добавлении поля -' . $key . '- в базе со значением ' . $value; 
						return $shop_item;
					  }
					
					 break;
					 
		 	
			case 'артикул_произв':
				
					if( // если артикул/код не был задан изначально, попытаться его внести
						!db_query("INSERT INTO {content_field_zp_art_proizv} (field_zp_art_proizv_value, nid, vid) VALUES ('%s', %d, %d)", $value, $node->nid, $node->vid)
					  )
					  {
						$shop_item['Действие / результат'] = 'change error: ошибка при добавлении поля -' . $key . '- в базе со значением ' . $value; 
						return $shop_item;
					  }
				
					 break; 
				
				
					 
					 
			case 'штрих_код_поставщ':
				
					if( // если артикул/код не был задан изначально, попытаться его внести
						!db_query("INSERT INTO {content_field_zp_bar_postav} (field_zp_bar_postav_value, nid, vid) VALUES ('%s', %d, %d)", $value, $node->nid, $node->vid)
					  )
					  {
						$shop_item['Действие / результат'] = 'change error: ошибка при добавлении поля -' . $key . '- в базе со значением ' . $value; 
						return $shop_item;
					  }
				
					 break; 	
					 
					 
					 
			case 'артикул_поставщ':
				
					if( // если артикул/код не был задан изначально, попытаться его внести
						!db_query("INSERT INTO {content_field_zp_art_postav} (field_zp_art_postav_value, nid, vid) VALUES ('%s', %d, %d)", $value, $node->nid, $node->vid)
					  )
					  {
						$shop_item['Действие / результат'] = 'change error: ошибка при добавлении поля -' . $key . '- в базе со значением ' . $value; 
						return $shop_item;
					  }
				
					 break; 		 
					 
					 
					
			case 'штрих_код_магазина':
				
					if( // если артикул/код не был задан изначально, попытаться его внести
						!db_query("INSERT INTO {content_field_zp_bar_shop} (field_zp_bar_shop_value, nid, vid) VALUES ('%s', %d, %d)", $value, $node->nid, $node->vid)
					  )
					  {
						$shop_item['Действие / результат'] = 'change error: ошибка при добавлении поля -' . $key . '- в базе со значением ' . $value; 
						return $shop_item;
					  }
				
					 break; 		
					
					 
			
			case 'артикул_магазина':
				
					if( // если артикул/код не был задан изначально, попытаться его внести
						!db_query("INSERT INTO {content_field_zp_art_shop} (field_zp_art_shop_value, nid, vid) VALUES ('%s', %d, %d)", $value, $node->nid, $node->vid)
					  )
					  {
						$shop_item['Действие / результат'] = 'change error: ошибка при добавлении поля -' . $key . '- в базе со значением ' . $value; 
						return $shop_item;
					  }
				
					 break;	
					
			
				
			case 'название_бренда':
				
					if( // если артикул/код не был задан изначально, попытаться его внести
						!db_query("INSERT INTO {content_field_zp_brand_nolink} (field_zp_brand_nolink_value, nid, vid) VALUES ('%s', %d, %d)", $value, $node->nid, $node->vid)
					  )
					  {
						$shop_item['Действие / результат'] = 'change error: ошибка при добавлении поля -' . $key . '- в базе со значением ' . $value; 
						return $shop_item;
					  }
				
					 break;
			
			  

				
			default:
				break;
			
				
		 }	// end of switch($key) 
		 
	  } // end of foreach ($zp_element as $key => $value) // // внесём данные по артикулам и брендам в товар
	 
	 
	 
	 
	 // внесём в базу адреса, в зависимости от типа элемента
	switch($zp_element['type'])
	 {

	 	case 'населённый пункт':
	 	case 'район':
	 	case 'магазин':
	 	case 'подотдел':
	 		
	 		// записываем адрес в общую таблицу
	    	if($zp_element['address']) 
	    		db_query("INSERT INTO {content_field_place_address} (vid, nid, field_place_address_value)"
	    											   . " VALUES (%d, %d, '%s')", 
	    											   $node->vid, $node->nid, $zp_element['address']);	  
	    											   
	 		break;

	 		
	 	default:
	 		break;
	  	
	 } // end of switch($zp_element['type']) // внесём в базу вторую часть данных по элементу, в зависимости от типа элемента // теперь более индивидуальные данные

	 
	 
	 /*
	 // нужно ли заполнять таблицы с типами данных?
	 switch($zp_element['type'])
	 {
	 	
	 	
	 	case 'страна':
	 		// заполняем в таблицу с данными по типу страна
	 		
	 		// не уверен, что нужно вносить данные, если из данных есть только нода и ревизия...
	    	db_query("INSERT INTO {content_type_c_country} (vid, nid) VALUES (%d, %d)", $node->vid, $node->nid);
	 		break;
	 		
	 		
	 		
	 		
	 	case 'населённый пункт':
	 		// заполняем в таблицу с данными по типу город
	 		
	 		// не уверен, что нужно вносить данные, если из данных есть только нода и ревизия...
	    	db_query("INSERT INTO {content_type_c_city} (vid, nid) VALUES (%d, %d)", $node->vid, $node->nid);
	    	
	 		break;
	 		
	 		
	 		
	 		
	 	case 'район':
	 		// вносим в таблицу с данными по типу район данные об адресе
	 		
	 		// не уверен, что нужно вносить данные, если из данных есть только нода и ревизия...
	    	db_query("INSERT INTO {content_type_c_rajon} (vid, nid) VALUES (%d, %d)", $node->vid, $node->nid);
	    	
	 		break;
	 		
	 		
	 	default:
	 		break;
	  	
	 } // end of switch($zp_element['type']) 
	 
	 */

	 
	 
	 
	 
	 
	 
	 
// окончание внесения дополнительных данных (адресов и т.д.) по разным типам элементов	 
	 
	 	 








	 
	 // внесём в базу коэффициент доставки и минимальной суммы покупки (корзины), в зависимости от типа элемента
	switch($zp_element['type'])
	 {
	 	
	 	case 'страна':
	 	case 'населённый пункт':
	 	case 'район':
	 	case 'магазин':
	 	case 'подотдел':

	    	if
	 		(
				!db_query("INSERT INTO {content_field_d_factor} (vid, nid, field_d_factor_value) VALUES (%d, %d, %f)", $node->vid, $node->nid,  $zp_element['коэффициент_доставки'])
				  OR 
				!db_query("INSERT INTO {content_field_cart_min_sum_f} (vid, nid, field_cart_min_sum_f_value) VALUES (%d, %d, %f)", $node->vid, $node->nid, $zp_element['коэффициент_минимальной_суммы_покупки_(корзины)']) 
			)
			{
				$shop_item['Действие / результат'] = 'change error: ошибка при изменении коэффициентов Доставки или Минимальной суммы покупки (корзины)'; 
				return $shop_item;
			}

	 		break;

	 		
	 	default:
	 		break;
	  	
	 } // end of switch($zp_element['type']) // внесём в базу вторую часть данных по элементу, в зависимости от типа элемента // теперь более индивидуальные данные
	 

	 
	 
	 
	 
	 
	 
	 
	 
	
	// внесём в базу данные о категории, связях и родителях элемента, в зависимости от типа элемента
	// проверка на правильность связей уже проведена выше
	// уже определены вспомогательные переменные
	// $zp_element['term_parent_exists']
	// $zp_element['parent_podgruppa_tid']
	// $zp_element['term_is_dublicate']
	// $zp_element['existing_term_tid']
	// $zp_element['parent_otdel_tid_name']
	// $zp_element['parent_otdel_tid']
	// $zp_element['parent_tid_name']
	// $zp_element['parent_tid']

	switch($zp_element['type'])
	 {
		case 'страна':
						
			$new_tid = db_next_id('{term_data}_tid');
	    	$new_tid_description = '';
    		$new_tid_weight = 0;
    		$new_tid_voc_id = 1; // = catalog 	

    		echo 'new_tid =' . $new_tid;
    		// создаём терм для страны	
    		db_query("INSERT INTO {term_data} (tid, vid, name, description, weight) VALUES (%d, %d, '%s', '%s', %d)", $new_tid, $new_tid_voc_id, $node->title, $new_tid_description, $new_tid_weight);    		
    		// связываем созданный терм с его родителем. В данном случае родитель - 0 (корень каталога)
    		db_query("INSERT INTO {term_hierarchy} (tid, parent) VALUES (%d, %d)", $new_tid, 0);
    		//привязываем созданный терм к созданной ноде создаваемого элемента
    		db_query("INSERT INTO {term_node} (nid, tid) VALUES (%d, %d)", $node->nid, $new_tid);
			
			break;
	 		 
	 	case 'населённый пункт':	
	 	case 'район':
	 	case 'магазин':
	 	case 'подотдел':
	 	case 'подгруппа':
    		

    		/* 	// чтобы иметь возможность автоматически использовать существующий терм, нужно раскомментировать этот блок и задать способ, что следует делать
    			// - использовать существующий терм или же создавать новый с приставкой '_new'
    		if($zp_element['term_is_dublicate']) // если в базе уже есть у терм с таким названием у указанного родителя
    		{
    		    // если уже существует терм с таким же именем, которое мы хотим создать, 
				// есть два варианта:
				
				$dublicat_action = 'use_existing'; // используем уже существующий терм, к нему и подвязываем наш элемент
				//$dublicat_action = 'add_new'; // создаём новый терм, но с частицей '_new' в конце названия

				switch($dublicat_action)
				{
					case 'use_existing':
						// делаем соответствующую пометку в поле результата обработки элемнта
					    $shop_item['Действие / результат'] = '***Notice: Терм с названием ' . $node->title . ' уже существовал у данного родителя. Используем существующий терм';	    		
    		
    					// для любого типа , кроме подгруппы, созданный терм присваивается созданной ноде элемента
    					// просто у подгруппы нет своей ноды, поэтому и терм подгруппы существует сам по себе, пока к нему не будет подключён товар (товары)
    					if($zp_element['type'] != 'подгруппа')
    		  				db_query("INSERT INTO {term_node} (nid, tid) VALUES (%d, %d)", $node->nid, $zp_element['existing_term_tid']);
						
						break;
						
						
					case 'add_new':
						
						$new_tid = db_next_id('{term_data}_tid');
	    				$new_tid_description = '';
    					$new_tid_weight = 0;
    					$new_tid_voc_id = 1; // = catalog 	
          	
    					echo 'flag_is_dublicat =' . $flag_is_dublicat;
    					echo 'new_tid =' . $new_tid;
						
						// добавляем к имени терма '_new'
		    		    db_query("INSERT INTO {term_data} (tid, vid, name, description, weight) VALUES (%d, %d, '%s', '%s', %d)", $new_tid, $new_tid_voc_id, $node->title . '_new', $new_tid_description, $new_tid_weight);
					    
						// связываем созданный терм с его родителем
    					db_query("INSERT INTO {term_hierarchy} (tid, parent) VALUES (%d, %d)", $new_tid, $zp_element['parent_tid']);
    		
    					// для всех типов, кроме подгруппы созданный терм присваивается созданной ноде
    					// просто у подгруппы нет своей ноды, поэтому и терм подгруппы существует сам по себе, пока к нему не будет подключён товар (товары)
    					if($zp_element['type'] != 'подгруппа')
    		  				db_query("INSERT INTO {term_node} (nid, tid) VALUES (%d, %d)", $node->nid, $new_tid);
    		  				
    		  			// и делаем соответствующую пометку в поле результата обработки элемнта
					    $shop_item['Действие / результат'] = 'Notice: Терм с названием ' . $node->title . ' уже существовал у данного родителя. Создаём терм с именем с частицей _new';	    		

						break;
				} // end of switch($dublicat_action)
    		    
    		} // end of if($flag_is_dublicat) // если в базе уже есть у терм с таким названием у указанного родителя
    		else 
    		*/
    		{
    			$new_tid = db_next_id('{term_data}_tid');
	    		$new_tid_description = '';
    			$new_tid_weight = 0;
    			$new_tid_voc_id = 1; // = catalog 	
          	
    			echo 'flag_is_dublicat =' . $flag_is_dublicat;
    			echo 'new_tid =' . $new_tid;
    			
    			db_query("INSERT INTO {term_data} (tid, vid, name, description, weight) VALUES (%d, %d, '%s', '%s', %d)", $new_tid, $new_tid_voc_id, $node->title, $new_tid_description, $new_tid_weight);    		
    			// связываем созданный терм с его родителем
    			db_query("INSERT INTO {term_hierarchy} (tid, parent) VALUES (%d, %d)", $new_tid, $zp_element['parent_tid']);
    		
    			// для всех типов, кроме подгруппы созданный терм присваивается созданной ноде
    			// просто у подгруппы нет своей ноды, поэтому и терм подгруппы существует сам по себе, пока к нему не будет подключён товар (товары)
    			if($zp_element['type'] != 'подгруппа')
    		  		db_query("INSERT INTO {term_node} (nid, tid) VALUES (%d, %d)", $node->nid, $new_tid);
    		} // end of // если в базе нет терма с таким названием у указанного родителя, какое мы хотим создать

    		break;
    		
    		
    		
    		
    		
    		
    	case 'товар':
    		
    		// если терм подгруппы найден в базе в указанном отделе, присваиваем его создаваемому товару, иначе создаём сначала терм подгруппы, и созданный присваиваем создаваемому товару
    		if($zp_element['term_parent_exists'])
    		{
    			// присваиваем найденный (или созданный) терм подгруппы создаваемому товару 
     			db_query("INSERT INTO {term_node} (nid, tid) VALUES (%d, %d)", $node->nid, $zp_element['parent_podgruppa_tid']);
    		}
		
    		break; // end of case 'товар':
    		
    	
    	default:
    		break;
	 
	 } // end of switch($zp_element['type']) // следующий шаг создания и связывания категорий элемента
	
// конец внесения данных о связывании категорий ---------------------------------------------------------




	 
	 
	 
	 
	 
	 
	 
	 
	 
	 

// внесём в базу данные о картинках для указанного элемента -----------------------------------------------
	
	
	// если должны быть использованы не картинки товара из другого магазина (с другим артикулом), а оригинальные картинки с названием на основе одного из артикулов или штрихкодов
 	// создаём в базе все записи и связям по файлам касательно этих картинок, 
	// чтобы только осталось скопировать на сервер указанные файлы
	 	  
	// чуть раньше в базу в поле source_of_pics типа ноды было записано, как формируются картинки товара 
	// - либо  поле содержит значение в формате "copy *z1010101001001" (именно это должно быть записано в таблице, из которой производится загрузка данных) - при выводе страницы показываются картинки из другого товара
	// - либо указывается, на основе чего формируются названия файлов с картинками
	if(strpos($zp_element['source_of_pics'], 'copy *z') !== FALSE)
  	 {   
  	 	
  	 	// если задано копирование картинок из другого товара, записываем в это поле артикул этого другого товара 
  	 	
  	 	// сам артикул определён и проверен на наличие элемент с таким артикулом чуть раньше в этой функции
  	 	
 	 	if( 
			!db_query("INSERT INTO {content_field_source_of_pics} (field_source_of_pics_value, nid, vid) VALUES ('%s', %d, %d)", $zp_element['artikul_of_pic_source'], $node->nid, $node->vid)
		  )
		  {
			$shop_item['Действие / результат'] = 'new error: ошибка при добавлении поля со ссылкой на источник картинок в базе со значением артикула элемента-источника ' . $zp_element['artikul_of_pic_source']; 
			return $shop_item;
		  }

  	 }
  	else if($zp_element['type'] != 'подгруппа') // иначе добавляем данные о собственных картинках элемента, если только это не подгруппа // иначе добавляем данные о собственных картинках элемента
  	 {	
  	 	
  	 	
  	   if( // если ранее было задано копирование картинок из другого элемента, удалить эту запись из базы
			
			 db_result(db_query("SELECT nid from {content_field_source_of_pics} WHERE nid = %d", $node->nid))

		  )
		  {
			if( 
			
			 	!(db_query('DELETE FROM {content_field_source_of_pics} WHERE nid = %d', $node->nid))

		  	  )
		  	  {
		  		$shop_item['Действие / результат'] = 'new error: ошибка при удалении старой записи об источнике картинок'; 
				return $shop_item;
		      }

		  } // end of if( // если ранее было задано копирование картинок из другого элемента, удалить эту запись из базы
  	 	
  	 	
  	 	
  	 	
	   switch($zp_element['source_of_pics']) // На основе чего формируется название картинок
	    {
	    	
	    	case 'название':
					if(!$zp_element['новое_название'])
					{
						$shop_item['Действие / результат'] = 'change error: Не все данные внесены! Не внесены картинки! Не задано название элемента, а на его основе должны формироваться названия картинок'; 
						return $shop_item;
					}
							
					//$pic_name_base = $zp_element['новое_название']; //$shop_item['Название'];

					$pic_name_base = $node->title;
					$pic_amount = $zp_element['кол_во_картинок'];
					
					break;
			
							
							
			case 'зп-артикул':
					if(!$zp_element['zp_artikul'])
					{
						$shop_item['Действие / результат'] = 'change error: Не все данные внесены! Не внесены картинки! Не задан внутренний артикул-зп элемента, а на его основе должны формироваться названия картинок'; 
						return $shop_item;
					}
					
					$pic_name_base = $zp_element['zp_artikul'];
					$pic_amount = $zp_element['кол_во_картинок'];
					break;

							
							
			case 'ш-произв':

					if(!$shop_item['Штрих-код производителя'])
					{
						$shop_item['Действие / результат'] = 'change error: Не все данные внесены! Не внесены картинки! Не задан штрих-код производителя, а на его основе должны формироваться названия картинок'; 
						return $shop_item;
					}
							
					$val = zp_correct_quotes($shop_item['Штрих-код производителя']);

					if($val[0] . $val[1] . $val[2] == '###')
					{
						$val = explode('###', $val);
						$val = $val[1];
					}
					else if(strpos($val, '###') !== FALSE)
					{
						$val = explode('###', $val);
						$val = $val[0];
					}
							
					// убираем лишнее промежуточное действие
		 			//$zp_element['штрих_код_произв']	= $val;				
					//$pic_name_base = $zp_element['штрих_код_произв'];
								
					$pic_name_base = $val;
					$pic_amount = $zp_element['кол_во_картинок'];
					break;

							
							
			case 'арт-произв':
							
					if(!$shop_item['Арт. Произв'])
					{
						$shop_item['Действие / результат'] = 'change error: Не все данные внесены! Не внесены картинки! Не задан артикул производителя, а на его основе должны формироваться названия картинок'; 
						return $shop_item;
					}
								
					$val = zp_correct_quotes($shop_item['Арт. Произв']);

					if($val[0] . $val[1] . $val[2] == '###')
			 		{
						$val = explode('###', $val);
						$val = $val[1];
		 			}
		 			else if(strpos($val, '###') !== FALSE)
		 			{
		 				$val = explode('###', $val);
						$val = $val[0];
			 		}
							
					// убираем лишнее промежуточное действие
			 		//$zp_element['артикул_произв']	= $val;				
					//$pic_name_base = $shop_item['Арт. Произв'];
							
					$pic_name_base = $val;
					$pic_amount = $zp_element['кол_во_картинок'];
					break;
		
							
							
							
			case 'ш-поставщ':
								
					if(!$shop_item['Штрих-код поставщика'])
					{
						$shop_item['Действие / результат'] = 'change error: Не все данные внесены! Не внесены картинки! Не задан штрих-код поставщика, а на его основе должны формироваться названия картинок'; 
						return $shop_item;
					}
							
					$val = zp_correct_quotes($shop_item['Штрих-код поставщика']);
	
					if($val[0] . $val[1] . $val[2] == '###')
 					{
						$val = explode('###', $val);
						$val = $val[1];
					}
					else if(strpos($val, '###') !== FALSE)
 					{
 						$val = explode('###', $val);
						$val = $val[0];
					}
							
					// убираем лишнее промежуточное действие
					//$zp_element['штрих_код_поставщ'] = $val;				
					//$pic_name_base = $shop_item['Штрих-код поставщика'];
							
					$pic_name_base = $val;
					$pic_amount = $zp_element['кол_во_картинок'];
					break;
			
							
							
			case 'арт-поставщ':
								
					if(!$shop_item['Арт. Поставщ'])
					{
						$shop_item['Действие / результат'] = 'change error: Не все данные внесены! Не внесены картинки! Не задан артикул поставщика, а на его основе должны формироваться названия картинок'; 
						return $shop_item;
					}
				
					$val = zp_correct_quotes($shop_item['Арт. Поставщ']);
						if($val[0] . $val[1] . $val[2] == '###')
 					{
						$val = explode('###', $val);
						$val = $val[1];
					}
		 			else if(strpos($val, '###') !== FALSE)
		 			{
		 				$val = explode('###', $val);
						$val = $val[0];
			 		}
							
					// убираем лишнее промежуточное действие
			 		//$zp_element['артикул_поставщ'] = $val;				
					//$pic_name_base = $shop_item['Арт. Поставщ'];
							
					$pic_name_base = $val;
					$pic_amount = $zp_element['кол_во_картинок'];
					break;
							
							
			
			case 'ш-магазина':
							
					if(!$shop_item['Штрих-код магазина'])
					{
						$shop_item['Действие / результат'] = 'change error: Не все данные внесены! Не внесены картинки! Не задан штрих-код магазина, а на его основе должны формироваться названия картинок'; 
						return $shop_item;
					}
							
					$val = zp_correct_quotes($shop_item['Штрих-код магазина']);

					if($val[0] . $val[1] . $val[2] == '###')
		 			{
						$val = explode('###', $val);
						$val = $val[1];
			 		}
		 			else if(strpos($val, '###') !== FALSE)
		 			{
		 				$val = explode('###', $val);
						$val = $val[0];
		 			}
							
					// убираем лишнее промежуточное действие
			 		//$zp_element['штрих_код_магазина'] = $val;				
					//$pic_name_base = $shop_item['Штрих-код магазина'];
							
					$pic_name_base = $val;
					$pic_amount = $zp_element['кол_во_картинок'];
					break;
			
							
							
			case 'арт-магазина':
							
					if(!$shop_item['Арт. Магазина'])
					{
						$shop_item['Действие / результат'] = 'change error: Не все данные внесены! Не внесены картинки! Не задан артикул магазина, а на его основе должны формироваться названия картинок'; 
						return $shop_item;
					}
						
					$val = zp_correct_quotes($shop_item['Арт. Магазина']);

					if($val[0] . $val[1] . $val[2] == '###')
		 			{
						$val = explode('###', $val);
						$val = $val[1];
					}
					else if(strpos($val, '###') !== FALSE)
					{
		 				$val = explode('###', $val);
						$val = $val[0];
		 			}
							
					// убираем лишнее промежуточное действие
		 			//$zp_element['артикул_магазина'] = $val;				
					//$pic_name_base = $shop_item['Арт. Магазина'];
							
					$pic_name_base = $val;
					$pic_amount = $zp_element['кол_во_картинок'];
					break;

					
	 							
	 		default:
	 				// если в таблице не задано, как формируется картинка, прекращаем обработку этого элемента с грозным сообщением :)
					$shop_item['Действие / результат'] = 'new error: Не все данные внесены! Не внесены картинки! Не может формироваться название картинки на основе ' . $value . ' для типа ' . $zp_element['type'] . ' при изменении названия картинок'; 
					return $shop_item;
					
	    } // end of switch($shop_item['На основе чего формируется название картинок'])
			
	    
	    
	    // транслитерируем базу на случай, если она содержит кириллицу
	    $pic_name_base = translit_no_spaces($pic_name_base);
	    
	    
	    // добавляем в базу данные о картинках элемента
	    
	    if($zp_element['type'] != 'подгруппа' AND $pic_amount > 0)
	    {
	    	for($f_count = 1; $f_count <= $pic_amount; $f_count++)
	    	{
	    		$fid = db_next_id('{files}_fid');
	    		$delta = $f_count - 1; // т.к. дельта начинается с нуля, а нумерация картинок с еденицы
	    	
	    		$filename = $pic_name_base . '-p' . $f_count . '.jpg';
	    		$filepath = 'files/' . $zp_element['pics_path'] . '/' . $filename;
	    		$filemime = 'image/jpeg';
	    		$filesize = '';
	    	
				$file_title = '';
				$file_alt = '';
			
	    		db_query("INSERT INTO {files} (fid, nid, filename, filepath, filemime, filesize) VALUES (%d, %d, '%s', '%s', '%s', %d)", $fid, $node->nid, $filename, $filepath, $filemime, $filesize);
	    		
	    		switch($zp_element['type'])
	    		{
	    			case 'страна':
				 	case 'населённый пункт':	
	 				case 'район':
	 				case 'магазин':
	 				case 'подотдел':
	 					db_query("INSERT INTO {content_field_place_img} (vid, delta, nid, field_place_img_fid, field_place_img_title, field_place_img_alt) VALUES (%d, %d, %d, %d, '%s', '%s')", $node->vid, $delta, $node->nid, $fid, $file_title, $file_alt);
							 				
	    				break;
	    				
	    			case 'товар':
	    				// для того, чтобы заносить инфу о картинках в разные таблицы и поля для разных типов данных
	    				// сформируем название таблицы и поля в базе из названия типа товара
						//$type_of_product = explode('product_', $node->type); 
						//$type_of_product = $type_of_product[1];
						//$type_of_product = 'content_field_p_' . $type_of_product .'_img';

	    				//db_query("INSERT INTO {content_field_p_" . $type_of_product . "_img} (vid, delta, nid, field_p_" . $type_of_product . "_img_fid, field_p_" . $type_of_product  . "_img_title, field_p_" . $type_of_product . "_img_alt) VALUES (%d, %d, %d, %d, '%s', '%s')", $node->vid, $delta, $node->nid, $fid, $file_title, $file_alt);
	    				
	    				db_query("INSERT INTO {content_field_product_img} (vid, delta, nid, field_product_img_fid, field_product_img_title, field_product_img_alt) VALUES (%d, %d, %d, %d, '%s', '%s')", $node->vid, $delta, $node->nid, $fid, $file_title, $file_alt);
	    				
	    				break;
	    				
	    			default:
    					break;
    					
	    		} // end of switch($zp_element['type'])

	    	} // end of for($f_count = 1; $f_count <= $pic_amount; $f_count++)
	    
	    } // end of  if($zp_element['type'] != 'подгруппа' AND $pic_amount > 0)

	 } // end of else // если не копия другого товара, а оригинальные картинки
	    
	    
	 
	 
	 
	 
	 
	 
	    
	    
	// добавим данные о логотипах для магазинов и отделов
	
	// если должны быть использованы не логотипы из другого элемента (с другим артикулом), а оригинальные логотипы с названием на основе одного из артикулов или штрихкодов
 	// создаём в базе все записи и связям по файлам касательно этих картинок, 
	// чтобы только осталось скопировать на сервер указанные файлы
	 	  
	// чуть раньше в базу в поле source_of_pics типа ноды было записано, как формируются картинки товара 
	// - либо  поле содержит значение в формате "copy *z1010101001001" (именно это должно быть записано в таблице, из которой производится загрузка данных) - при выводе страницы показываются картинки из другого товара
	// - либо указывается, на основе чего формируются названия файлов с картинками
	
  if($zp_element['type'] == 'магазин' OR $zp_element['type'] == 'подотдел')
  {
	if(strpos($zp_element['logo'], 'copy *z') !== FALSE)
  	 {    
  	 	
		  
		//записываем в базу артикул этого другого товара, из которого должны браться логотипы
  	 	if( 
			!db_query("INSERT INTO {content_field_source_of_logo} (field_source_of_logo_value, nid, vid) VALUES ('%s', %d, %d)", $zp_element['artikul_of_logo_source'], $node->nid, $node->vid)
		  )
		  {
			$shop_item['Действие / результат'] = 'new error: ошибка при добавлении поля со ссылкой на источник картинок логотипов в базе со значением ' . $zp_element['artikul_of_logo_source']; 
			return $shop_item;
		  }
		  
		  
		  
		 // и всё-таки добавляем в элемент данные по логотипу магазина для верхнего меню (картинка формируется на основе внутреннего зп-артикула)
		 // это значит, что реально картинка будет браться всё же из другого элемента, но запись останется, 
		 // а своя картинка будет использована, как только будет удалена запись из базы об элементе, с которого следует брать логотипы
		 // (этот алгоритм должен быть реализован чере)
		 
		 if($zp_element['type'] == 'магазин')
	     {
	        
	    		$logo_name_base = translit_no_spaces($zp_element['zp_artikul']);
				$filemime = 'image/jpeg';
		    	$filesize = '';
	    	
				// данные о логотипе для меню вносятся всегда
				$fid_logomenu = db_next_id('{files}_fid');
		    	$filename_logomenu = $logo_name_base . '-logomenu' . '.jpg';
		    	$filepath_logomenu = 'files/' . $zp_element['pics_path'] . '/' . $filename_logomenu;
				$file_title_logomenu = '';
				$file_alt_logomenu = '';
			
		    	// добавляем в базу данные о файле с логотипом магазина для использования в описании
		    	db_query("INSERT INTO {files} (fid, nid, filename, filepath, filemime, filesize) VALUES (%d, %d, '%s', '%s', '%s', %d)", $fid_logomenu, $node->nid, $filename_logomenu, $filepath_logomenu, $filemime, $filesize);	    	
	    		
	    		// вносим в таблицу с данными о логотипе магазина в верхнем меню
		    	db_query("INSERT INTO {content_type_c_shop} (vid, nid, field_logo_upmenu_fid, field_logo_upmenu_title, field_logo_upmenu_alt)"
	    											   . " VALUES (%d, %d, %d, '%s', '%s')", 
	    											   $node->vid, $node->nid, $fid_logomenu, $file_title_logomenu, $file_alt_logomenu);	
	    											   
	     } // end of if($zp_element['type'] == 'магазин')

 	 }
  	 else // иначе добавляем данные о собственных логотипах элемента
  	 {	
  	 	if( // если ранее было задано копирование картинок из другого элемента, удалить эту запись из базы
			
			 db_result(db_query("SELECT nid from {content_field_source_of_logo} WHERE nid = %d", $node->nid))

		  )
		  {
			if( 
			
			 	!(db_query('DELETE FROM {content_field_source_of_logo} WHERE nid = %d', $node->nid))

		  	  )
		  	  {
		  		$shop_item['Действие / результат'] = 'new error: ошибка при удалении старой записи об источнике картинок логотипов'; 
				return $shop_item;
		      }

		  } // end of if( // если ранее было задано копирование картинок из другого элемента, удалить эту запись из базы
  	 	
  	 	
		  
		  
	    switch($zp_element['type'])
	    {
	    	
	    	case 'магазин':

	    		$logo_name_base = translit_no_spaces($zp_element['zp_artikul']);
				$filemime = 'image/jpeg';
		    	$filesize = '';
	    	
				// данные о логотипе для меню вносятся всегда
				$fid_logomenu = db_next_id('{files}_fid');
		    	$filename_logomenu = $logo_name_base . '-logomenu' . '.jpg';
		    	$filepath_logomenu = 'files/' . $zp_element['pics_path'] . '/' . $filename_logomenu;
				$file_title_logomenu = '';
				$file_alt_logomenu = '';
			
		    	// добавляем в базу данные о файле с логотипом магазина для использования в описании
		    	db_query("INSERT INTO {files} (fid, nid, filename, filepath, filemime, filesize) VALUES (%d, %d, '%s', '%s', '%s', %d)", $fid_logomenu, $node->nid, $filename_logomenu, $filepath_logomenu, $filemime, $filesize);	    	
	    		
	    		// вносим в таблицу с данными о логотипе магазина в верхнем меню
		    	db_query("INSERT INTO {content_type_c_shop} (vid, nid, field_logo_upmenu_fid, field_logo_upmenu_title, field_logo_upmenu_alt)"
	    											   . " VALUES (%d, %d, %d, '%s', '%s')", 
	    											   $node->vid, $node->nid, $fid_logomenu, $file_title_logomenu, $file_alt_logomenu);		    	

				// если в таблице не указано, что логотипа нет, вносим в базу данные по логотипу
				if($zp_element['logo'] != 'нет') 
				 {
	    			$fid_logo = db_next_id('{files}_fid');
	    			$filename_logo = $logo_name_base . '-logo' . '.jpg';
	    			$filepath_logo = 'files/' . $zp_element['pics_path'] . '/' . $filename_logo;
					$file_title_logo = '';
					$file_alt_logo = '';
				
					// добавляем в базу данные о файле с логотипом магазина для верхнего меню
	    			db_query("INSERT INTO {files} (fid, nid, filename, filepath, filemime, filesize) VALUES (%d, %d, '%s', '%s', '%s', %d)", $fid_logo, $node->nid, $filename_logo, $filepath_logo, $filemime, $filesize);
					
		    		// вносим в таблицу с данными об обычном логотипе (для использования в описании)
		    		db_query("INSERT INTO {content_field_place_logo} (vid, nid, field_place_logo_fid, field_place_logo_title, field_place_logo_alt)"
	    														   . " VALUES (%d, %d, %d, '%s', '%s')", 
	    														   $node->vid, $node->nid, $fid_logo, $file_title_logo, $file_alt_logo);
	    											   
			 	} // end of if($zp_element['logo'] != 'нет') 
			 
			 	break;
			 	
			 	
			 	
			 	
			 case 'подотдел':
	 		
		 		// если в таблице указано, что логотипа нет для этого подотдела, выходим - не делаем записи в базе о файле картинки с логотипом
		 		if($zp_element['logo'] == 'нет')
	 			 break;
	 		
				$logo_name_base = translit_no_spaces($zp_element['zp_artikul']);

		    	$fid_logo = db_next_id('{files}_fid');
	    		$filename_logo = $logo_name_base . '-logo' . '.jpg';
	    		$filepath_logo = 'files/' . $zp_element['pics_path'] . '/' . $filename_logo;
				$file_title_logo = '';
				$file_alt_logo = '';
	    	
	    		$filemime = 'image/jpeg';
	    		$filesize = '';

	    		// добавляем в базу данные о файле с логотипом отдела для использования в описании
		    	db_query("INSERT INTO {files} (fid, nid, filename, filepath, filemime, filesize) VALUES (%d, %d, '%s', '%s', '%s', %d)", $fid_logo, $node->nid, $filename_logo, $filepath_logo, $filemime, $filesize);
	    	
	    		// вносим в таблицу с данными об обычном логотипе (для использования в описании)
		    	db_query("INSERT INTO {content_field_place_logo} (vid, nid,"
			    											   . " field_place_logo_fid, field_place_logo_title, field_place_logo_alt)"
	    													   . " VALUES (%d, %d, %d, '%s', '%s')", 
	    													   $node->vid, $node->nid, 
	    													   $fid_logo, $file_title_logo, $file_alt_logo);
	    											   
	    	
	    											   
	 			break;

	    } // end of switch($zp_element['type']) // добавим данные о логотипах для магазинов и отделов
	    

  	 } // end of else 
	    
  } // end of if($zp_element['type'] == 'магазин' OR $zp_element['type'] == 'подотдел')
	 
  // конец внесения данных о катинках логотипах элемента	 
	 


	

  
  
  

	
	
	
	
	
	
	
	 // если заданы "другие" атрибуты товара, внесём их
	 // ранее строка с атрибутами была разобрана в переменные:
	 
     // $attributes[$count]['type'] - тип атрибута (text, select, check, radio)
	 // $attributes[$count]['name'] - имя атрибута
	 // $attributes[$count]['descr'] - описание атрибута
	 // $attributes[$count]['options'] - опции со значением суммы прибавки к цене
	 
	 // пример 'select***Цвет***Описание атрибута[Красный^^^0---Зелёный^^^3,40]text***Размер[24^^^1.20---43^^^5.21]'
	 
     if($zp_element['type'] == 'товар' AND $zp_element['другие_атрибуты_товара'])
     {
	  if($zp_element['другие_атрибуты_товара'] != 'нет')
	  {
		foreach($attributes as $attribute) // перебираем указанные в таблице атрибуты товара
		{
			// выясним тип очередного атрибута в таблице
			switch($attribute['type'])
			{
				case 'text': 
					$attribute['type'] = 0;
					break;
				
				case 'select': 
					$attribute['type'] = 1;
					break;
					
				case 'radio': 
					$attribute['type'] = 2;
					break;
				
			}
			
			// выясним, определён ли в базе такой атрибут и выясним его aid 
			if( 
				!($aid = db_result(db_query("SELECT aid from {uc_attributes} WHERE name = '%s' AND display = %d", $attribute['name'], $attribute['type'])))
	  	  	  )
	  	  	  {
	  	  	  	
	  	  	  	// если такого атрибута в базе нет, вносим его в базу
  	 			if( 
					!db_query("INSERT INTO {uc_attributes} (name, ordering, required, display, description) VALUES ('%s', %d, %d, %d, '%s')", $attribute['name'], 0, 0, $attribute['type'], $attribute['descr'])
		  		  )
		  		  {
					$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. Ошибка при добавлении в базу нового атрибута -' . $attribute['name'] . '-'; 
					return $shop_item;
		  		  }
	  	  		
	  	  	  	// выясняем aid только что внесенного атрибута
	  	  	  	if( 
					!($aid = db_result(db_query("SELECT aid from {uc_attributes} WHERE name = '%s' AND display = %d", $attribute['name'], $attribute['type'])))
		  		  )
		  		  {
					$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. Ошибка при считывании aid только что добавленного в базу нового атрибута -' . $attribute['name'] . '-'; 
					return $shop_item;
		  		  }

	   	  	  } // end of // выясним, определён ли в базе такой атрибут и выясним его aid 
	   	  	  
	   	  	
	   	  	  
	   	  	// перебирвем все опции
	   	  	// выясним, определены ли в базе опции для этого атрибута, указанные в таблице
	   	  	// и выясним их oid
	   	  	$option_count = 0;
			foreach($attribute['options'] as $option_name => $add_price)
			{
				$option_count++;
				
				// выясним, определёна ли в базе такая опция у такого атрибута и выясним его oid 
				if( 
					!($oid = db_result(db_query("SELECT oid from {uc_attribute_options} WHERE name = '%s' AND aid = %d", $option_name, $aid)))
	  	  	  	  )
	  	  	  	  {
	  	  	  	
	  	  	  		// если такой опции нет в этом атрибуте в базе, вносим её в базу
	  	  	  		// задаём нулевые цены, так как это общие данные по опциям, а для каждого товара они будут задаваться свои
  	 				if( 
						!db_query("INSERT INTO {uc_attribute_options} (aid, name, cost, price, weight, ordering) VALUES (%d, '%s', %f, %f, %d, %d)", $aid, $option_name, 0, 0, 0, 0)
		  		  	  )
		  		  	  {
						$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. Ошибка при добавлении в базу новой опции -' . $option_name . '- атрибута -' . $attribute['name'] . '-'; 
						return $shop_item;
		  		  	  }
	  	  		
	  	  	  		// выясняем oid только что внесенной опции текущего атрибута
	  	  	  		if( 
						!($oid = db_result(db_query("SELECT oid from {uc_attribute_options} WHERE aid = %d AND name = '%s'", $aid, $option_name)))
		  		  	  )
		  		  	  {
						$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. Ошибка при считывании oid только что добавленной в базу новой опции -' . $option_name . '- атрибута -' . $attribute['name'] . '-'; 
						return $shop_item;
		  		  	  }
		  		  	  

		  		   } // end of // выясним, определёна ли в базе такая опция у такого атрибута и выясним его oid 	  
		  		  	  
	   	  	
	   	  			// как только определили первую опцию текущего атрибута, вносим атрибут в базу по текущему товару
	   	  			// (единожды вносим этот атрибут)
	   	  			// вносим в базу данные об этом атрибуте для этого товара
  	 				
	   	  			if($option_count == 1)
	   	  			 if( 
						!db_query("INSERT INTO {uc_product_attributes} (nid, aid, ordering, default_option, required, display) VALUES (%d, %d, %d, %d, %d, %d)", $node->nid, $aid, 0, $oid, 0, $attribute['type'])
		  	 		   )
		  	 		   {
						 $shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. Ошибка при добавлении атрибута -' . $attribute['name'] . '- к этому товару'; 
						 return $shop_item;
		  	 		   }
		  	 		   
		  	 		// вносим в базу данные о текущей опции для этого товара
  	 				if( 
						!db_query("INSERT INTO {uc_product_options} (nid, oid, cost, price, weight, ordering) VALUES (%d, %d, %f, %f, %d, %d)", $node->nid, $oid, 0, $add_price, 0, $option_count-1) // $option_count-1 - это порядок отображения опций, как в таблице, начиная с нуля (поэтому вычитаем единицу)
		  		 	  )
		  		 	  {
					 	$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. Ошибка при добавлении опции -' . $option_name . '- атрибута -' . $attribute['name'] . '- к этому товару'; 
						return $shop_item;
		  		  	  }

	
			} // end of foreach($attribute['options'] as $option => $add_price)
		
		 } // end of foreach($attributes as $attribute) // перебираем указанные в таблице атрибуты товара
		
	   } // end of if($zp_element['другие_атрибуты_товара'] != 'нет')

     } // end of if($zp_element['type'] == 'товар' AND $zp_element['другие_атрибуты_товара']) 
       // end of // если заданы "другие" атрибуты товара, внесём их
     
	
	
	
     
     
     
	
     
     
// добавим к элементу Опцию "Ваши пожелания" со значением по умолчанию (нет),
	// если в этом поле стоит "есть" или "1"

	if($zp_element['атрибут_ваши_пожелания_(нет)'] == 'есть' OR $zp_element['атрибут_ваши_пожелания_(нет)'] == '1')
	{
		// атрибуты имеют только товары
		switch($zp_element['type'])
		{
			case 'товар':
				 
				// выясним aid атрибута "Ваши пожелания к товару (укажите)"
				if( 
					!($aid = db_result(db_query("SELECT aid from {uc_attributes} WHERE name = '%s'", 'Ваши пожелания к товару (укажите)')))
	  	  	  	  )
	  	  	  	  {
	  	  	  	  	
	  	  	  	  	/*
	  	  	  	  	// если такой атрибут не определён в системе, пропускаем добавление атрибута в элемент
					//$shop_item['Предупреждения'] = 'new warning: в базе не определён атрибут -Ваши пожелания к товару (укажите)-'; 
	  	  	  	  	$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. В базе не определён атрибут -Ваши пожелания к товару (укажите)-'; 
					return $shop_item;
					*/
					
					
					
					
					// если такого атрибута в базе нет, вносим его в базу
  	 				if( 
						!db_query("INSERT INTO {uc_attributes} (name, ordering, required, display, description) VALUES ('%s', %d, %d, %d, '%s')", 'Ваши пожелания к товару (укажите)', 10, 0, 0, 'Например, "Дата изготовления не позднее вчерашнего дня".') // 10 - ставим этот атрибут последним, если будут другие атрибуты
		  		 	  )
		  		  	  {
						$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. Ошибка при добавлении в базу нового атрибута -Ваши пожелания к товару (укажите)-'; 
						return $shop_item;
		  		  	  }
	  	  		
	  	  	  		// выясняем aid только что внесенного атрибута
	  	  	  		if( 
						!($aid = db_result(db_query("SELECT aid from {uc_attributes} WHERE name = '%s' AND display = %d", 'Ваши пожелания к товару (укажите)', 0))) // 0 - текстовое поле
		  		  	  )
		  		  	  {
						$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. Ошибка при считывании aid только что добавленного в базу нового атрибута -Ваши пожелания к товару (укажите)-'; 
						return $shop_item;
		  		  	  }
	   	  	      }
	   	  	      
	   	  	      
				
				// выясним номер oid для опции "Нет" атрибута "Ваши пожелания к товару (укажите)"
				if( 
					!($oid = db_result(db_query("SELECT oid from {uc_attribute_options} WHERE aid = %d AND name = '%s'", $aid, 'Нет')))
	  	  	  	  )
	  	  	  	  {
	  	  	  	  	/*
	  	  	  	  	// если такая опция не определёна в системе, пропускаем добавление атрибута в элемент
					//$shop_item['Предупреждения'] = 'new warning: в базе не определён атрибут -Ваши пожелания к товару (укажите)-'; 
	  	  	  	  	$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. В базе не определёна опция -Нет- для атрибута -Ваши пожелания к товару (укажите)-'; 
					return $shop_item;
					*/
					
					
					
					
					// если такой опции нет в этом атрибуте в базе, вносим её в базу
  	 				if( 
						!db_query("INSERT INTO {uc_attribute_options} (aid, name, cost, price, weight, ordering) VALUES (%d, '%s', %f, %f, %d, %d)", $aid, 'Нет', 0, 0, 0, 0)
		  		  	  )
		  		  	  {
						$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. Ошибка при добавлении в базу новой опции -Нет- атрибута -Ваши пожелания к товару (укажите)-'; 
						return $shop_item;
		  		  	  }
	  	  		
	  	  	  		// выясняем oid только что внесенной опции текущего атрибута
	  	  	  		if( 
						!($oid = db_result(db_query("SELECT oid from {uc_attribute_options} WHERE aid = %d AND name = '%s'", $aid, 'Нет')))
		  		  	  )
		  		  	  {
						$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. Ошибка при считывании oid только что добавленной в базу новой опции -Нет- атрибута -Ваши пожелания к товару (укажите)-'; 
						return $shop_item;
		  		  	  }
		  		  	  
		  		  	  
	   	  	      }
	   	  	      
	   	  	      
	   	  	      
	   	  	      
	   	  	    // вносим в базу данные об этом атрибуте для этого элемента
  	 			if( 
					!db_query("INSERT INTO {uc_product_attributes} (nid, aid, ordering, default_option, required, display) VALUES (%d, %d, %d, %d, %d, %d)", $node->nid, $aid, 10, $oid, 0, 0) // ordering ставим 10, чтобы Поле с пожеланиями стояло последним после любых других атрибутов
		  		  )
		  		  {
					$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. Ошибка при добавлении атрибутв -Ваши пожелания к товару (укажите)-'; 
					return $shop_item;
		  		  }
		  		  
		  		// вносим в базу данные об опции (Нет) этого атрибуте для этого элемента
  	 			if( 
					!db_query("INSERT INTO {uc_product_options} (nid, oid, cost, price, weight, ordering) VALUES (%d, %d, %f, %f, %d, %d)", $node->nid, $oid, 0, 0, 0, 0)
		  		  )
		  		  {
					$shop_item['Действие / результат'] = 'new error: Не все данные внесены по этому элементу. Ошибка при добавлении атрибутв -Ваши пожелания к товару (укажите)-'; 
					return $shop_item;
		  		  }
		  		
		  		  
		  		    
		  	default: 
				break;
				
		
		} // end of switch($zp_element['type']) // атрибуты имеют только товары
			
	} // end of if($zp_element['опция_ваши_пожелания_(нет)'] == 'есть' OR $zp_element['опция_ваши_пожелания_(нет)'] == '1')


     
	
	
	
	
	





				// после обработки данных помещаем в выходную таблицу сохранённые строки с историей, 
				// убирая маркер изменения ### с начала строки (что значит, что при следующей итерации это поле изменяться не будет)
				foreach ($new_value_with_history as $key => $value)
				{
					//echo '-key = ' . $key . ', old $shop_item[key] = ' . $shop_item[$key] . '<br>';
					// после внесения в базу, сохраняем в поле с названием полную историю изменения названия, лишь убрав из ней первые три символа ### (если они там были)
	 				// перед этим восстанвливаем первоначальный вид кавчек, если они были
					
	 				
	 				//$shop_item[$key] = zp_restore_quotes($new_value_with_history[$key]); // восстанавливаем полное значение поля, если оно имело историю (убирая признак изменения элемента, если он стоял вначале строки.... остальные разделители версий и сами версии названия остаются)
	 				
	 				$shop_item[$key] = zp_restore_quotes($value); // восстанавливаем полное значение поля, если оно имело историю (убирая признак изменения элемента, если он стоял вначале строки.... остальные разделители версий и сами версии названия остаются)
	 				
	 				//echo '+key = ' . $key . ', new $shop_item[key] = ' . $shop_item[$key] . '<br>';
				}	   
					  	    
    



    // конец функции ----------------------------------------------------------------------------------------------------------- 	 
	return $shop_item;	
}

























// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// запись результатов в файлы обработанных данных и отметки заданий----------------------

function zp_write_results($zp_catalog_processed,
						  $fields, 
	                      $zp_input_data, 
                          $zp_input_data_commented, 
                          $start_num_string,
                          $stop_num_string, 
                          $real_stop_num_string)
{                    
  
    global $zp_server_directory;
	global $zp_preprocess_data;
	    
	echo '<br>zp_catalog_processed: <br>';
	//print '<PRE>';
	//print_r($zp_catalog_processed);
	//print '</PRE>';
	
	
   //echo 'processed_catalog_filename = ' . $zp_preprocess_data['processed_catalog_filename'] . '<br>';
  
// записать результаты в файлы обработанных данных и отметки заданий----------------------
// -------------------------------------------------------------------------------------   

   
  // если в файле отчёта не были найдены предыдущие результаты вычислений по текущему обрабатываемому файлу, 
  // создадим новый файл для обработанных данных (копия каталога, но с очищенными от инструкций к действиям (изменить, добавить и т.д.) полями)
  // естественно, это же название поместим и в файл отчёта (в формате "<исходный файл>  <диапазон обработанных строк>  <выходной файл, очищенный от инструкций>")
  $flag_new_processed_file = 0;
  if(!$zp_preprocess_data['processed_catalog_filename'])
   {

    	$processed_catalog_filename = explode('---', $zp_input_data['catalog_filename']);
    	$zp_preprocess_data['processed_catalog_filename'] = $processed_catalog_filename[0] . date("---d-m-y--H-i");// . '_out.csv';
    	$flag_new_processed_file = 1; // указываем, что выходные данные будут записываться впервые, в новый файл... следовательно, нужно будет записать в файл все данные до табличных и затем название полей
   }
   else 
   {
   	$processed_catalog_filename = explode('_out', $zp_preprocess_data['processed_catalog_filename']);   	
   	$zp_preprocess_data['processed_catalog_filename'] = $processed_catalog_filename[0];
   }   
   
//echo 'new processed_catalog_filename = ' . $zp_preprocess_data['processed_catalog_filename'] . '<br>';

  //foreach ($zp_catalog[1] as $key => $value)
   //echo $key . '=>' . $value . '<br>';
   
  //foreach ($fields as $key => $value)
   //echo $key . '=>' . $value . '<br>';
  
   
   //$zp_server_directory = 'http://www.zapokupkami.com/zp_import/';
   //$zp_server_directory = 'D:\\WebServers\\home\\zapokupkami.com\\www\\zp_import\\';

   //echo 'processed_catalog_filename = ' . $zp_preprocess_data['processed_catalog_filename'] . '<br>';
   //echo 'zp_server_directory = ' . $zp_server_directory . '<br>';
   
   // to test only
   $file = $zp_server_directory . $zp_preprocess_data['processed_catalog_filename'] . '_out.csv' . '<br>';
   //echo 'file = ' . $file;
      
   if (!($fp = fopen($zp_server_directory . $zp_preprocess_data['processed_catalog_filename'] . '_out.csv', 'a+'))) 
     {
        echo 'Ошибка записи в выходной файл каталога';
        return;
     }
     else 
     {	
     	// если обработанные данные выводядся в новый файл (впервые) выводим данные, предшествующие табличным, и название полей
     	if($flag_new_processed_file)
     	{
     	  fwrite($fp, $zp_preprocess_data['processed_catalog_filename'] . '.csv
');	
     	  // пропускаем пару строк
     	  fwrite($fp, '


');
     	
     	  // внесём все данные, предшествующие табличным	
     	  foreach($zp_input_data as $key => $value)
           {
     		
     	     fwrite($fp, '>' . utf8_to_cp1251($key) . '>' . utf8_to_cp1251($value) . '
');	
     	   }
     	  
     	    
     	  // пропускаем пару строк 
     	  fwrite($fp, '


');
     	  
     	  // внесём все закоментированные данные, предшествующие табличным	
     	  foreach($zp_input_data_commented as $value)
           {
     		
     		fwrite($fp, utf8_to_cp1251($value) . '
');	
     	   }

     	   
     	   // пропускаем пару строк
     	  fwrite($fp, '


');
     	  
     	  fwrite($fp, '>>>
');
     	  // выведем название полей	
     	  $string = implode(';', $fields);
     	  $string = utf8_to_cp1251($string);
     	  fwrite($fp, $string . '
');
		
     	}
     	
     	// выводим в файл все табличные данные построчно
     	$flag_errors = 0;
     	
     	foreach ($zp_catalog_processed as $string){
         //echo $key . '=>' . $value . '<br>';
         //print implode(';', $string);
     	 
     	 //fwrite($fp, iconv("UTF-8", "cp1251" ,implode(';', $string)) . '
     	 //fwrite($fp, iconv("UTF-8", "WINDOWS", implode(';', $string)) . '
     	 //fwrite($fp, utf8_win(implode(';', $string)) . '

     	 // если поле 'Действие / результат' не пустое
     	 // не записываем эту строку (этот элемент) в базу
     	 // таким образом, в выходной файл попадут только успешные данные,
     	 
     	 // Таким образом, после исправления, можно будет проганять то же задание второй раз
     	 // при этом уже введённые данные покажут ошибку (уже введено, исправлено и т.д.)
     	 // и будут пропущены, а исправленные с учётом предыдущих ошибок будут теперь правильно обработаны и введены в базу 
     	 // и, соответственно, записаны в результирующий выходной файл
     	 
     	 if($string['Действие / результат'] != '' AND $string['Действие / результат'] != '' AND $string['Действие / результат'] != '>>')
     	 {
			if(!$flag_errors) // если это первая запись в файл ошибок, создаём пустой файл и добавляем в него название полей
			{
     	 		if (!($fp_errors = fopen($zp_server_directory . $zp_preprocess_data['processed_catalog_filename'] . '_out_errors.csv', 'w'))) 
     			{
        			echo 'Ошибка записи в выходной файл c каталога с пояснением ошибок';
        			return;
     			}
     			else 
     			{
     				// выведем название полей	
   			  	  	$fields = implode(';', $fields);
     	  			$fields = utf8_to_cp1251($fields);
     	  			fwrite($fp_errors, $fields . '
');
     	 			fclose($fp_errors);
     	 			
     	 			$zp_preprocess_data['processed_catalog_filename_errors'] = $zp_preprocess_data['processed_catalog_filename'] . '_out_errors.csv';
     			}
			}	
     	 	
   	  	 	
     	 	
     	 	$flag_errors = 1;
			
			if (!($fp_errors = fopen($zp_server_directory . $zp_preprocess_data['processed_catalog_filename'] . '_out_errors.csv', 'a+'))) 
     		{
        		echo 'Ошибка записи в выходной файл c каталога с пояснением ошибок';
        		return;
     		}
     		else 
     		{
     			$string = implode(';', $string);
     	 		$string = utf8_to_cp1251($string);
     	 		fwrite($fp_errors, $string . '
');		
     	 		fclose($fp_errors);
     		}
     	 
     		
     		
     	 	continue;
     	 }
     	
     	
     	 
     	 $string = implode(';', $string);
     	 $string = utf8_to_cp1251($string);
     	 fwrite($fp, $string . '
');
     	}
     	
     	
        fclose($fp);
     }
  
        
// Теперь сделаем запись в файл отчёта выполнения задач 
// для того, чтобы в следующий раз уже не выполнять данную задачу
// -------------------------------------------------------------------
//---------------------------------------------------------------------------
    
   if(!$flag_errors) // если не было ошибок при вводе, записываем строку о выполнении задания в файл отчёта
   {				 // иначе не записываем. Таким образом, задание при следующем прогоне будет выполняться ещё раз 
   					 // (естественно, пользователь должен будет предварительно исправить указанные программой ошибки в исходном файле)
    
   	 if($fp = fopen($zp_server_directory . '---' . $zp_input_data['shop_filename_clear_for_schedule'] . '---schedule_report.csv', 'a')) 
     {
        

        // количество обработанных строк может отличаться от указанного в задании (может быть меньше, если строк реально меньше)
        // поэтому корректируем реальную цифру конечного номера строки и записываем реальный диапазон последним значением строки отчёта... Возможно, его можно будет в будущем как-то использовать
   
      	$schedule_report_current = date("d.m.y,H:i:s") . ' ' . $zp_input_data['catalog_filename'] . ' ' .  $start_num_string . '-' . $stop_num_string . ' ' . $zp_preprocess_data['processed_catalog_filename'] . '_out.csv' . ' ' . $start_num_string . '-' . $real_stop_num_string . '
';     	
     	
//      $schedule_report_current = date("d.m.y,H:i:s") . ' ' . $zp_input_data['catalog_filename'] . ' ' .  $start_num_string . '-' . $stop_num_string . ' ' . $zp_preprocess_data['processed_catalog_filename'] . '
//';
    	fwrite($fp, $schedule_report_current);
        fclose($fp);
     }  
     else
     {
    	echo 'error opening file';  	
     }
   }

}



















// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// загрузка данных из файлов ------------------------------------------------------------

function zp_load_data_from_files()
{
	
	global $fields;
	global $reported_tasks;
	global $scheduled_tasks; 
	global $zp_input_data;
	global $zp_input_data_commented;
	global $zp_catalog; 
	global $zp_catalog_processed;
	global $zp_preprocess_data;	
	global $zp_server_directory;


  //echo 'filename from dialog =  ' .  $form_values['csvfile'] .'<br>';
  
///home/rasmus/file.gif
  //if (!$fp = fopen($file_name, 'r')) {
  //if (!$fp = fopen(realpath('/zp_import/') . '---zp_shop_input_data.csv', 'a')) {
  //if (!$fp = fopen('home/zapokupkami.com/www/zp_import/' . '---zp_shop_input_data.csv', 'a')) {
  //if (!$fp = fopen(realpath('/zp_import') . '---zp_shop_input_data.csv', 'r')) {
  if (!$fp = fopen($zp_server_directory . $zp_preprocess_data['zp_shop_input_data'], 'r')) {
  	return 'Ошибка открытия файла ' . $zp_preprocess_data['zp_shop_input_data'];
  }

  //если первая строка не название файла (списка), закончить
  $buffer = trim(fgets($fp));
  //echo 'buffer =  ' .  $buffer .'<br>';
  
  
  $buffer = strpos($zp_preprocess_data['zp_shop_input_data'], $buffer);
  if($buffer === false) 
  {
  	return 'Неверный формат файла - первая строка не имя файла в файле ' . $zp_preprocess_data['zp_shop_input_data'];
  } 
  
  while(($buffer = trim(fgets($fp))) != '>>' AND !feof($fp))
  {
    if(!$buffer OR $buffer =='')
     continue;
    
    $buffer = explode('>', $buffer);
    $zp_input_data[$buffer[1]] = $buffer[2];
  }
  
  if(!$zp_input_data['shop_filename_clear_for_schedule'])
   {
   	 return 'Неверный формат файла расписания - не определён магазин для обработки';
   }
   else 
   {
   	//$file_date_time = explode('.', $zp_input_data['shop']);
   	//$file_date_time = explode('---', $file_date_time[0]);
   	//$zp_input_data['shop'] = $file_date_time[0];
   	//$file_date_time = explode('--', $file_date_time[1]);
   	
   	//$zp_input_data['file-data'] = $file_date_time[0];
   	//$zp_input_data['file-time'] = $file_date_time[1];
   }
  
   fclose($fp);



//---------------- считываем список задач из файла с расписанием
  

  //$file_name = '---' . $zp_input_data['shop_filename_clear_for_schedule'] . '---schedule.csv';
  $zp_preprocess_data['zp_schedule_file'] = '---' . $zp_input_data['shop_filename_clear_for_schedule'] . '---schedule.csv';
  //if (!$fp = fopen($file_name, 'r')) {
  if (!$fp = fopen($zp_server_directory . $zp_preprocess_data['zp_schedule_file'], 'r')) 
  {
   return 'Ошибка открытия файла ' . $zp_preprocess_data['zp_schedule_file'];
  }

  $zp_input_data['catalog_filename'] = trim(fgets($fp));
  
  
  //echo 'catalog_filename =  ' .  $zp_input_data['catalog_filename'] .'<br>';

  
  
  
  
  
  
  //если первая строка не название файла (нет в строке расширения csv), закончить
  $buffer = strpos($zp_input_data['catalog_filename'], 'csv');
   if($buffer === false) 
   {
     return 'Неверный формат файла ' . $zp_input_data['catalog_filename'] . ' (первая строка не имя файла)';
   } 
   
   
  //если вторая строка не специальный символ >, закончить
  $buffer = trim(fgets($fp));
  if($buffer != '>') 
  {
    return 'Неверный формат файла ' . $zp_input_data['catalog_filename'];
  } 
 

  //внести все запланированные задачи из файла (ограничитель >>)
  for ($i = 0; (($buffer = trim(fgets($fp))) != '>>'); $i++)  
  {
    if(($buffer[0] == '/' AND $buffer[1] == '/') OR $buffer == '' OR $buffer == ' ') // если закомментировано, пропускаем строку
     continue;
     
    
    // если строка содержит указание о порядке обработки строк - inverse говорит об обратном порядке обработки (с конца в начало)
    $inverse = explode(' ', $buffer);
    if($inverse[1] == 'inverse')
    {
		$buffer = $inverse[0];
    	$inverses[$i] = 'inverse';
    }
    
    $scheduled_tasks[$i] = $buffer;
    
    //echo 'scheduled tasks =  ' .  $scheduled_tasks[$i] .'<br>';
  }
 
  $zp_preprocess_data['scheduled_tasks'] = $scheduled_tasks;
  
  
  fclose($fp);
  
//----------конец загрузки списка задач 





 // заполнение списка с реализованными задачами
  
  //$file_name = '---' . $zp_input_data['shop_filename_clear_for_schedule'] . '---schedule_report.csv';
  $zp_preprocess_data['zp_schedule_report'] = '---' . $zp_input_data['shop_filename_clear_for_schedule'] . '---schedule_report.csv';
  
  if (!$fp = fopen($zp_server_directory . $zp_preprocess_data['zp_schedule_report'], 'r')) 
  {
    return 'Ошибка открытия файла ' . $zp_preprocess_data['zp_schedule_report'];
  }  
  
  
  
  for ($i = 0; !feof($fp) AND (($buffer = trim(fgets($fp))) != '>>'); $i++)  
  {
    if(($buffer[0] == '/' AND $buffer[1] == '/') OR $buffer == '' OR $buffer == ' ') // если строка в файле закомментирована, пропускаем её
     continue;
     
    $reported_tasks[$i] = $buffer;
    
      //echo 'reported tasks =  ' .  $reported_tasks[$i] .'<br>';
  
  }  

  $zp_preprocess_data['reported_tasks'] = $reported_tasks;
  
  $reported_tasks_amount = $i;
    
    fclose($fp);

  // конец заполнения списка с реализованными задачами


  // если последняя отправка произошла менее, 
  // чем заданный минимальный интервал $post_time_interval,
  // заканчиваем выполнение программы
  // иначе продолжаем
 
 
  $last_time_reported = explode(" ", $reported_tasks[$reported_tasks_amount-2]);
  $last_time_reported = $last_time_reported[0];
  $last_time_reported = explode(",", $last_time_reported);
  $last_date_reported = explode(".", $last_time_reported[0]);
  $last_time_reported = $last_time_reported[1];
  $last_time_reported = explode(":", $last_time_reported);
  // сколько секунд прошло с начала дня указанной даты, когда было выполнено задание?
  $last_time_reported = $last_time_reported[0]*60*60 + $last_time_reported[1]*60 + $last_time_reported[2];
  
  $current_time = date("d.m.y,H:i:s");
  $current_time = explode(",", $current_time);
  $current_date = explode(".", $current_time[0]);
  $current_time = $current_time[1];
  $current_time = explode(":", $current_time);
  // сколько секунд прошло с начала сегодняшнего дня до текущего момента?
  $current_time = $current_time[0]*60*60 + $current_time[1]*60 + $current_time[2];

  if($current_date[2] < $last_date_reported[2])
  {
  	return 'В файле расписания: текущий год меньше, чем год выполнения прошлой задачи... Такого вообще не может быть!';
  }
   
  if($current_date[1] < $last_date_reported[1] AND $current_date[2] == $last_date_reported[2])
  {
  	return 'В файле расписания: текущий месяц меньше, чем месяц выполнения прошлой задачи при одинаковом годе... Такого вообще не может быть!';
  }
  
  if($current_date[0] < $last_date_reported[0] AND $current_date[1] == $last_date_reported[1] AND $current_date[2] == $last_date_reported[2])
  {
  	return 'В файле расписания: текущее число меньше, чем число выполнения прошлой задачи при одинаковом месяце и годе... Такого вообще не может быть!';
  }
  
  // теперь остались варианты только такого же числа, месяца, года или больше сегодня, чем дата прошлой отправки

/*  
  // если даты совпадают, проверяем условия соответствия времени
  // если условия по датам не совпадают (текущее число, месяц или год больше даты прошлой расссылки), то значит время проверять время не нужно - оно в любом случае правильное 
  if($current_date[0] == $last_date_reported[0] AND $current_date[1] == $last_date_reported[1] AND $current_date[2] == $last_date_reported[2])
  {
    // Если прошло менее установленного минимального времени (между отправками) с момента последней отправки
    // заканчиваем программу, иначе продолжаем
    if($current_time < ($last_time_reported + $post_time_interval*60))
    {
      echo 'Прошло всего ' . ($current_time - $last_time_reported)/60 . ' минут (менее установленного времени с момента последней отправки), а должно пройти ' . $post_time_interval . ' минут';
       return;
    }
  }
*/

  
  //находим нереализованную задачу в списке запланированных задач
  $current_task = 0; // обнуляем текущую задачу
  foreach ($scheduled_tasks as $i => $scheduled_task)
  {
  	foreach ($reported_tasks as $reported_task)
  	{
  		
  		//echo 'reported_task = ' . $reported_task;
  		
  		$reported_task = explode(" ", $reported_task);
  		$reported_task_check = $reported_task[1] . ' ' . $reported_task[2];
  		if($reported_task_check == $zp_input_data['catalog_filename'] . ' ' . $scheduled_task )
  		{
		  // если обработка файла с таким названием уже производилась, сохранить название обработанного файла каталога, чтобы в него производить дозапись
		  // если ни одного обработанного файла не найдено, при записи обработанного файла каталога необходимо будет сгенерировать новое название выходного файла (по дате и времени) и произвести в него запись
  		  
		  //$zp_preprocess_data['processed_catalog_filename'] = $reported_task[3];
  		  $zp_preprocess_data['processed_catalog_filename'] = $reported_task[3];
  		  //echo '1 zp_preprocess_data[processed_catalog_filename] = ' . $zp_preprocess_data['processed_catalog_filename'];
  		  continue 2;
  		}  
  		
  	}
  	$zp_preprocess_data['current_task'] = $scheduled_task; // если в выполненных задачах нет текущей проверяемой задачи из запланированных
  	                                 // значит назначаем её текущей выполняемой
  	if($inverses[$i] == 'inverse')
	    $zp_preprocess_data['inverse'] = 'yes';
	
    break; // прекратим перебор запланированных заданий, так как уже нашлось задание, которое ещё не выполнено 	                                 
  }
  
  
 
  
  
  if(!$zp_preprocess_data['current_task'])
  { 
    return 'В файле расписания: нет невыполненных задач! Программа остановлена. <BR> Загрузите файл с новым расписанием задач!';
  }
  
  //$start_num_letter = explode('-', $current_task);
  $start_num_string = explode('-', $zp_preprocess_data['current_task']);
  $zp_preprocess_data['stop_num_string'] = $start_num_string[1]; // начальная строка списка адресов для текущей задачи рассылки
  $zp_preprocess_data['start_num_string'] = $start_num_string[0]; // конечная строка списка адресов для текущей задачи рассылки



  
  //echo 'current_task =  ' .  $zp_preprocess_data['current_task'] .'<br>';
  

  
  
  
  
  
  
  
  
//---------------- заполняем все данные из определённого на предыдущем этапе файла c табличными данными


  if (!$fp = fopen($zp_server_directory . $zp_input_data['catalog_filename'], 'r')) 
  {
     return 'Ошибка открытия файла с исходной таблицей ' . $zp_input_data['catalog_filename'];
  }
  
  $buffer = explode(';', fgets($fp));
  
  $buffer = trim($buffer[0]);
  if($buffer == '') 
  {
   return 'Неверный формат файла ' . $zp_input_data['catalog_filename'];
  }
  
  
  /*
  //если первая строка не входит в название файла (города), закончить
  $buffer = strpos($zp_input_data['catalog_filename'], $buffer);
  if($buffer === false) 
  {
    return 'Неверный формат файла ' . $zp_input_data['catalog_filename'] . ' (первая строка не имя файла)';
  }
  
  
  //если вторая строка не специальный символ >, закончить
  $buffer = explode(';', fgets($fp));
  if(trim($buffer[0]) != '>') 
  {
   return 'Неверный формат файла ' . $zp_input_data['catalog_filename'];
  }
  */
  
  
  
  // вводим все данные, предшествующие табличным, в формате >
  while(!feof($fp))
  {
    $buffer = explode(';', cp1251_to_utf8_recursive((fgets($fp)))); 
    //$buffer = explode(';', iconv("cp1251", "UTF-8", (fgets($fp)))); 
    
    // пока не встретится в начале строки >>>, выходим из цикла и переходим к вводу табличных данных
    $buffer = trim($buffer[0]);
    if(trim($buffer) == '>>>')
     break;
  	
  	if(!$buffer OR $buffer =='')
     continue;
     
    if($buffer[0] == '/' AND $buffer[1] == '/') 
    {
      $zp_input_data_commented[] = $buffer;
      continue;	
    }
    
     
    $buffer = explode('>', $buffer);
    if($buffer[1] AND $buffer[2])
      $zp_input_data[$buffer[1]] = $buffer[2];
      
      
        //echo '$zp_input_data =  ' .  $zp_input_data[$buffer[1]] .'<br>';
  }
  

  
  
  // переходим к вводу табличных данных --------------------------------------------------
  
  //запоминаем названия полей для данных
  $buffer = cp1251_to_utf8_recursive(trim(fgets($fp)));
  
  
  //echo 'названия полей для данных =  ' .  $buffer  .'<br>';
  $fields = explode(";", $buffer);
  
  // пропускаем одну строку (нумерация полей)
  $buffer = fgets($fp);
  
  
  $count = 0;
  $string_count=-1;
  //for ($i = 0; (($buffer = trim(fgets($fp))) != '>>'); $i++)
  for ($i = 0; !feof($fp); $i++)
  { 
  	$count++;   
  	
  	$buffer = fgets($fp);
  	$buffer = cp1251_to_utf8_recursive($buffer);
  	$buffer = explode(";", $buffer);
  	
  	/*
  	if(trim($buffer[1]) == '>>' OR trim($buffer[2]) == '')
  	{
      $count--;
      $i--;
      continue;	
    }
  	*/
    
    if(($zp_preprocess_data['stop_num_string'] > 0 AND ($count < $zp_preprocess_data['start_num_string'] OR $count > $zp_preprocess_data['stop_num_string']))) // если номер строки вне интервала номеров строк, определённого в задаче, то пропускаем эту строку и уменьшаем счётчик $i на единицу
    {
      $i--;
      continue;	
    }
  	
    for ($j = 0; $j < count($buffer); $j++)
     {
       $zp_catalog[$i][$fields[$j]] = trim($buffer[$j]);
     }  
     
     //foreach ($zp_catalog[$i] as $key => $value)
      //echo $key . ' =>' .  $value . '<br>';
  } 
  
  
  
  /*
  foreach($zp_catalog as $values)
  {
  	$string = '';
   foreach($values as $value)
     $string = $string . ' > ' . $value;
   
   echo 'данные для обработки =  ' .  $string  .'<br>';
     
  }
  */

  
  
  
  // количество обработанных строк может отличаться от указанного в задании (может быть меньше, если строк реально меньше)
  // поэтому корректируем реальную цифру конечного номера строки
  $zp_preprocess_data['real_stop_num_string'] = $zp_preprocess_data['start_num_string'] + ($i-1); 
    
  fclose($fp);

  
  
  
  
  return;
	
	
	
}











// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
// Прочие функции -------------------------------------------------------------------------------







// Преобразование кодировок------------------------------------

function cp1251_to_utf8_recursive(/*mixed*/ $data)
{
	if (is_array($data))
	{
		$d = array();
		foreach ($data as $k => &$v)
		{
			$d[cp1251_to_utf8_recursive($k)] = cp1251_to_utf8_recursive($v);
		}
		return $d;
	}
	if (is_string($data)) return iconv('cp1251', 'utf-8//IGNORE//TRANSLIT', $data);
	if (is_scalar($data) or is_null($data)) return $data;
	#throw warning, if the $data is resource or object:
	trigger_error('An array, scalar or null type expected, ' . gettype($data) . ' given!', E_USER_WARNING);
	return $data;
}



/*  //declared also in Z:\home\zapokupkami.com\www\includes\unicode.inc:211


function truncate_utf8($string, $len, $wordsafe = FALSE, $dots = FALSE) {
	$slen = strlen($string);
	if ($slen <= $len) {
		return $string;
	}
	if ($wordsafe) {
		$end = $len;
		while (($string[--$len] != ' ') && ($len > 0)) {};
		if ($len == 0) {
			$len = $end;
		}
	}
	if ((ord($string[$len]) < 0x80) || (ord($string[$len]) >= 0xC0)) {
		return substr($string, 0, $len) . ($dots ? ' ...' : '');
	}
	while (--$len >= 0 && ord($string[$len]) >= 0x80 && ord($string[$len]) < 0xC0) {};
	return substr($string, 0, $len) . ($dots ? ' ...' : '');
}

*/






function translit_no_spaces($string, $format = 1)
{
	// таблица для транслита
	$iso1 = array(
	"Р„"=>"Ye","Р†"=>"I","Рѓ"=>"G","С–"=>"i","в„–"=>"#","С”"=>"ye","С“"=>"g",
	"Рђ"=>"A","Р‘"=>"B","Р’"=>"V","Р“"=>"G","Р”"=>"D",
	"Р•"=>"E","РЃ"=>"Yo","Р–"=>"Zh",
	"Р—"=>"Z","Р?"=>"I","Р™"=>"J","Рљ"=>"K","Р›"=>"L",
	"Рњ"=>"M","Рќ"=>"N","Рћ"=>"O","Рџ"=>"P","Р "=>"R",
	"РЎ"=>"S","Рў"=>"T","РЈ"=>"U","Р¤"=>"F","РҐ"=>"Kh",
	"Р¦"=>"Ts","Р§"=>"Ch","РЁ"=>"Sh","Р©"=>"Sch","РЄ"=>"'",
	"Р«"=>"Y","Р¬"=>"","Р"=>"E","Р®"=>"Yu","РЇ"=>"Ya",
	"Р°"=>"a","Р±"=>"b","РІ"=>"v","Рі"=>"g","Рґ"=>"d",
	"Рµ"=>"e","С‘"=>"yo","Р¶"=>"zh",
	"Р·"=>"z","Рё"=>"i","Р№"=>"j","Рє"=>"k","Р»"=>"l",
	"Рј"=>"m","РЅ"=>"n","Рѕ"=>"o","Рї"=>"p","СЂ"=>"r",
	"СЃ"=>"s","С‚"=>"t","Сѓ"=>"u","С„"=>"f","С…"=>"kh",
	"С†"=>"ts","С‡"=>"ch","С€"=>"sh","С‰"=>"shh","СЉ"=>"",
	"С‹"=>"y","СЊ"=>"","СЌ"=>"e","СЋ"=>"yu","СЏ"=>"ya","В«"=>"","В»"=>"","вЂ”"=>"-","С—"=>"i","Р‡"=>"I"
	);

	// добавляем не вошедшие в таблицу символы
	$iso1[cp1251_to_utf8_recursive('И')] = "I";
	$iso1[cp1251_to_utf8_recursive('П')] = "P";
	$iso1[cp1251_to_utf8_recursive('Р')] = "R";
	$iso1[cp1251_to_utf8_recursive('Э')] = "E";


	if ($format == 1)
	$translit = strtr(cp1251_to_utf8_recursive($string), $iso1);
	else
	$translit = strtr($string, $iso1);
	
	// заменяем пробелы на дефисы
	
	$translit = preg_replace('/[^a-z0-9]/', '-', strtolower($translit));
	if(strpos($translit, '--') !== FALSE)
	{
		$translit = str_replace('--', '-', $translit);
	}
	
	$translit = trim($translit, '-'); // убираем - по краям
	
	/*
	if(strpos($translit, ' ') !== FALSE)
	{
		$translit = str_replace(' ', '-', $translit);
	}
	*/

	return $translit;

}







function translit($string, $format = 1)
{
	// таблица для транслита
	$iso1 = array(
	"Р„"=>"Ye","Р†"=>"I","Рѓ"=>"G","С–"=>"i","в„–"=>"#","С”"=>"ye","С“"=>"g",
	"Рђ"=>"A","Р‘"=>"B","Р’"=>"V","Р“"=>"G","Р”"=>"D",
	"Р•"=>"E","РЃ"=>"Yo","Р–"=>"Zh",
	"Р—"=>"Z","Р?"=>"I","Р™"=>"J","Рљ"=>"K","Р›"=>"L",
	"Рњ"=>"M","Рќ"=>"N","Рћ"=>"O","Рџ"=>"P","Р "=>"R",
	"РЎ"=>"S","Рў"=>"T","РЈ"=>"U","Р¤"=>"F","РҐ"=>"Kh",
	"Р¦"=>"Ts","Р§"=>"Ch","РЁ"=>"Sh","Р©"=>"Sch","РЄ"=>"'",
	"Р«"=>"Y","Р¬"=>"","Р"=>"E","Р®"=>"Yu","РЇ"=>"Ya",
	"Р°"=>"a","Р±"=>"b","РІ"=>"v","Рі"=>"g","Рґ"=>"d",
	"Рµ"=>"e","С‘"=>"yo","Р¶"=>"zh",
	"Р·"=>"z","Рё"=>"i","Р№"=>"j","Рє"=>"k","Р»"=>"l",
	"Рј"=>"m","РЅ"=>"n","Рѕ"=>"o","Рї"=>"p","СЂ"=>"r",
	"СЃ"=>"s","С‚"=>"t","Сѓ"=>"u","С„"=>"f","С…"=>"kh",
	"С†"=>"ts","С‡"=>"ch","С€"=>"sh","С‰"=>"shh","СЉ"=>"",
	"С‹"=>"y","СЊ"=>"","СЌ"=>"e","СЋ"=>"yu","СЏ"=>"ya","В«"=>"","В»"=>"","вЂ”"=>"-","С—"=>"i","Р‡"=>"I"
	);

	// добавляем не вошедшие в таблицу символы
	$iso1[cp1251_to_utf8_recursive('И')] = "I";
	$iso1[cp1251_to_utf8_recursive('П')] = "P";
	$iso1[cp1251_to_utf8_recursive('Р')] = "R";
	$iso1[cp1251_to_utf8_recursive('Э')] = "E";


	if ($format == 1)
	$translit = strtr(cp1251_to_utf8_recursive($string), $iso1);
	else
	$translit = strtr($string, $iso1);

	return $translit;

}


function utf8_to_cp1251($s)
        {
            for ($c=0;$c<strlen($s);$c++)
            {
               $i=ord($s[$c]);
               if ($i<=127) $out.=$s[$c];
                   if ($byte2){
                       $new_c2=($c1&3)*64+($i&63);
                       $new_c1=($c1>>2)&5;
                       $new_i=$new_c1*256+$new_c2;
                   if ($new_i==1025){
                       $out_i=168;
                   } else {
                       if ($new_i==1105){
                           $out_i=184;
                       } else {
                           $out_i=$new_i-848;
                       }
                   }
                   $out.=chr($out_i);
                   $byte2=false;
                   }
               if (($i>>5)==6) {
                   $c1=$i;
                   $byte2=true;
               }
            }
            return $out;
        }

 
function utf8_win ($s){
//## перекодировка unicode UTF-8 -> win1251
	$out="";
	$c1="";
	$byte2=false;
	for ($c=0;$c<strlen($s);$c++){
		$i=ord($s[$c]);
		if ($i<=127) $out.=$s[$c];
		if ($byte2){
			$new_c2=($c1&3)*64+($i&63);
			$new_c1=($c1>>2)&5;
			$new_i=$new_c1*256+$new_c2;
			if ($new_i==1025){
				$out_i=168;
			}else{
				if ($new_i==1105){
					$out_i=184;
				}else {
					$out_i=$new_i-848;
				}
			}
			$out.=chr($out_i);
			$byte2=false;
		}
		if (($i>>5)==6) {
			$c1=$i;
			$byte2=true;
		}
	}
	return $out;
}
        


function zp_clear_cache_drupal()
{
	drupal_clear_css_cache();
 
	$core = array('cache', 'cache_content', 'cache_filter', 'cache_menu', 'cache_page', 'cache_views');
	$alltables = array_merge($core, module_invoke_all('devel_caches'));
	foreach ($alltables as $table) 
	{
  		cache_clear_all('*', $table, true);
	}
	
	//print(t('Cache cleared.'));
}