<?php  	           


// Определить тип и версию браузера пользователя
function zp_functions_browser_info(){

	$agent = $_SERVER['HTTP_USER_AGENT'];
	//echo '$HTTP_USER_AGENT = ' . $agent . '<br>';	
	$browsers = array(  
        'Opera' => 'Opera',  
        'Mozilla Firefox' => '(Firebird)|(Firefox)',
        'Galeon' => 'Galeon',
        'Mozilla'=> 'Gecko',
        'MyIE'=>'MyIE',
        'Lynx' => 'Lynx',  
        'Netscape' => '(Mozilla/4\.75)|(Netscape6)|(Mozilla/4\.08)|(Mozilla/4\.5)|(Mozilla/4\.6)|(Mozilla/4\.79)',
        'Konqueror' => 'Konqueror',
        'SearchBot' => '(nuhk)|(Googlebot)|(Yammybot)|(Openbot)|(Slurp/cat)|(msnbot)|(ia_archiver)',

        'IE' => '(MSIE [0-9]\.[0-9]+)',
        //'IE8' => '(MSIE 8\.[0-9]+)',
        //'IE4' => '(MSIE 4\.[0-9]+)',
    );  
   
    foreach($browsers as $browser=>$pattern)  
    {  
        if (eregi($pattern, $agent))
        {
            if($browser == 'IE') 
            	$ver = substr($agent,strpos($agent,"MSIE")+5,3);	
            else if ($browser == 'Opera')
            	$ver = substr($agent,strpos($agent,"Opera")+6,4);
            else if ($browser == 'Netscape')
            	$ver = substr($agent,strpos($agent,"Mozilla")+8,3);
            else if ($browser == 'Mozilla Firefox')
            	$ver = substr($agent,strpos($agent,"Firefox")+8,3);
            
        	return array($browser, $ver[0]);  
        }
    }  
    return null;
    
    
	/*
	
	// Искать сигнатуру Internet Explorer
	if(ereg('MSIE ([0-9].[0-9]{1,2})', $agent, $version))
	{
		$browse_type = "IE";
		$browse_version = $version[1];
	}
		// Искать сигнатуру Opera
	else if(ereg( 'Opera ([0-9].[0-9]{1,2})'. $agent, $version))
	{
		$browse_type = "Opera";
		$browse_version = $version[1];
	}
		// Искать сигнатуру Netscape. Проверка браузера Netscape
		// *должна* выполняться после проверки Internet Explorer и Opera,
		// поскольку все эти браузеры любят сообщать имя
		// Mozilla вместе с настоящим именем.
	else if(ereg( 'Mozilla/([0-9].[0-9]{1,2})'. $agent, $version))
	{
		$browse_type = "Netscape";
		$browse_version = $version[1];
	}
	return array ($browse_type, $browse_version);
	
	*/
	
}






// выведем любимые магазины клиента и расстояния от них до клиента
function zp_functions_distances_to_client_loveshops($user_id){

	// найдём нид ноды скрытых данных клиента
	$user_nid = db_result(db_query("SELECT nid from {node} WHERE title  = '%s'", 'u' . $user_id . '-hi'));
	
	// найдём координаты клиента
	$u_location = db_result(db_query("SELECT lid from {location_instance} WHERE nid  = %d", $user_nid));
	$u_location = db_query("SELECT latitude, longitude from {location} WHERE lid  = %d", $u_location);
	$u_location = db_fetch_array($u_location);
	

	// найдём любимые магазины клиента и их координаты
	$loveplaces = db_query("SELECT r_id, r_text from {node_field_multireference_data} WHERE nid  = %d", $user_nid);
	while($loveplace = db_fetch_array($loveplaces))
	{
		// найдём тип места (координаты будем показывать только для магазинов)
		$place_zp_art = db_result(db_query("SELECT field_zp_art_place_value from {content_field_zp_art_place} WHERE nid = %d", $loveplace['r_id']));		

		if(strlen($place_zp_art) == 8) // если очередное доступное местоположение - магазин (длина артикула - 8 символов)
		{
			
			// найдём координаты очередного магазина
			$s_location = db_result(db_query("SELECT lid from {location_instance} WHERE nid  = %d", $loveplace['r_id']));
			$s_location = db_query("SELECT latitude, longitude from {location} WHERE lid  = %d", $s_location);
			$s_location = db_fetch_array($s_location);
			
			// найдём расстояние до клиента от этого магазина
			$shop['distance'] = zp_functions_mapdistance($s_location['latitude'], $s_location['longitude'], $u_location['latitude'], $u_location['longitude']);

			$shop['name'] = $loveplace['r_text'];
			$shop['address'] = db_result(db_query("SELECT field_place_address_value from {content_field_place_address} WHERE nid  = %d", $loveplace['r_id']));
			
			$places[] = $shop;
		}
		else 
		{	
			// вычислим магазина, в котороы находится указанный отдел
			$parent_shop_zp_art = substr($place_zp_art, 0, 8);
			$parent_shop_nid = db_result(db_query("SELECT nid from {content_field_zp_art_place} WHERE field_zp_art_place_value  = '%s'", $parent_shop_zp_art));
			$parent_shop_name = db_result(db_query("SELECT title from {node} WHERE nid  = %d", $parent_shop_nid));
			$parent_shop_address = db_result(db_query("SELECT field_place_address_value from {content_field_place_address} WHERE nid  = %d", $parent_shop_nid));

			$s_location = db_result(db_query("SELECT lid from {location_instance} WHERE nid  = %d", $parent_shop_nid));
			$s_location = db_query("SELECT latitude, longitude from {location} WHERE lid  = %d", $s_location);
			$s_location = db_fetch_array($s_location);
			
			// найдём расстояние до клиента от этого магазина
			$shop['distance'] = zp_functions_mapdistance($s_location['latitude'], $s_location['longitude'], $u_location['latitude'], $u_location['longitude']);
			
			
			$place['name'] = $loveplace['r_text'];
			$place['address'] = $parent_shop_name . '. ' . db_result(db_query("SELECT field_place_address_value from {content_field_place_address} WHERE nid  = %d", $loveplace['r_id'])) . '. ' . $parent_shop_address;
			
			$places[] = $place;
			
		}
		
		
	} // end of while($loveplace = db_fetch_array($loveplaces))
	
	return $places;
	
}






// получим координаты магазина или клиента
function zp_functions_get_location($target_type, $target_id){

	if($target_type == 'user')
     	{

   			// найдём нид ноды скрытых данных текущего клиента
			$target_nid = db_result(db_query("SELECT nid from {node} WHERE title  = '%s'", 'u' . $target_id . '-hi'));
		
			$location = db_result(db_query("SELECT lid from {location_instance} WHERE nid  = %d", $target_nid));
			$location = db_query("SELECT latitude, longitude from {location} WHERE lid  = %d", $location);
			$location = db_fetch_array($location);

     	}
     	else if($target_type == 'shop')
     	{
   			$target_nid = db_result(db_query("SELECT nid from {content_field_zp_art_place} WHERE field_zp_art_place_value  = '%s'", $target_id));
     			
   			$location = db_result(db_query("SELECT lid from {location_instance} WHERE nid  = %d", $target_nid));
			$location = db_query("SELECT latitude, longitude from {location} WHERE lid  = %d", $location);
			$location = db_fetch_array($location);

     	}
	
	return $location;
	
} // end of zp_functions_get_location($target_type = 'user', $target_id){






// получим карту расположения магазина или клиента
function zp_functions_get_location_map($target_type = 'user', $target_id, $location = false, $map_type = 'mail', $map_num = 1){


	// сформируем url файла с картой
    
 	if($target_type == 'user')
   	{
		// for Denver
    	// $zp_server_directory = 'D:\\WebServers\\home\\zapokupkami-x.com\\www\\zpmaps\\users\\';	

    	// for remote server
   		//$zp_server_directory = $_SERVER['DOCUMENT_ROOT'] . base_path() . 'zpmaps/users/';	
   		$zp_server_directory = 'zpmaps/users/';	
   		//$map_file = $zp_server_directory . 'u' . $args->uid . '_map' . '.gif';
   	}
   	else // иначе это магазин
   	{
   		//$zp_server_directory = $_SERVER['DOCUMENT_ROOT'] . base_path() . 'zpmaps/shops/';	
   		$zp_server_directory = 'zpmaps/shops/';	
   		
   		//$map_file = $zp_server_directory . $node->field_zp_art_place[0]['value'] . '_map' . '.gif';
   		//$map_file = $zp_server_directory . $target_id . '_map' . '.gif'; // $target_id = zp id магазина
   	}
   		
   		
   	$map_file = $zp_server_directory;
   		
   	if($target_type == 'user')
   		$map_file .= 'u';  // а для магазина букву не ставим, так как ид включает букву z в начале
   			
   		
   	$map_file .= $target_id . '-map'; // $target_id = uid клиента или zp id магазина
   		
   	if($map_type == 'wap')
   		$map_file .= '-wap'; // для карты для использования в wap, меньшего размера
   		
   	if($map_num > 1)
   		$map_file .= '-' . $map_num; // если имеется несколько карт с разными местами расположениями (для одного клиента, например), добавляем номер карты, если это не 1... для первой карты номера не добавляем, вторая будет -2
   				
   	$map_file .= '.gif';
  			
   			
	
     // если карта ещё не была сформирована и сохранена на сервере, получаем её от Гугля
     if(!file_exists($_SERVER['DOCUMENT_ROOT'] . base_path() . $map_file))
     //if(1)
     {
     					
     	
     	if($target_type == 'user')
     	{
     	
     		if(!$location) // если в параметрах не были переданы координаты клиента, получаем их из базы
     		{
     		
     			// найдём нид ноды скрытых данных текущего клиента
				$target_nid = db_result(db_query("SELECT nid from {node} WHERE title  = '%s'", 'u' . $target_id . '-hi'));
		
				$location = db_result(db_query("SELECT lid from {location_instance} WHERE nid  = %d", $target_nid));
  				$location = db_query("SELECT latitude, longitude from {location} WHERE lid  = %d", $location);
  				$location = db_fetch_array($location);
     		}
     		
     		$marker_type = 'blueu'; // маркер с буквой U
     	}
     	else 
     	{
     		if(!$location) // если в параметрах не были переданы координаты магазина, получаем их из базы
     		{
     			$target_nid = db_result(db_query("SELECT nid from {content_field_zp_art_place} WHERE field_zp_art_place_value  = '%s'", $target_id));
     			
     			$location = db_result(db_query("SELECT lid from {location_instance} WHERE nid  = %d", $target_nid));
  				$location = db_query("SELECT latitude, longitude from {location} WHERE lid  = %d", $location);
  				$location = db_fetch_array($location);
     		}
     		
     		$marker_type = 'blues'; // маркер с буквой S
     	}
     		
     		
  				
    	// статическая картинка карты, получаемая с гугля
   
    	$static_map_url = 'http://maps.google.com/staticmap?center=';
    	$static_map_url .= $location['latitude'].','.$location['longitude'];
   		//$static_map_url .= '&zoom=16&size=334x300&maptype=mobile';
   		
   		
   		
   		if($map_type == 'wap')
   		{
   			$static_map_url .= '&zoom=15&maptype=mobile'; // чуть отдалаяем, так как почти ничего не попадает в карту
   			$static_map_url .= '&size=120x120'; // для вапа делаем картинку поменьше
   		}
   		else
   		{
   			$static_map_url .= '&zoom=16&maptype=mobile';
   			$static_map_url .= '&size=334x300';
   		}
   		
    	$static_map_url .= '&markers='.$location['latitude'].','.$location['longitude'].','.$marker_type;
    	$static_map_url .= '&key='. variable_get('googlemap_api_key', ''); //keys_api_get_key('gmap', $_SERVER['HTTP_HOST']);
    	

    
    	
    
    	// скопируем картинку с гугля в локальный файл (локальный путь файла на только что был сформирован)
    
    	// var. 1 ----> Working on Denver
    	//file_put_contents($map_file, file_get_contents($static_map_url));
     					
    	// var. 2
    	//copy($map_file, file_get_contents($static_map_url));
     					
    	// var. 3
    	//$destination=fopen($map_file,"w");
		//$source=fopen($static_map_url,"r");
		//while ($a=fread($source,1024)) 
		//fwrite($destination,$a);
		//fclose($source);
		//fclose($destination);
     					

    
     	// по причине ограничений провайдера, все вышеперечисленные методы не работают на удалённом сервере (первый из них точно работает локально на денвере)				
    	// var. 4 ----> CURL, working on remote
    	$out = fopen($map_file, 'wb');
    	if ($out == FALSE)
    	{
    		echo "Error opening destination file";
    	}
    	else 
    	{
    		$ch = curl_init();
         
    		curl_setopt($ch, CURLOPT_FILE, $out);
    		curl_setopt($ch, CURLOPT_HEADER, 0);
    		curl_setopt($ch, CURLOPT_URL, $static_map_url);
             
		    if(curl_exec($ch) === false)
    		{
    			echo "<br>Error is : ".curl_error ($ch);
    		}
    		
   
    		curl_close($ch); 
    						
    	} // end of else
   
    } // end of if(!file_exists($map_file))
     			

	return $map_file;
}









// формирование рекламного блока на основе модуля ad
// может возвращать единичный рекламный блок, блок со сменной рекламой (стандартная возможность ротации блока ad) или динамически сменяющиеся рекламные блоки с заданным эффектом

function zp_functions_ad_block($amount = NULL, $ad_type = 'ad', $source_type = 'ad_group_title', $source = NULL, $effect = 'scrollDown', $effect_delay = 2000, $bounce = 0, $slideshow_block_id){
	
	switch($source_type)	
	{
		
		case 'node_titles':
			
			$old_source = $source;
			foreach($old_source as $key => $node_title)
			{
				if($node_nid = db_result(db_query("SELECT nid from {node_revisions} WHERE title = '%s'", $node_title)))
					$source[$key] = $node_nid;
					
			}
			
		 
		case 'node_nids':

			$ad_block = NULL;
			
			if($ad_type == 'slide_show' AND ($amount > 1 OR $amount == NULL)) // если нужно показать слайд-шоу и количество не задано или больше одного, формируем содержимое для слайдшоу из отдельных рекламных блоков
			{
				
				foreach($source as $key => $node_nid)
				{
					if($key+1 > $amount)
						break;
					$ad_block .= ad(NULL, 1, array('nids' => $node_nid));
				}
				
				if($ad_block)
				{
					$ad_block = '<div id="slide_ad_block_' . $slideshow_block_id . '">' . $ad_block . '</div>';	
			
					drupal_add_js('sites/all/modules/_Jstools/jquery_plugin/jquery.cycle.all.min.js');
					drupal_add_js('sites/all/modules/_Jstools/jquery_plugin/jquery.easing.js');
					drupal_add_js('sites/all/modules/_Jstools/jquery_plugin/jquery.easing.compatibility.js');
					
					drupal_add_js(
						"$(document).ready(
      									function() 
      									{
        									//$('.jquery_slideshow').css({height:'200px'});
        									//$('.jquery_slideshow').css({width:'200px'});
        									
        									$('#slide_ad_block_" . $slideshow_block_id . "').cycle
        														({
          															//fx: 'toss',
          															//fx: 'fade',
          															//fx: 'blindX',
          															//fx: 'uncover',
          															//fx: 'scrollDown', 

          															fx: '" . $effect . "'," 
																	
																	.($bounce ? // если нужен отскок, добавляет этот кусок кода
          															
    	  															" 
          															speedIn:  2000, 
    	  															speedOut: 500, 
    	  															easeIn:  'bounceout', 
    	  															easeOut: 'backin', 
    	  															//delay:   -" . $effect_delay . " //-2000
    	  															" 
          															: // иначе этот
          															
          															" 
          															//speed: " . $effect_delay . ", //2000,
          															" ). // продолжается обычный код
          															
          															"
          															timeout: " . $effect_delay ."//1000
          															
        														});

      									});", 
						'inline');
					
				}
			
			}
			else 
			if($ad_type == 'ad' OR ($ad_type == 'slide_show' AND $amount == 1)) // если нужно показать рекламный блок или нужно показать слайд-шоу, но количество равно одному, значит игнорируем требование показать слайдшоу и показываем простой рекламный блок
			{

				// сформируем список нидов для передачи в функцию модуля ad
				foreach($source as $key => $nid)
				{
					if($key == 0)
						$nids = $nid;
					else
						$nids .= ', ' . $nid;
				}
				
				if($nids)
				{
					// если список не пустой, формируем рекламный блок
					if($ad_block = ad(NULL, $amount, array('nids' => $nids))) // игнорируем группу, указываем ноды + количество реклам, которые будут показаны олновременно
					{
						$ad_block = '<div id="ad_block">' . $ad_block . '</div>';
					}
					
				}

			}
			
			break;
			
			
			
			
		
		case 'ad_group_name': // в нулевом элементе массива $source помещено название терма рекламной группы (созданной с помощью модуля ad)
			// найдём тид и передадим управление следующему варианту этого switch($source_type)
			// тут не нужен break;
			
			$source[0] = db_result(db_query("SELECT tid from {term_data} WHERE name = '%s'", $source[0]));
			
			
			
			
		
		case 'ad_group_tid': // в нулевом элементе массива $source помещен номер tid рекламной группы (созданной с помощью модуля ad)
			
			$ad_block = NULL;
			
			if($ad_type == 'slide_show' AND ($amount > 1 OR $amount == NULL)) // если нужно показать слайд-шоу и количество не задано или больше одного, формируем содержимое для слайдшоу из отдельных рекламных блоков
			{
				//получим все ноды с рекламой из этой группы
				$nodes = db_query("SELECT nid from {term_node} WHERE tid = %d", $source[0]);
			
				if($node = db_fetch_object($nodes))
				{
					// если есть хоть одна нода, открываем группу
					$ad_block .= '<div id="slide_ad_block_' . $slideshow_block_id . '">';
				
					// и помещаем в неё первый элемент
					$ad_block .= ad(NULL, 1, array('nids' => $node->nid));
					$ad_count = 1;
				}

				while($ad_count < $amount AND $node = db_fetch_object($nodes))
				{
					// если есть ещё ноды, добавляем их как остальные элементы группы
					$ad_block .= ad(NULL, 1, array('nids' => $node->nid));
					$ad_count++;
				}

				if($ad_block) //закрываем группу, если она была открыта
				{
					$ad_block .= '</div>';
					
					drupal_add_js('sites/all/modules/_Jstools/jquery_plugin/jquery.cycle.all.min.js');
					drupal_add_js('sites/all/modules/_Jstools/jquery_plugin/jquery.easing.js');
					drupal_add_js('sites/all/modules/_Jstools/jquery_plugin/jquery.easing.compatibility.js');
					
					drupal_add_js(
						"$(document).ready(
      									function() 
      									{
        									//$('.jquery_slideshow').css({height:'200px'});
        									//$('.jquery_slideshow').css({width:'200px'});
        									
        									$('#slide_ad_block_" . $slideshow_block_id . "').cycle
        														({
          															//fx: 'toss',
          															//fx: 'fade',
          															//fx: 'blindX',
          															//fx: 'uncover',
          															//fx: 'scrollDown', 

          															fx: '" . $effect . "'," 
																	
																	.($bounce ? // если нужен отскок, добавляет этот кусок кода
          															
    	  															" 
          															speedIn:  2000, 
    	  															speedOut: 500, 
    	  															easeIn:  'bounceout', 
    	  															easeOut: 'backin', 
    	  															//delay:   -" . $effect_delay . " //-2000
    	  															" 
          															: // иначе этот
          															
          															" 
          															//speed: " . $effect_delay . ", //2000,
          															" ). // продолжается обычный код
          															
          															"
          															timeout: " . $effect_delay ."//1000
          															
        														});

      									});", 
						'inline');
					
				}
			
			}
			else 
			if($ad_type == 'ad' OR ($ad_type == 'slide_show' AND $amount == 1)) // если нужно показать рекламный блок или нужно показать слайд-шоу, но количество равно одному, значит игнорируем требование показать слайдшоу и показываем простой рекламный блок
			{

				// открываем группу
				$ad_block .= '<div id="ad_block">';
				
				// и помещаем в неё рекламный блок
				$ad_block .= ad($source[0], $amount); // вся группа + количество реклам, которые будут показаны олновременно

				//закрываем группу
				$ad_block .= '</div>';

			}
			
				
			
			break;
			
			
		default:
			
			break;
			
	} // end of switch($source_type)
	
	
	return $ad_block;
	
	
}










// вспомогательная функция для отладки
function zp_functions_show($obj){

	echo '<PRE>';
	print_r($obj);
	echo '</PRE>';
}



// функция формирования содержания для каталога статей и описаний (товаров и услуг, производителей и брендов, магазинов и заведений)
function zp_functions_get_issues_content($view_name = 'zp_issues_all', $current_tid = NULL, $parent_tid = NULL, $vid = NULL, $step = 0){

	$current_tid_name = db_result(db_query("SELECT name FROM {term_data} WHERE tid  = %d", $current_tid));
	
	// если терм имеет прямую ссылку на ноду, считаем, что этот терм не имеет детей, т.е. подразделов
	// и возвращаем вьюс с родительским термом в качестве аргумента,
	// обрамлённый филдсетом
	
	
	if($current_nid = db_result(db_query("SELECT nid FROM {term_node} WHERE tid  = %d", $current_tid)))
	{
		if($step > 1  AND !$_GET['page']) // показывает закрытыми все филдсеты, кроме корневых, если не был использован переход на страницу во вьюсах (листание страниц со списком)
		//if(0)
			$out = '<fieldset class="collapsible collapsed"><legend><a href="#">' . $current_tid_name . '</a></legend>';
		else 
			$out = '<fieldset class="collapsible"><legend><a href="#">' . $current_tid_name . '</a></legend>';

		cache_clear_all('*', 'cache_views', true);
			
		$view = views_get_view($view_name);
		
		
		if($view)
		{
			//zp_functions_show($view);
		
    		$view->filter[1] = array (
     			//'vid' => 3,
    			'tablename' => '',
      			'field' => 'term_node_7.tid',
      			'value' => array (
  						0 => $current_tid, 
						),
      			'operator' => 'AND',
      			'options' => '',
      			'position' => 1,
      			'id' => 'term_node_7.tid',
      			
    			);	
		
			//$limit = 0;
			//$out .= views_build_view('embed', $view, array(), FALSE, $limit);
			$out .= views_build_view('embed', $view, array(), $view->use_pager, $view->nodes_per_page);
		}

		
		$out .= '</fieldset>';
		
		
		return $out;
	}
	
	// иначе считаем, что это раздел
	// открываем филдсет с заголовком в виде названия текущего терма
	// получаем всех потомков, передаём каждого в эту же функцию рекурсивно
	// и закрываем филдсет
	
	$out = NULL;

	$childrens = db_query("SELECT tid FROM {term_hierarchy} WHERE parent  = %d", $current_tid);
	
	while($children = db_fetch_object($childrens))
		$out .= zp_functions_get_issues_content($view_name, $children->tid, $current_tid, $vid, $step + 1);

	
	if($out AND $step)
	{
		
		if($step > 1 AND !$_GET['page']) // показывает закрытыми все филдсеты, кроме корневых
		//if(0)
			$out = '<fieldset class="collapsible collapsed"><legend><a href="#">' . $current_tid_name . '</a></legend>' . $out . '</fieldset>'; 
		else 
			$out = '<fieldset class="collapsible"><legend><a href="#">' . $current_tid_name . '</a></legend>' . $out . '</fieldset>'; 
	}
		
	return $out;
	
}

















// группируем магазины по районам для second menu города
function zp_functions_shops_by_rajons($items)
{
	foreach($items as $type_tid => $type)
    {
    	if(is_array($type['children']))
    	{
    		foreach ($type['children'] as $stid => $shop)
    		{
    			
    			$rajon_tid = db_result(db_query("SELECT parent from {term_hierarchy} WHERE tid = %d", $stid));
    	 				
    			if(!$rajons[$rajon_tid]['data'])
    			{
    				$rname = db_result(db_query("SELECT name from {term_data} WHERE tid = %d", $rajon_tid));
    				$rnid = db_result(db_query("SELECT nid from {term_node} WHERE tid = %d", $rajon_tid));
    				$rajons[$rajon_tid]['data'] = l($rname, 'node/' . $rnid);
    			}
    	 				
    			$rajons[$rajon_tid]['children'][$stid]['data'] = $shop['data'];
    			$rajons[$rajon_tid]['children'][$stid]['children'] = array();

    		}
    	 			 	
    		//unset($items[$type_tid]['children']);
    	 	$items[$type_tid]['children'] = $rajons;
    	}
    	else 
    		unset($items[$type_tid]); // убираем пункт меню типа магазина, если в этом типе нет магазинов	
    }
	
	return $items;
}






function zp_functions_shop_info($argument_shop_tid, $user_id)
{
	
    //echo 'xxx'; 
// зададим переменные для логотипа, адреса и прочих данных магазина
// будем сохранять в сессии данные (вернее, данные по файлам логотипов, по адресу маназина и т.д.) для всех просмотренных магазинов, в название данных в сессии будем вставлять тид магазина, 
// таким образом, не придётся каждый раз заново рассчитывать данные по магазину, если они уже были однажды определёны

	if(!($cur_shop_info = $_SESSION[$argument_shop_tid . '_shop_info'] AND ($user_id > 0 AND $cur_shop_info['shop_min_sum'] AND $cur_shop_info['shop_min_sum'] != 0))) // если данные ещё не были рассчитаны, рассчитаем их и зададим соответствующие переменные сессии и для файла шаблона
    {
         	
          	// выясним ноду магазина по её тиду
      	    $argument_shop_nid = db_result(db_query("SELECT nid from {term_node} WHERE tid = %d", $argument_shop_tid));
      	    
      	    //определим внутренний ZP артикул магазина
      	    $cur_shop_info['shop_id'] = db_result(db_query("SELECT field_zp_art_place_value from {content_field_zp_art_place} WHERE nid = %d", $argument_shop_nid));
      	    
      	    //определим название магазина
      	    $cur_shop_info['shop_name'] = db_result(db_query("SELECT title from {node} WHERE nid = %d", $argument_shop_nid));
      	    
            $cur_shop_info['shop_nid'] = $argument_shop_nid;
            $cur_shop_info['shop_tid'] = $argument_shop_tid;
            
            //$data = zp_functions_shop_min_sum($argument_shop_nid, $user_id); // потом надо перенести эту функцию из phptemplate сюда, но чтобы и все остальные модули вызывали именно отсюда функцию, а не из phptemplate
            $data = zp_shop_min_sum($argument_shop_nid, $user_id);
            
            $cur_shop_info['shop_min_sum'] = $data['final_min_sum'];
            
            //echo 'argument_shop_nid = ' . $argument_shop_nid . ', user_id = ' . $user_id;
            //echo 'xxx2 = ' . $cur_shop_info['shop_min_sum']; 
            
          	$cur_shop_info['shop_address'] = db_result(db_query("SELECT field_place_address_value from {content_field_place_address} WHERE nid = %d", $argument_shop_nid));
          	
            $_SESSION[$argument_shop_tid . '_shop_info'] = $cur_shop_info;
	}         
	
	return $cur_shop_info;	
}











//  функция для определения минимальной суммы покупки в магазине, в котором продаётся товар, nid которого передаётся как аргумент
// возвращается минимальная сумма покупки для этого магазина для текущего клиента
function zp_functions_shop_min_sum($c_nid, $uid)
{
	
	 //drupal_set_message('9999999999 c_nid = ' . $c_nid . 'uid = ' . $uid, 'error');
	 //echo '-----c_tid = ' . $c_nid . '<br>';
	//global $user;
	
	    	//найти тид продукта, продающегося в этом магазине
            //$c_tid = db_result(db_query("SELECT tid FROM {term_node} WHERE nid = %d", $c_nid));
            
            $c_tids = taxonomy_node_get_terms_by_vocabulary($c_nid, 1); 
      		foreach($c_tids as $c_tid)
          		$c_tid = $c_tid->tid;
	    	
            
            $term_name = db_result(db_query("SELECT name FROM {term_data} WHERE tid = %d", $c_tid));
            //echo '-----c_tid = ' . $c_tid . ', term_data = ' . $term_name . ', c_nid = ' . $c_nid . '<br>';  
            
 	   		// задаём массив тидов продукта и первым элементом делаем терм самого продукта
        	$linage_c_tids = array($c_tid);
        
        	$count = 1;
        	while(($c_tid = db_result(db_query("SELECT parent from {term_hierarchy} WHERE tid  = '%s'", $c_tid))) != 0)
	         {
    	       $linage_c_tids[] = $c_tid;
        	   $count++;
        	   
        	   //echo '2----c_tid = ' . $c_tid . '<br>'; 
         	 } 
        
	        // для примерного понимания... 
    	    //$item_shop_tid = $linage_tids[$count-4]; // вариант город-район-магазин. 
        	//$item_rajon_tid = $linage_tids[$count-3]; // Третьим элементом в этом варианте становится район
	        //$item_city_tid = $linage_tids[$count-2]; // при любом варианте город будет вторым элементом после страны
    	    //$item_country_tid = $linage_tids[$count-1];

    	   // print '<PRE>';
    	   // print_r($linage_c_tids);
    	   // print '</PRE>';

    	    
			  
// найдём минимальную стоимость покупки для магазина, товары из которого находятся в корзине

// переопределяем минимальную сумму покупки в зависимости от настроек системы:
// мин.сумма покупки по умолчанию указывается на ноде настроек по умолчанию

// но каждая страна, город, район, магазин и клиент имеет свой коэффициент 
// - все кофээфициенты перемножаются и умножаются на значение минимальной суммы
// в итоге получаем значение минимальной суммы покупки в конкретном магазине
    
// коэффициент определяется при определении текущего магазина корзины 
// и заносится в массив под ключом 'min_sum'    
    
 			// найдём минимальную сумму покупки по умолчанию
 			// найдём номер ноды с настройками магазина по умолчанию
			$zp_default_set_nid = db_result(db_query("SELECT nid from {node} WHERE type  = '%s'", 'zp_default_set'));
			
			
			$min_sum_default = db_result(db_query("SELECT field_cart_min_sum_value from {content_type_zp_default_set} WHERE nid  = %d", $zp_default_set_nid));
			
			$final_min_sum = $min_sum_default; // зададим сначала минимальную стоимость покупки равную стоимости по умолчанию
			
			//echo 'final_min_sum = ' . $final_min_sum . ', count = ' . $count . '<br>';
			
			//а затем перемножим её на коэффициенты страны, города, района и магазина
		    
			//переребираем страну, город, район, магазин (их тиды сохранены у нас в массиве $linage_c_tids[])
			//выясняем для каждого коэффициент минимальной стоимости и перемножаем между собой
			for($i = 1; $i <= 4; $i++)
 			 {
 			 	// найдём нид очередного элемента (страна, город, район или магазин)
 				$next_nid = db_result(db_query("SELECT nid from {term_node} WHERE tid  = '%s'", $linage_c_tids[$count - $i]));
 				
 				//echo '--next_nid = ' . $next_nid . ', i = ' . $i . '<br>';
 				
 				// найдём его коэффициент мин. суммы корзины
 				$next_min_sum_f = db_result(db_query("SELECT field_cart_min_sum_f_value from {content_field_cart_min_sum_f} WHERE nid  = %d", $next_nid));
 				
 				//echo '--next_min_sum_f = ' . $next_min_sum_f . '<br>';
 				
 			 	//умножим найденный коэффициент на общий коэффициент
 				$final_min_sum  *= $next_min_sum_f; 
 				
 				
 			 }
 			 
 			 //echo '--final_min_sum = ' . $final_min_sum . '<br>';

			// домножим получившуюся сумму на ещё один коэффициент - конкретного клиента
			
			
			
			// найдём нид ноды скрытых данных текущего клиента
			$u_hi_nid = db_result(db_query("SELECT nid from {node} WHERE title  = '%s'", 'u' . $uid . '-hi'));
			
// временно!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			//$u_hi_nid = 61;
			
			//echo '-----u_hi_nid= ' . $u_hi_nid . '<br>';
			
			// получим значение коэффициента минимальной суммы покупки для текущего клиента из этой ноды
			$user_min_sum_f = db_result(db_query("SELECT field_cart_min_sum_f_value from {content_field_cart_min_sum_f} WHERE nid  = %d", $u_hi_nid));
			
			
			//echo '-----user_min_sum_f= ' . $user_min_sum_f . '<br>';
			
			//и теперь домножим получившуюся сумму на полученный коэффициент конкретного клиента 
			$final_min_sum *= $user_min_sum_f;
			
			
			
			
			// теперь переменная $final_min_sum содержит минимальную сумму покупки для этого магазина
			//drupal_set_message("Минимальная сумма покупки для этого магазина и клиента final_min_sum = $final_min_sum", 'error');  
			  
			 //echo 'final_min_sum = ' . $final_min_sum . '<br>';
			  
// окончание определения минимальной стоимости покупки для этого магазина	    	    
    	    
	
//$data = array();
$data['final_min_sum'] = round($final_min_sum, 2);   
$data['linage_c_tids'] = $linage_c_tids;
$data['count'] = $count;

	
return $data;


//return $final_min_sum;

	
	
}


















// генерация нового заказа с зарезервированным номером, указанным аргументом $r_order_id

function zp_function_order_new_reserved_id($uid = 0, $order, $r_order_id, $state = 'in_checkout') {
  
  if ($uid > 0) {
    $user = user_load(array('uid' => $uid));
    $email = $user->mail;
  }

  $order->order_id = $r_order_id;
  
  $order->uid = $uid;
  $order->order_status = uc_order_state_default($state);
  $order->primary_email = $email;

  
  if(!db_result(db_query("SELECT order_id from {uc_orders} WHERE order_id = %d", $order->order_id)))
  {
  	db_query("INSERT INTO {uc_orders} (order_id, uid, order_status, order_total, "
          ."primary_email, delivery_first_name, delivery_last_name, delivery_phone, "
          ."delivery_company, delivery_street1, delivery_street2, delivery_city, "
          ."delivery_zone, delivery_postal_code, delivery_country, billing_first_name, "
          ."billing_last_name, billing_phone, billing_company, billing_street1, "
          ."billing_street2, billing_city, billing_zone, billing_postal_code, "
          ."billing_country, payment_method, data, created, modified) VALUES "
          ."(%d, %d, '%s', 0, '%s', '', '', '', '', '', '', '', 0, '', 0, '', "
          ."'', '', '', '', '', '', 0, 0, 0, '', '', %d, %d)", $order->order_id,
           $uid, $order->order_status, $email, time(), time());

  	module_invoke_all('order', 'new', $order, NULL);
  }

  return $order;
}








function zp_functions_product_d_factor($nid, $user_id){
		
		// разные продукты даже в одном магазине могут иметь разные коэффициенты доставки
		// т.к. могут находиться в разных отделах с разными коэффициентами доставик

	
 
        // вычисляем коэффициент доставки
        // равный перемноженным коэффициентам страна*город*район*магазин*отдел(ы)*клиент-общий*клиент-по-всей-иерархии-от-отдела-до-страны
        // выясним всю последовательность до страны, затем тиды страны, города, района и магазина
  

        //$node_tid = db_result(db_query("SELECT tid from {term_node} WHERE nid = %d", $node->nid)); 
        $node_tids = taxonomy_node_get_terms_by_vocabulary($nid, 1); 
      	
        // определим терм ноды продукта
        foreach($node_tids as $node_tid)
          $node_tid = $node_tid->tid;
      	
      	// определим родителя терма данной ноды. Это будет как раз терм отдела, в котором продаётся этот продукт
        $node_tid = db_result(db_query("SELECT parent from {term_hierarchy} WHERE tid  = '%s'", $node_tid));
        $parent_otdel_nid = db_result(db_query("SELECT nid from {term_node} WHERE tid = %d", $node_tid)); 

		
    	//$d_factor_otdel = zp_functions_d_factor_otdel($node_tid, $parent_otdel_nid, $user_id);
		//return $d_factor_otdel
		return zp_functions_d_factor_otdel($node_tid, $parent_otdel_nid, $user_id);

}








function zp_functions_get_zp_default_set($constants_to_search = array())
{

 		// загружаем из базы массив с переменными по умолчанию
        $zp_default_set = $_SESSION['zp_default_set'];
        
        // если массив пока не определён или в нём не определён параметр nid (номер ноды с параметрами по умолчанию),
        // находим параметр nid и добавляем его в массив
        if(!$zp_default_set OR !$zp_default_set['nid'])
          $zp_default_set['nid'] = db_result(db_query("SELECT nid from {node} WHERE type = '%s'", 'zp_default_set'));
        
        // делим значение процента доставки на 100 и получаем коэффициент
        // инициализируем данную переменную, только если на неё был запрос из вызываемой функции (массив с перечнем запрашиваемых переменных из набора по умолчанию)
        if(!$zp_default_set['d_f'] AND in_array('d_f', $constants_to_search))
        {
          // добавляем пустую строку к числу, тем самым преобразуя это число в строку, чтобы поменьше знаков сохранять в базе (без этого сохраняло 20 знаков после запятой почему-то, даже с функцией round)
  		  // заодно округляем до 2 знаков после запятой
          $zp_default_set['d_f'] = round(db_result(db_query("SELECT field_d_percents_value from {content_type_zp_default_set} WHERE nid = %d", $zp_default_set['nid'])) / 100, 2) . '';
        }	
        
        
        // заносим в сессионную переменную значение по умолчанию для минимальной стоимости "дорогого" товара
        // инициализируем данную переменную, только если на неё был запрос из вызываемой функции (массив с перечнем запрашиваемых переменных из набора по умолчанию)
        if(!$zp_default_set['costly_level'] AND in_array('costly_level', $constants_to_search))
          $zp_default_set['costly_level'] = db_result(db_query("SELECT field_costly_level_value from {content_type_zp_default_set} WHERE nid = %d", $zp_default_set['nid']));

		// заносим в сессионную переменную значение по умолчанию для флага способа отображения "дорогого" товара (показывать цену и разрешать доставку (1), показывать цену и не разрешать доставку (2), не показывать цену и не разрешать доставку (3), не показывать товар вообще (4))
        // инициализируем данную переменную, только если на неё был запрос из вызываемой функции (массив с перечнем запрашиваемых переменных из набора по умолчанию)
		if(!$zp_default_set['show_costly'] AND in_array('show_costly', $constants_to_search))
          $zp_default_set['show_costly'] = db_result(db_query("SELECT field_show_costly_value from {content_type_zp_default_set} WHERE nid = %d", $zp_default_set['nid']));        
        
        // сохраняем значение коэффициента доставки по умолчанию в базе (чтобы заново не вычислять для каждого продукта)
        $_SESSION['zp_default_set'] = $zp_default_set;
        
        return $zp_default_set;
}
        
        



function zp_functions_d_factor_otdel($node_tid, $parent_otdel_nid, $user_id)
{
	// определение коэффициента доставки для конкретного юзера и конкретного отдела (с учётом коэф. доставки всех его родительских отделов) 
 	   
	if(!$user_id)
	{
		global $user;
		$user_id = $user->uid;
	}
	
	if(!($d_factor_otdel = $_SESSION['df' . $parent_otdel_nid]))
 	{
 	   	// esli factor dlia otdela eshio ne opredelen, opredeliaem ego (polnostiu copiruem block iz modulia uc_cart.module)
 	   	// задаём массив и первым элементом делаем терм первого отдела, в котором продаётся этот продукт
        $linage_tids = array($node_tid);
        
      	//$linage_tids[] = $node_tid;
        //$save_node_tid = $node_tid;
        
        $count = 1;
        while(($node_tid = db_result(db_query("SELECT parent from {term_hierarchy} WHERE tid  = '%s'", $node_tid))) != 0)
         {
           $linage_tids[] = $node_tid;
           $count++;
         } 

        
        // для примерного понимания... 
        //$item_shop_tid = $linage_tids[$count-4]; // вариант город-район-магазин. 
        //$item_rajon_tid = $linage_tids[$count-3]; // Третьим элементом в этом варианте становится район
        //$item_city_tid = $linage_tids[$count-2]; // при любом варианте город будет вторым элементом после страны
        //$item_country_tid = $linage_tids[$count-1];

        
        for($i = 0; $i <= $count-1; $i++) 
        {
          // начинаем со второго элемента, предполагая, что вторым элементом идёт отдел, в котором находится продукт, потом следуют родительские отделы (если есть), затем магазин, район, город, страна... Страна = $count-1
          // формируем массив нодов с коэфффициентами доставки
          $d_f_nids[$i] = db_result(db_query("SELECT nid from {term_node} WHERE tid = %d", $linage_tids[$i])); 
          
          $d_f_nid_titles[$i] = db_result(db_query("SELECT title from {node} WHERE nid = %d", $d_f_nids[$i])); 
          
          // поле с фактором стоимости доставки во всех типах нод называется d_factor
          // соответственно, когда таких полей несколько (одинаковые в разных типах нодов), эти значения хранятся в таблице content_field_d_factor
          // а значение этой переменной содержится в поле field_d_factor_value таблицы которое можно вычислить по номеру ноды nid
          // формируем массив с коэффициентами стоимости доставки
          $d_f_vals[$i] = db_result(db_query("SELECT field_d_factor_value from {content_field_d_factor} WHERE nid = %d", $d_f_nids[$i])); 
        }
        
        // найдём номер ноды скрытой инфы пользователя
        // считаем, что работаем с текущим пользователем, поэтому и берём ид текущего
        // в принципе, можно потом сделать сложнее - определить пользователя текущей корзины и работать с ним (если админские права позволяю).
  		$user_hi_nid = db_result(db_query("SELECT nid from {node} WHERE title = '%s'", 'u' . $user_id . '-hi')); 
  		
  		
  		//$user_d_f = db_result(db_query("SELECT field_d_factor_value from {content_field_d_factor} WHERE nid = %d", $user_hi_nid));
  		// дополняем массив с коэффициентами стоимости доствки общим коэффициентом конкретного клиента
  		$d_f_vals[++$i] = db_result(db_query("SELECT field_d_factor_value from {content_field_d_factor} WHERE nid = %d", $user_hi_nid));
  		

  		// определим для конкретного клиента отличные от единицы коэффициенты для любимых магазинов, отделов и т.д. , в которых находится этот продукт 
		// и затем добавим их в список коэффициентов для этого продукта (отдела, в котором содержится этот продукт, вообще-то)
		
		// структура сохранённой сессионной переменной для конкретного юзера
		// по идее, она формируется при формировании меню пользователя

		$user_shops_data = $_SESSION['user_shops_data'];		
		
		foreach($user_shops_data as $user_shops)
		{
		   if(in_array($user_shops['nid'], $d_f_nids))
		   		$d_f_vals[++$i] = $user_shops['price_factor'];	
		}


        // перемножаем все коэффициенты и получаем финальный коэффициент
        $final_d_f = 1; 
  		foreach($d_f_vals as $d_f_val)
  		 $final_d_f *= $d_f_val;

        //получим из базы значение процента, который определяет стоимость доставки по умолчанию
        //стоимость доставки товара по умолчанию равна стоимости товара, умноженной на процент по умолчанию 
        //и затем умноженной на только что посчитанный финальный коэффициент доставки
        
        // процент доставки по умолчанию берётся с поля типа d_percents (поле field_d_percents_value в таблице content_type_zp_default_set)
        
        // в этом поле значение содержится в виде процента. Поэтому чтобы получить коэффициент, делим это значение на 100.
        
        //$zp_default_set = array();
        
        // загружаем из базы массив с переменными по умолчанию
        
        
        
        $zp_default_set = zp_functions_get_zp_default_set(array('d_f', 'costly_level', 'show_costly'));
         
        /*
        $zp_default_set = $_SESSION['zp_default_set'];
        
        // если массив пока не определён или в нём не определён параметр nid (номер ноды с параметрами по умолчанию),
        // находим параметр nid и добавляем его в массив
        if(!$zp_default_set OR !$zp_default_set['nid'])
          $zp_default_set['nid'] = db_result(db_query("SELECT nid from {node} WHERE type = '%s'", 'zp_default_set'));
        
        // делим значение процента доставки на 100 и получаем коэффициент
        if(!$zp_default_set['d_f'])
        {
          // добавляем пустую строку к числу, тем самым преобразуя это число в строку, чтобы поменьше знаков сохранять в базе (без этого сохраняло 20 знаков после запятой почему-то, даже с функцией round)
  		  // заодно округляем до 2 знаков после запятой
          $zp_default_set['d_f'] = round(db_result(db_query("SELECT field_d_percents_value from {content_type_zp_default_set} WHERE nid = %d", $zp_default_set['nid'])) / 100, 2) . '';
        }	
        
        
        // заносим в сессионную переменную значение по умолчанию для минимальной стоимости "дорогого" товара
        if(!$zp_default_set['costly_level'])
          $zp_default_set['costly_level'] = db_result(db_query("SELECT field_costly_level_value from {content_type_zp_default_set} WHERE nid = %d", $zp_default_set['nid']));

		// заносим в сессионную переменную значение по умолчанию для флага способа отображения "дорогого" товара (показывать цену и разрешать доставку (1), показывать цену и не разрешать доставку (2), не показывать цену и не разрешать доставку (3), не показывать товар вообще (4))
        if(!$zp_default_set['show_costly'])
          $zp_default_set['show_costly'] = db_result(db_query("SELECT field_show_costly_value from {content_type_zp_default_set} WHERE nid = %d", $zp_default_set['nid']));        
        
        // сохраняем значение коэффициента доставки по умолчанию в базе (чтобы заново не вычислять для каждого продукта)
        $_SESSION['zp_default_set'] = $zp_default_set;
        
        */
       
        
        
        
        // окончательный коэффициент доставки равен коэффициенту по умолчанию $zp_default_set['d_f'], 
        // умноженному на перемноженные все остальные коэффициенты доставки для данного юзера $final_d_f 
        // заодно округляем до 2 знаков после запятой
        $d_factor_otdel = round($final_d_f * $zp_default_set['d_f'], 2) . '';
        
        // сохраним коэффициент доставки для данного отдела в сессионной переменной
        $_SESSION['df' . $parent_otdel_nid] = $d_factor_otdel;
 	   	 	
 	   	 	
	} // end of if(!($d_factor_otdel = $_SESSION['df' . $parent_otdel_nid]))   

	// teper' u nas opredel`n factor dostavki $d_factor_otdel dlia otdela
 	   	 

	return $d_factor_otdel;
	
}























function zp_functions_continue_shopping_link()
{
	

// определим ссылку для линка "Continue shopping" (Продолжить покупки)

// - если прошлая страница была продуктом, отделом, магазином и т.д., значит показываем ссылку на это

// - если прошлая страница какого-то другого типа, значит показываем:

// отдел, если переменная текущего отдела установлена в сессиях
// если отдел не задан, показываем магазин, если переменная текущего магазина установлена в сессиях
// если магазин не задан, показываем текущий город
// или если город не задан... страну, но для страны я пока переменную не задал

    	//$page = uc_referer_uri(); // показывает предыдущую ссылку, но уже испорченную by pathauto
    	
    	
    	
    	//$otd = $_SESSION['current_otdel'];
    	//$sho = $_SESSION['current_shop'];
    	//$cit = $_SESSION['current_city'];
    	//drupal_set_message("0 - otd = $otd, sho = $sho, cit = $cit, page = $page", 'error');
    	
    	$current_tid = NULL;
    	
    	if($current_tid = $_SESSION['current_otdel'])
    	{
    	  
    		$nid = db_result(db_query("SELECT nid from {term_node} WHERE tid  = %d", $current_tid));
    		//drupal_set_message("1 - otd = $otd, sho = $sho, cit = $cit, page = $page", 'error');
         }
    	else 
    	 if($current_tid = $_SESSION['current_shop'])
    	 {
			
    	 	$nid = db_result(db_query("SELECT nid from {term_node} WHERE tid  = %d", $current_tid));
    	 	//drupal_set_message("2 - otd = $otd, sho = $sho, cit = $cit, page = $page", 'error');
    	 }
    	else 
    	 if($current_tid = $_SESSION['current_rajon'])
    	 {
    	  
    	 	$nid = db_result(db_query("SELECT nid from {term_node} WHERE tid = %d", $current_tid));
    	  //drupal_set_message("3 - otd = $otd, sho = $sho, cit = $cit, page = $page", 'error');
    	 }
    	else 
    	 if($current_tid = $_SESSION['current_city'])
    	 {
    	  
    	 	$nid = db_result(db_query("SELECT nid from {term_node} WHERE tid = %d", $current_tid));
    	  //drupal_set_message("3 - otd = $otd, sho = $sho, cit = $cit, page = $page", 'error');
    	 }
    	
    	$continue_shopping['nid'] = $nid;
    	$continue_shopping['tid'] = $current_tid;
    	
    	return $continue_shopping;
    	   
    	//return l(variable_get('uc_continue_shopping_text', t('Continue shopping')), 'node/' . $page); 	

}





function zp_functions_renew_product_data($unser_data, $order_product_nid)
{

// ----------------------------- изменение формата поля data продукта, возвращаемого в корзину


// сейчас формат атрибутов в заказе слегка отличается от стандартного формата атрибутов в корзине
// поэтому при возврате в корзину формат нужно изменить на стандартный

   	        
/*  

// стандартный формат поля data корзины

Array
(
    [attributes] => Array
        (
            [1] => Нет
            [2] => 3
        )

    [model] => 
    [shippable] => 1
    [module] => uc_product
)


// изменённый мною формат поля data корзины

Array
(
    [attributes] => Array
        (
            [Ваши пожелания к товару (укажите)] => Нет
            [Подарочная упаковка (выберите)] => Обёртка
        )

    [model] => 
    [shippable] => 1
    [module] => uc_product
    [#opt_price] => 3
    [#dost_price] => 7.8
)


*/ 	        
	
	
$aids = array();

unset($unser_data['#opt_price']);
unset($unser_data['#dost_price']);

foreach($unser_data['attributes'] as $name => $option)
  {
  	
  	// сохраняем все полученных из базы соответствия aid и oid, а затем считываем их из массива, чтобы лишний раз не обращаться к базе, если в заказе много однотипных товаров с однотипными атрибутами
  	if(!isset($aids[$name]['aid']))
  	{ 
 	  	
  	  	$attrs = db_query("SELECT aid, display from {uc_attributes} WHERE name = '%s'", $name);
        
        while($aid = db_fetch_array($attrs))
        {
        	if($oid = db_result(db_query("SELECT oid FROM {uc_attribute_options} WHERE name = '%s' AND aid = %d", $option, $aid['aid'])))
        	{
        		if(db_result(db_query("SELECT oid FROM {uc_product_options} WHERE oid = %d AND nid = %d", $oid, $order_product_nid)))
        		{
        			$aids[$name]['aid'] = $aid['aid'];
  	  				$aids[$name]['display'] = $aid['display'];
  	  				$aids[$name]['oid'] = $oid;
        			break;
        		}
        	}
        }

  	}
  	
   	if($aids[$name]['display'] == 0) // если этот атрибут - просто текстовое поле
  	 {
  	   unset($unser_data['attributes'][$name]); // удаляем этот элемент из массива и меняем его на другой
  	   
  	   // если эта переменная до сих пор не определена
  	   // значит не было найдено совпадение по опциям атрибута, а это возможно только тогда, когда опция - текст, введённый пользователем
  	   // тогда просто находим атрибут с текущим названием, а если их несколько, то выбираем из них именно текстовый тип
  	   if(!$aids[$name]['aid'])
  	   	$aids[$name]['aid'] = db_result(db_query("SELECT aid FROM {uc_attributes} WHERE name = '%s' AND display = %d", $name, 0));
  	 
  	   $unser_data['attributes'][$aids[$name]['aid']] = $option; // просто меняем название элемента в массиве (имя атрибута меняем на его aid)
  	   continue; 
  	 
  	 } 
  	else
  	//if($aids[$name]['display'] == 1)
  	{
	  unset($unser_data['attributes'][$name]); // удаляем этот элемент из массива и меняем его на другой	

	  // сохраняем все полученных из базы соответствия aid и oid, а затем считываем их из массива, чтобы лишний раз не обращаться к базе, если в заказе много однотипных товаров с однотипными атрибутами
	  if(!isset($aids[$name]['oid']))
  	    {
  	   	  	$aids[$name]['oid'] = db_result(db_query("SELECT oid from {uc_attribute_options} WHERE name  = '%s' AND aid = %d", $option, $aids[$name]['aid']));
  	    }
	  
	  $unser_data['attributes'][$aids[$name]['aid']] = $aids[$name]['oid']; // меняем название элемента в массиве (имя атрибута меняем на его aid)
  	  continue;
  	}

  }

// ----------------------------- конец изменения формата поля data        
  return $unser_data;
}











// ------------ функции определения расстояния

function zp_functions_mapdistance($StartLat = 0, $StartLong = 0, $EndLat = 0, $EndLong = 0)
{

//echo 'StartLat = ' . $StartLat . ', StartLong = ' . $StartLong . ', EndLat = ' . $EndLat . ', EndLong = ' . $EndLong;
	
	
/*
// исходные данные (тестовые) Далее закомментированные результаты показаны именно для этих тестовых координат
$StartLat = 55.45;   // Начальная широта
$StartLong = 37.38;  // Начальная долгота
$EndLat =  52.3;     // Конечная широта
$EndLong = 13.22;    // Конечная долгота

// исходные данные новые
$StartLat = 55.45;   // Начальная широта
$StartLong = 37.38;  // Начальная долгота
$EndLat =  -22.53;     // Конечная широта
$EndLong = -43.14;    // Конечная долгота

// do daninogo
$StartLat = "40°34'" . '46.22"С';
$StartLong = "73°58'" . '6.48"З';
$EndLat = "40°37'" . '53.22"С';
$EndLong = "74° 0'" . '26.93"З';
*/

/*
// do mam inogo
$StartLat = "59°57'" . '23.22"С';
$StartLong = "30°21'" . '17.02"В';
$EndLat = "40°37'" . '53.22"С';
$EndLong = "74° 0'" . '26.93"З';
*/

if(strpos($StartLat, '°') !== FALSE)
	$StartLat =  zp_functions_mapcoord_switch($StartLat);
if(strpos($StartLong, '°') !== FALSE)	
	$StartLong =  zp_functions_mapcoord_switch($StartLong);
if(strpos($EndLat, '°') !== FALSE)	
	$EndLat =  zp_functions_mapcoord_switch($EndLat);
if(strpos($EndLong, '°') !== FALSE)	
	$EndLong =  zp_functions_mapcoord_switch($EndLong);


//echo 'StartLat = ' . $StartLat . ', StartLong = ' . $StartLong . ', EndLat = ' . $EndLat . ', EndLong = ' . $EndLong . '<br><br>';



// Переменные, используемые для вычисления смещения и расстояния

/*
fPhimean  		: Double;                           // Средняя широта
fdLambda  		: Double;                           // Разница между двумя значениями долготы
fdPhi     		: Double;                           // Разница между двумя значениями широты
fAlpha    		: Double;                           // Смещение
fRho      		: Double;                           // Меридианский радиус кривизны
fNu       		: Double;                           // Поперечный радиус кривизны
fR        		: Double;                           // Радиус сферы Земли
fz        		: Double;                           // Угловое расстояние от центра сфероида
fTemp     		: Double;                           // Временная переменная, использующаяся в вычислениях
Distance  		: Double;                           // Вычисленное расстояния в метрах
Bearing   		: Double;                           // Вычисленное от и до смещение

*/


// Константы, используемые для вычисления смещения и расстояния

$D2R = 0.017453;           // Константа для преобразования градусов в радианы
$R2D = 57.295781;          // Константа для преобразования радиан в градусы
$a = 6378137;              // Основные полуоси
$b = 6356752.314245;	   // Неосновные полуоси
$e2 = 0.006739496742337;   // Квадрат эксцентричности эллипсоида
$f = 0.003352810664747;    // Выравнивание эллипсоида


// Вычисляем разницу между двумя долготами и широтами и получаем среднюю широту

$fdLambda = ($StartLong - $EndLong) * $D2R;   // 0,422
$fdPhi = ($StartLat - $EndLat) * $D2R;	      // 0,05497695
$fPhimean = (($StartLat + $EndLat)/2)*$D2R;	  // 0,940280375


// Вычисляем меридианные и поперечные радиусы кривизны средней широты

$fTemp = 1 - $e2*(pow(sin($fPhimean), 2));                	       //0,995603037
$fRho = ($a * (1 - $e2)) / pow($fTemp, 1.5);                 	   //6377165,541
$fNu = $a / (sqrt(1 - $e2 * (sin($fPhimean) * sin($fPhimean))));   //6392205,628


// Вычисляем угловое расстояние

$fz = sqrt(pow(sin($fdPhi / 2.0), 2) + cos($EndLat * $D2R) * cos($StartLat * $D2R) * pow(sin($fdLambda / 2.0), 2));	// 0,126273167
$fz = 2 * asin($fz);	// 0,253222333


// Вычисляем смещение

$fAlpha = cos($EndLat * $D2R) * sin($fdLambda) * (1 / sin($fz));	// 0,999064896	ВНИМАНИЕ! провврить!! яя взялл в скобки  последнее выражение 1/ .in
$fAlpha = asin($fAlpha);	// 1,527547044

//echo 'Смещение fAlpha = ' . $fAlpha . '<br>';

// Вычисляем радиус Земли

$fR = ($fRho * $fNu) / (($fRho * pow(sin($fAlpha), 2))+($fNu * pow(cos($fAlpha), 2)));	//6392177,447

//echo 'радиус Земли fR = ' . $fR . ' м<br>';

// Получаем смещение и расстояние
$Distance = $fz * $fR; // Distance, m, 1618642,088

//echo 'Distance = '. $Distance/1000 . ' км<br>';

if(($StartLat < $EndLat) and ($StartLong < $EndLong))
 {
   $Bearing = abs($fAlpha * $R2D);	// 87,52200088
   //echo '<br>1. ($StartLat < $EndLat) and ($StartLong < $EndLong) => ';
 }
  else
   if(($StartLat < $EndLat) and ($StartLong > $EndLong))
     {
      $Bearing = 360 - abs($fAlpha * $R2D);	//272,4779991
      //echo '<br>2. ($StartLat < $EndLat) and ($StartLong > $EndLong) => ';
     }
      else
        if(($StartLat > $EndLat) and (StartLong>EndLong))
          {
            $Bearing = 180 + abs($fAlpha * $R2D); // 267,5220009
            //echo '<br>3. ($StartLat > $EndLat) and (StartLong>EndLong) => ';
          }
            else
              if(($StartLat > $EndLat) and ($StartLong < $EndLong))
                {
                  $Bearing = 180 - abs($fAlpha * $R2D); // 92,47799912
                  //echo '<br>4. ($StartLat > $EndLat) and ($StartLong < $EndLong) => ';
                }
//echo 'Азимут/Bearing = ' . $Bearing . ' градусов <br>';




$distance_data['distance'] = round($Distance/1000, 2);
$distance_data['bearing'] = round($Bearing, 2);

return $distance_data;
//return $Distance/1000;
}




// изменение входного представления координат

function zp_functions_mapcoord_switch($coord)
{
  //echo 'test 0 = ' . $coord . '<br>';

  $replace1 = array ("°" => " ", "''" => " ", "'" => " ", '"' => ' ');
  $replace2 = array ("  " => " ");

  $coord = strtr(strtr($coord, $replace1), $replace2);

  //echo 'test 1 = ' . $coord . "<br>";

  $coord = explode(" ", $coord);
  $coordNapr = $coord[3];
  $coord = $coord[0]+($coord[1]*60+$coord[2])/3600;

  //echo $coord[0] . ' ' . $coord[1] . ' ' . $coord[2] . '<br>';


  if($coordNapr == 'Ю' OR $coordNapr == 'S' OR $coordNapr == 'З' OR $coordNapr == 'W')
   $coord = -1*$coord;

  //echo 'New $coord = ' . $coord . '<br>';
  //echo '$coordNapr = ' . $coordNapr . '<br>';



  return $coord;

}

  




